//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// @file   Mapi_mhl.h/// @author MStar Semiconductor Inc./// @brief  MHL driver Function////////////////////////////////////////////////////////////////////////////////////////////////////*    1. Check whether MHL cable is plugged or not in Rx side    2. Disable R-term and output Vbus    3. Check whether Cbus is connected(discovery pulse completed)    4. Sink -> Source: "SET_HPD"    5. Sink -> Source: Write_Stat - "DCAP_RDY" and Write_INT - "DCAP_CHG"    6. Sink -> Source: Write_Stat - "PATH_EN"*/#ifndef _MDRV_MHL_ST_H_#define _MDRV_MHL_ST_H_#include "MsTypes.h"#include "MsCommon.h"#ifdef __cplusplusextern "C"{#endif//-------------------------------------------------------------------------------------------------//  Define//-------------------------------------------------------------------------------------------------#define MODIFY_FOR_LG_LAYOUT                0#define DMHL_INT_ENABLE                     0 // MHL interrupt enable#define DMHL_CTS                            1 // MHL setting for CTS#define DMHL_TIMER_POLLING_COUNTER          0#define DMHL_TIMER_POLLING_INTERVAL         (!DMHL_TIMER_POLLING_COUNTER)#define DEM_POLLING_DELAY                   10U     // Main Loop Polling interval (ms)#define CBUS_COMMAND_TIMEOUT_SECS           2U      // No response for 1 second means we hold off and move#define CBUS_ABORT_PADING_SECS              2U      // Allow bus to quieten down when ABORTs are received.#define CBUS_TIMER_CONTROL_MASK             32768U#define CBUS_TIMER_SECOND_COUNT             1010U#define CBUS_MSC_WAIT_TIME_MS               150U#define CBUS_SWITCH_MUX_TIME_MS             3500U#define CBUS_POLLING_TIMER_INTERVAL         10U // Unit ms#define CBUS_WAIT_MSC_RESPONSE_INTERVAL     101U // 10ms one unit#define CBUS_MSG_RCP_RELEASE_INTERVAL       15U // 10ms one unit#define CBUS_CHECK_CONTENT_ON_INTERVAL      101U // 10ms one unit#define MHL_CBUS_0_SECOND_TIME              0U // ms#define MHL_CBUS_1_SECOND_TIME              1000U // ms#define MHL_CBUS_2_SECOND_TIME              2000U // ms#define MHL_CBUS_3_SECOND_TIME              3000U // ms#define MHL_CBUS_4_SECOND_TIME              4000U // ms#define MHL_CBUS_IDEL_FREE_TIME             0U // ms#define MHL_CBUS_CONNECT_SILENCE_TIME       50U // ms#define MHL_CBUS_CONNECT_HOLD_TIME          150U // ms#define MHL_CBUS_SEND_SILENCE_TIME          MHL_CBUS_2_SECOND_TIME // ms#define MHL_CBUS_ABORT_HOLD_TIME            2040U // ms#define MHL_MSG_WAIT_RESPONSE_TIME          MHL_CBUS_1_SECOND_TIME // ms#define MHL_CBUS_RCP_RELEASE_TIME           150 // ms#define MHL_WAIT_WRITE_GRANT_TIME           500U // ms#define MHL_CHECK_RECEIVE_LOSE_TIME         20U // ms#define MHL_MSG_SEND_RESPONSE_TIME          250U // ms#define MHL_CHECK_CONTENT_ON_TIME           MHL_CBUS_1_SECOND_TIME // ms#define MHL_AUTO_SWITCH_STOP_TIME           MHL_CBUS_2_SECOND_TIME // ms#define MHL_WAIT_ECBUS_LOCK_TIME            MHL_CBUS_3_SECOND_TIME // ms#define MHL_AUTO_EQ_PROCESS_TIME            10U // ms#define MHL_WAIT_PATCH_ON_TIME              80U // ms#define MHL_WAIT_PATCH_OFF_TIME             50U // ms#define DMHL_ADOPTER_ID                     0x02CBU // Mstar: 715#define DMHL_DEVICE_ID                      0x0000U // Chip ID?#define DMHL_VENDOR_ID                      0x00U // ?#define MHL_EDID_TABLE_SIZE                 256U#define MHL_DEVICE_CAPABILITY_SIZE          16U#define MHL_XDEVICE_CAPABILITY_SIZE         4U#define MHL_MSC_SCRATCHPAD_SIZE             16U#define MHL_CBUS_DATA_SIZE                  (MHL_MSC_SCRATCHPAD_SIZE +2) // offset + maxi 16 packets#define DMHL_CBUS_TX_FIFO                   (MHL_MSC_SCRATCHPAD_SIZE +3) // Write_Burst(0x6C) + offset(0x40 ~ 0x7F) + maxi 16 packets + EOF(0x32)#define MHL_CBUS_TX_QUEUE_NUM               3U#define MHL_CBUS_TOTAL_QUEUE_NUM            ((MHL_CBUS_TX_QUEUE_NUM > 0)?(MHL_CBUS_TX_QUEUE_NUM +1):2)#define MHL_CBUS_RX_QUEUE_INDEX             (MHL_CBUS_TOTAL_QUEUE_NUM -1)#define MHL_EMSC_DATA_SIZE                  256U#define MHL_EMSC_DATA_SIZE_THRESHOLD        150U#define DMHL_CTS_HDCP_PATCH                 DISABLE// for CTS HDCP 2C-04#define DMHL_LG_PRADA_PATCH                 ENABLE// for LG PRADA patch#define DMHL_IGNORE_USB_PULSE_PATCH         ENABLE // for ignore USB pulse patch#define DMHL_DE_UNSTABLE_PATCH              ENABLE#define DMHL_WAKE_UP_PULSE_INT              ENABLE#define DMHL_CTS_SEND_MSC                   ENABLE#define DMHL_TEST_HDCP_SOFTWARE_PATCH       ENABLE#define DMHL_AUTO_SENT_RAP_POLLING          DISABLE#define DMHL_TEST_SIGNAL_SUPPORT            DISABLE#define MHL_INPUT_PORT(a)                   (a +65)#define MASKSET(a, b, c)                    ((a &~c) | (b &c))#define ABS_MINUS(a, b)                     ((a > b)? (a -b): (b -a))#define GET_BIT(a)                          (((a) > 0)? 1: 0)#define MHL_EDID_BLOCK_LENGTH               128U#define MHL_EDID_DTD_LENGTH                 18U#define MHL_EDID_FIRST_DTD_START            0x36U#define MHL_EDID_SECOND_DTD_START           0x48U#define MHL_EDID_EXTENSION_FLAG             0x7EU  #define MHL_EDID_RESERVED_DATA_BLOCK        0x82U#define MHL_3D_SEQUENCE_LENGTH              5U#define MHL_3D_ITEM_LENGTH                  2U#define MHL_3D_DTD_INFORMATION_LENGTH       8U#define MHL_3D_VIC_INFORMATION_LENGTH       16U#define MHL_VC_SEQUENCE_LENGTH              3U#define MHL_VC_ITEM_LENGTH                  3U#define MHL_VIRTUAL_CHANNEL_LENGTH          7U#define MHL_CBUS1_TIME_SLOT_DEFAULT         1U#define MHL_EMSC_TIME_SLOT_DEFAULT          4U#define MHL_ECBUS_S_TIME_SLOT_TOTAL         25U#define MHL_CBUS_SLOT_NOT_ALLOCATE          0xFFU#define MHL_HEV_VIC_SEQUENCE_LENGTH         5U#define MHL_HEV_VIC_ITEM_LENGTH             2U#define MHL_HEV_VIC_TOTAL_ENTRY             3U#define MHL_HEV_VIC_INFORMATION_LENGTH      6U#define MHL_HEV_VIC_INDEX0                  0x5DU#define MHL_HEV_VIC_INDEX1                  0x5EU#define MHL_HEV_VIC_INDEX2                  0x5FU#define MHL_HEV_VIC_INDEX3                  0x62U#define MHL_HEV_VIC_INDEX4                  0x63U#define MHL_HEV_VIC_INDEX5                  0x64U#define MHL_HEV_DTD_SEQUENCE_LENGTH         1U#define MHL_HEV_DTD_TOTAL_ENTRY             1U#define MHL_AUDIO_TUNNEL_SEQUENCE_LENGTH    3U#define MHL_AUDIO_TUNNEL_ITEM_LENGTH        3U#define MHL_AUDIO_TUNNEL_SAD_RNTRY          1U // Short audio descriptors#define MHL_AUDIO_TUNNEL_SADB_RNTRY         0U // Speaker allocation data block#define MHL_AUDIO_TUNNEL_TOTAL_ENTRY        (MHL_AUDIO_TUNNEL_SAD_RNTRY +MHL_AUDIO_TUNNEL_SADB_RNTRY)#define MHL_AUDIO_TUNNEL_INFORMATION_LENGTH 6U#define MHL_AUDIO_TUNNEL_INDEX0             0UL#define MHL_AUDIO_TUNNEL_INDEX1             0UL#define MHL_AUDIO_TUNNEL_INDEX2             0UL#define MHL_AUDIO_TUNNEL_INDEX3             0UL#define MHL_AUDIO_TUNNEL_INDEX4             0UL#define MHL_AUDIO_TUNNEL_INDEX5             0UL#define MHL_EMSC_SUPPORT_SEQUENCE_LENGTH    5U#define MHL_EMSC_SUPPORT_ITEM_LENGTH        2U#define MHL_EMSC_SUPPORT_TOTAL_ENTRY        1U#define MHL_EMSC_SUPPORT_INFORMATION_LENGTH 6U#define MHL_EMSC_SUPPORT_BURST_ID0          0x0062U // MHL_BURST_ID_HID_PAYLOAD#define MHL_EMSC_SUPPORT_BURST_ID1          0U#define MHL_EMSC_SUPPORT_BURST_ID2          0U#define MHL_EMSC_SUPPORT_BURST_ID3          0U#define MHL_EMSC_SUPPORT_BURST_ID4          0U#define MHL_EMSC_SUPPORT_BURST_ID5          0U#define MHL_ADOPTER_ID_ROKU                 0x0411U#define MHL_ADOPTER_ID_HTC                  0x016FU#define MHL_DEVICE_ID_HTC                   0x0000U#define MHL_ADOPTER_ID_SONY                 0x03A7U#define MHL_POLLING_STACK_SIZE              1U#define MHL_POLLING_INTERVAL_NORMAL         20U#define MHL_POLLING_INTERVAL_BUSY           4U//-------------------------------------------------------------------------------------------------//  Type and Structure//-------------------------------------------------------------------------------------------------enum MHL_QUEUE_STATE_TYPE{    MHL_QUEUE_STATE_IDLE = 0,    MHL_QUEUE_STATE_SEND,    MHL_QUEUE_STATE_PENDING,    MHL_QUEUE_STATE_RETRY,};enum MHL_CLEAR_CBUS_FLAG_TYPE{    MHL_CLEAR_INITIAL_FLAG = 0,    MHL_CLEAR_CABLE_LOSS_FLAG,    MHL_CLEAR_CONNECT_LOSS_FLAG,    MHL_CLEAR_CBUS_TIME_OUT_FLAG,    MHL_CLEAR_MSG_RESPONSE_FLAG,};enum CBUS_HEADER_TYPE{    DDC_HEADER = 0,    VENDER_HEADER,    MSC_HEADER,};enum CBUS_CONTROL_TYPE{    CBUS_DATA = 0,    CBUS_CONTROL,};enum CBUS_RECEIVE_STATE_TYPE{    CBUS_RECEIVE_NORMAL = 0,    CBUS_RECEIVE_TIMEOUT,};enum MHL_PHY_CLOCK_MODE_TYPE{    MHL_PHY_CLOCK_RESERVED = 0,    MHL_PHY_CLOCK_PACKET_PIXEL = 2,    MHL_PHY_CLOCK_NORMAL_24BIT,};enum MHL_VIEW_PIXEL_FORMATE_TYPE{    MHL_VIEW_PIXEL_FORMATE_24BPP = 0,    MHL_VIEW_PIXEL_FORMATE_16BPP,};enum VBUS_CONTROL_TYPE{    VBUS_SW_UNCHARGE = 0,    VBUS_HW_DETECT,    VBUS_SW_CHARGE,};enum MHL_3D_SUPPORT_TYPE{    MHL_3D_FS_SUPPORT = BIT(0),    MHL_3D_TB_SUPPORT = BIT(1),    MHL_3D_LR_SUPPORT = BIT(2),};enum MHL_3D_DTD_NUMBER_TYPE{    MHL_3D_FIRST_DTD = 0,    MHL_3D_SECOND_DTD,    MHL_3D_THIRD_DTD,};enum MHL_3D_DTD_STEREO_TYPE{    MHL_3D_DTD_STEREO_NORMAL_DISPLAY = 0,    MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_RIGHT = 2,    MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_LEFT = 4,    MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_RIGHT = 3,    MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_LEFT = 5,    MHL_3D_DTD_STEREO_4WAY_INTERLEAVED = 6,    MHL_3D_DTD_STEREO_SIDE_BY_SIDE_INTERLEAVED = 7,};enum MHL_EDID_DATA_BLOCK_CODE_TYPE{    MHL_EDID_AUDIO_DATA_BLOCK_CODE = 1,    MHL_EDID_VIDEO_DATA_BLOCK_CODE = 2,    MHL_EDID_VENDER_SPECIFIC_DATA_BLOCK_CODE = 3,    MHL_EDID_SPEAKER_ALLOCATION_DATA_BLOCK_CODE = 4,    MHL_EDID_VESA_DTC_DATA_BLOCK_CODE = 5,    MHL_EDID_USE_EXTENDED_TAG_BLOCK_CODE = 7,};enum MHL_VIC_PARSING_STATE_TYPE{    MHL_VIC_PARSING_START = 0,    MHL_VIC_PARSING_CHECK_HDMI_VIDEO_PRESENT,    MHL_VIC_PARSING_CHECK_3D_PRESENT,    MHL_VIC_PARSING_CHECK_HDMI_VIC,    MHL_VIC_PARSING_3D_MULTI_PRESENT_00,    MHL_VIC_PARSING_3D_MULTI_PRESENT_01,    MHL_VIC_PARSING_3D_MULTI_PRESENT_10,    MHL_VIC_PARSING_CHECK_3D_STRUCTURE,    MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING,    MHL_VIC_PARSING_FINISH,};enum MHL_3D_PRESENT_TIMING_VIC_TYPE{    MHL_3D_PRESENT_VIC_1920x1080p24Hz = 32,    MHL_3D_PRESENT_VIC_1280x720p60Hz = 4,    MHL_3D_PRESENT_VIC_1920x1080i60Hz = 5,    MHL_3D_PRESENT_VIC_1280x720p50Hz = 19,    MHL_3D_PRESENT_VIC_1920x1080i50Hz = 20,};typedef enum{    RX_HDMI_RTERM = 0,    // HDMI mode    RX_MHL_RTERM,    // MHL mode    RX_RTERM_OFF,    // R-term off} RXRtermControl_T;enum MHL_CBUS_WRITE_BURST_STATE_TYPE{    MHL_CBUS_WRITE_BURST_NONE = 0,    MHL_CBUS_WRITE_BURST_START,    MHL_CBUS_WRITE_BURST_SEND_REQUEST,    MHL_CBUS_WRITE_BURST_REVEIVE_GRANT,    MHL_CBUS_WRITE_BURST_SEND_DATA,    MHL_CBUS_WRITE_BURST_REVEIVE_REQUEST,    MHL_CBUS_WRITE_BURST_SEND_GRANT,    MHL_CBUS_WRITE_BURST_RECEIVE_DATA,    MHL_CBUS_WRITE_BURST_END,};enum MHL_CBUS_SEND_WRITE_BURST_TYPE{    MHL_CBUS_SEND_WRITE_BURST_NONE = 0,    MHL_CBUS_SEND_WRITE_BURST_USER_DATA,    MHL_CBUS_SEND_WRITE_BURST_3D_INFORMATION,    MHL_CBUS_SEND_WRITE_BURST_VIRTUAL_CHANNEL,    MHL_CBUS_SEND_WRITE_BURST_HIGH_END_VIDEO,    MHL_CBUS_SEND_WRITE_BURST_AUDIO_DATA_TUNNEL,    MHL_CBUS_SEND_WRITE_BURST_EMSC_DATA_TUNNEL,    MHL_CBUS_SEND_WRITE_BURST_BIST_RETURN_STATUS,};enum MHL_CBUS_RUSB_PROCESS_STATE_TYPE{    MHL_CBUS_RUSB_NONE = 0,    MHL_CBUS_RUSB_START,    MHL_CBUS_RUSB_SOURCE_HOST,    MHL_CBUS_RUSB_REQUEST_HOST,    MHL_CBUS_RUSB_SINK_HOST,    MHL_CBUS_RUSB_RELINQUISH,    MHL_CBUS_RUSB_END,};enum MHL_CBUS_RHID_PROCESS_STATE_TYPE{    MHL_CBUS_RHID_NONE = 0,    MHL_CBUS_RHID_START,    MHL_CBUS_RHID_SOURCE_HOST,    MHL_CBUS_RHID_REQUEST_HOST,    MHL_CBUS_RHID_SINK_HOST,    MHL_CBUS_RHID_RELINQUISH,    MHL_CBUS_RHID_END,};enum MHL_CBUS_BIST_PROCESS_STATE_TYPE{    MHL_CBUS_BIST_NONE = 0,    MHL_CBUS_BIST_RECEIVE_SETUP,    MHL_CBUS_BIST_WAIT_TRIGGER,    MHL_CBUS_BIST_RECEIVE_TRIGGER,    MHL_CBUS_BIST_ECBUS_SWITCH,    MHL_CBUS_BIST_EVENT_FINISH,    MHL_CBUS_BIST_REQUEST_STATUS,    MHL_CBUS_BIST_RETURN_STATUS,    MHL_CBUS_BIST_END,};enum MHL_CBUS_FEATURE_REQUEST_STATE_TYPE{    MHL_CBUS_FEATURE_NONE = 0,    MHL_CBUS_FEATURE_START,    MHL_CBUS_FEATURE_SEND_3D_INFORMATION,    MHL_CBUS_FEATURE_SEND_HIGH_END_VIDEO,    MHL_CBUS_FEATURE_SEND_AUDIO_DATA_TUNNEL,    MHL_CBUS_FEATURE_SEND_EMSC_DATA_TUNNEL,    MHL_CBUS_FEATURE_SEND_FEATURE_COMPLETE,    MHL_CBUS_FEATURE_SEND_FEATURE_REQUEST,    MHL_CBUS_FEATURE_END,};enum MHL_ECBUS_STATE_TYPE{    MHL_ECBUS_STATE_NONE = 0,    MHL_ECBUS_STATE_RECEIVE_MODE_UP,    MHL_ECBUS_STATE_TRIGGER_MODE_UP,    MHL_ECBUS_STATE_PROCESS_MODE_UP,    MHL_ECBUS_STATE_MODE_UP_CLOCK_LOCK,    MHL_ECBUS_STATE_RECEIVE_MODE_DOWN,    MHL_ECBUS_STATE_TRIGGER_MODE_DOWN,    MHL_ECBUS_STATE_PROCESS_MODE_DOWN,    MHL_ECBUS_STATE_STABLE_POLLING,    MHL_ECBUS_STATE_UNLOCK_RESET,    MHL_ECBUS_STATE_BIST_MODE_UP,    MHL_ECBUS_STATE_BIST_MODE_DOWN,    MHL_ECBUS_STATE_END,};enum MHL_ECBUS_EVENT_TYPE{    MHL_ECBUS_EVENT_NONE = 0,    MHL_ECBUS_EVENT_PREPARE_MODE_UP,    MHL_ECBUS_EVENT_MODE_UP_PROCESS,    MHL_ECBUS_EVENT_PREPARE_MODE_DOWN,    MHL_ECBUS_EVENT_MODE_DOWN_PROCESS,    MHL_ECBUS_EVENT_UNLOCK_RESET,    MHL_ECBUS_EVENT_STUCK_TO_LOW,    MHL_ECBUS_EVENT_ECBUS_COMMAND_PARSING,    MHL_ECBUS_EVENT_BIST_TRIGGER,    MHL_ECBUS_EVENT_POWER_ON_PATCH_ON,    MHL_ECBUS_EVENT_POWER_ON_PATCH_OFF,};enum MHL_ECBUS_STATUS_FLAG_TYPE{    MHL_ECBUS_STATUS_TRAINING_PASS = BIT(0),    MHL_ECBUS_STATUS_CLOCK_LOCK = BIT(1),    MHL_ECBUS_STATUS_SLOT_SYNC_DONE = BIT(2),    MHL_ECBUS_STATUS_EMSC_SYNC_DONE = BIT(3),    MHL_ECBUS_STATUS_RETRY_TIMEOUT = BIT(4),};enum MHL_EMSC_SEND_STATUS_TYPE{    MHL_EMSC_SEND_NONE = 0,    MHL_EMSC_SEND_DATA,    MHL_EMSC_SEND_CHECK,    MHL_EMSC_SEND_PASS,    MHL_EMSC_SEND_FAIL,};enum MHL_ECBUS_TRAINING_STATE_TYPE{    MHL_ECBUS_STATE_DISABLE = 0,    MHL_ECBUS_STATE_WAIT_CLOCK_LOCK,    MHL_ECBUS_STATE_WAIT_SEND_CLOCK,    MHL_ECBUS_STATE_SEND_CLOCK,    MHL_ECBUS_STATE_SEND_COMMA1,    MHL_ECBUS_STATE_RECEIVE_COMMA2,    MHL_ECBUS_STATE_SEND_COMMA2,    MHL_ECBUS_STATE_SOURCE_ACTIVE,    MHL_ECBUS_STATE_ACTIVE,    MHL_ECBUS_STATE_FAIL = 10,    MHL_ECBUS_STATE_TRAINING_NONE,};enum MHL_ECBUS_TRAIN_STATE_TYPE{    MHL_ECBUS_TRAIN_IDLE = 0,    MHL_ECBUS_TRAIN_WAIT_CLOCK_LOCK,    MHL_ECBUS_TRAIN_ADJUST_TXLOC,    MHL_ECBUS_TRAIN_ADJUST_TXLOC_OK,    MHL_ECBUS_TRAIN_DELAY_REVERIFY,    MHL_ECBUS_TRAIN_WAIT_RRCEIVE_COMMA2,    MHL_ECBUS_TRAIN_ADJUST_CAP,    MHL_ECBUS_TRAIN_DONE,    MHL_ECBUS_TRAIN_FAIL,};enum{    MSC_NONE = 0x00,    MSC_ACK = 0x33,                     // Command/Data byte acknowledged    MSC_NACK = 0x34,                    // Command or Data byte not acknowledge    MSC_ABORT = 0x35,                   // Transaction abort    MSC_WRITE_STAT_OR_SET_INT = 0x60,   // Write one status or interrupt register    MSC_READ_DEVCAP = 0x61,             // Read one register    MSC_GET_STATE = 0x62,               // Read CBUS revision level from follower    MSC_GET_VENDOR_ID = 0x63,           // Read vendor ID value from follower.    MSC_SET_HPD = 0x64,                 // Set Hot Plug Detect in follower    MSC_CLR_HPD = 0x65,                 // Clear Hot Plug Detect in follower    MSC_MSC_MSG = 0x68,                 // VS command to send RCP sub-commands    MSC_GET_SC1_ERRORCODE = 0x69,       // Get Vendor-Specific command error code.    MSC_GET_DDC_ERRORCODE = 0x6A,       // Get DDC channel command error code.    MSC_GET_MSC_ERRORCODE = 0x6B,       // Get MSC command error code.    MSC_WRITE_BURST = 0x6C,             // Write 1-16 bytes to responder’s scratchpad.    MSC_GET_SC3_ERRORCODE = 0x6D,       // Get channel 3 command error code.    MSC_WRITE_XSTAT = 0x70,             // Extend write one status    MSC_READ_XDEVCAP = 0x71,            // Extend read device capability    MSC_EOF = 0x32,                     // End of Frame    MSC_RESERVED = 0xFF,}; //MscCtrlPkt_T;enum{    MSC_MSG_MSGE = 0x02,                // MSG Error sub-command    MSC_MSG_RCP = 0x10,                 // RCP sub-command    MSC_MSG_RCPK = 0x11,                // RCP Acknowledge sub-command    MSC_MSG_RCPE = 0x12,                // RCP Error sub-command    MSC_MSG_RAP = 0x20,                 // Mode Change Warning sub-command    MSC_MSG_RAPK = 0x21,                // MCW Acknowledge sub-command    MSC_MSG_RBP = 0x22,                 // Remote Button Protocol sub- command    MSC_MSG_RBPK = 0x23,                // RBP Acknowledge sub-command    MSC_MSG_RBPE = 0x24,                // RBP Error sub-command    MSC_MSG_UCP = 0x30,                 // UCP sub-command    MSC_MSG_UCPK = 0x31,                // UCP Acknowledge sub-command    MSC_MSG_UCPE = 0x32,                // UCP Error sub-command    MSC_MSG_RUSB = 0x40,                // Request USB host role    MSC_MSG_RUSBK = 0x41,               // Acknowledge request for USB host role    MSC_MSG_RHID = 0x42,                // Request HID host role    MSC_MSG_RHIDK = 0x43,               // Acknowledge request for HID host role    MSC_MSG_ATT = 0x50,                 // Request Attention sub-command    MSC_MSG_ATTK = 0x51,                // ATT Acknowledge sub-command    MSC_MSG_BIST_TRIGGRT = 0x60,        // BIST Trigger sub-command    MSC_MSG_BIST_REQUEST_STAT = 0x61,   // BIST Request Status sub-command    MSC_MSG_BIST_READY = 0x62,          // BIST Ready sub-command    MSC_MSG_BIST_STOP = 0x63,           // BIST Stop sub-command    MSC_MSG_SI_UNKNOWN = 0xF0,          // SI used unknow sub-command    MSC_MSG_SI_UNKNOWNK = 0xF1,         // SI used unknow acknowledge sub-command}; //MscMsgSubCmd_T;enum{    MSC_ERRORCODE_NO_ERROR = 0x00,    // Normal response, no error    MSC_ERRORCODE_RETRY_EXCEEDED = 0x01,    // Re-try threshold exceeded    MSC_ERRORCODE_PROTOCOL_ERROR = 0x02,    // Protocol error    MSC_ERRORCODE_PEER_TIMEOUT = 0x04,    // Peer timed out    MSC_ERRORCODE_INVALID_OPCODE = 0x08,    // Invalid op code    MSC_ERRORCODE_BAD_OFFSET = 0x10,    // Bad offset in command    MSC_ERRORCODE_PEER_BUSY = 0x20,    // Peer is busy, can't process new request};enum MHL_MSGE_STATUS_CODE{    MHL_MSGE_NO_ERROR = 0x00,     // MSGE No Error    MHL_MSGE_INVALID_SUB_COMMAND_CODE = 0x01,};enum MHL_RCP_STATUS_CODE{    MHL_RCP_NO_ERROR = 0x00,     // RCP No Error    MHL_RCP_INEFFECTIVE_KEY_CODE = 0x01,     // The key code in the RCP sub-command is not recognized    MHL_RCP_RESPONDER_BUSY = 0x02,     // RCP Response busy};enum MHL_RAP_STATUS_CODE{    MHL_RAP_NO_ERROR = 0x00,     // RAP No Error    MHL_RAP_UNRECOGNIZED_ACTION_CODE = 0x01,    MHL_RAP_UNSUPPORTED_ACTION_CODE = 0x02,    MHL_RAP_RESPONDER_BUSY = 0x03,};enum MHL_UCP_STATUS_CODE{    MHL_UCP_NO_ERROR = 0x00,     // UCP No Error    MHL_UCP_INEFFECTIVE_KEY_CODE = 0x01,     // The key code in the UCP sub-command is not recognized};enum MHL_ATT_STATUS_CODE{    MHL_ATT_NO_ERROR = 0x00,     // ATT No Error    MHL_ATT_UNRECOGNIZED_ACTION_CODE = 0x01,     // The key code in the ATT sub-command is not recognized    MHL_ATT_UNSUPPORTED_ACTION_CODE = 0x02,    MHL_ATT_RESPONDER_BUSY = 0x03,};enum MHL_RBP_STATUS_CODE{    MHL_RBP_NO_ERROR = 0x00,     // RBP No Error    MHL_RBP_INEFFECTIVE_BUTTON_CODE = 0x01,     // The key code in the RBP sub-command is not recognized    MHL_RBP_RESPONDER_BUSY = 0x02,     // RBP Response busy};enum MHL_RUSB_STATUS_CODE{    MHL_RUSB_NO_ERROR = 0x00,     // RUSB No Error    MHL_RUSB_INVALID_CODE = 0x01,        MHL_RUSB_DENY = 0x02,     };enum MHL_RHID_STATUS_CODE{    MHL_RHID_NO_ERROR = 0x00,     // RHID No Error    MHL_RHID_INVALID_CODE = 0x01,        MHL_RHID_DENY = 0x02,     };enum MHL_BIST_REQ_KEY_TYPE{    MHL_BIST_REQ_NOTHING = 0x00,    MHL_BIST_REQ_RETURN_STATUS = 0x01,};enum MHL_VC_FEATURE_ID_TYPE{    MHL_VC_FEATURE_ID_EMSC = 0x00,    MHL_VC_FEATURE_ID_USB = 0x01,    MHL_VC_FEATURE_ID_AUDIO = 0x02,    MHL_VC_FEATURE_ID_IP_PACKET = 0x03,    MHL_VC_FEATURE_ID_COMPRESSED_VIDEO = 0x04,    MHL_VC_FEATURE_ID_HID = 0x05,    MHL_VC_FEATURE_ID_END,};enum MHL_VC_RESPONSE_CODE_TYPE{    MHL_VC_RESPONSE_ACCEPT = 0x00,    MHL_VC_RESPONSE_REJECT_NUMBER = 0x01,    MHL_VC_RESPONSE_REJECT_FEATURE_ID = 0x02,    MHL_VC_RESPONSE_REJECT_CHANNEL_SIZE = 0x03,};enum CBUS_DEVCAP_TYPE{    MHL_CBUS_DEV_STATE = 0,    MHL_CBUS_VERSION,    MHL_CBUS_DEV_CAT,    MHL_CBUS_ADOPTER_ID_H,    MHL_CBUS_ADOPTER_ID_L,    MHL_CBUS_VID_LINK_MODE,    MHL_CBUS_AUD_LINK_MODE,    MHL_CBUS_VIDEO_TYPE,    MHL_CBUS_LOG_DEV_MAP,    MHL_CBUS_BANDWIDTH,    MHL_CBUS_FEATURE_FLAG,    MHL_CBUS_DEVICE_ID_H,    MHL_CBUS_DEVICE_ID_L,    MHL_CBUS_SCRATCHPAD_SIZE,    MHL_CBUS_INT_STAT,    MHL_CBUS_RESERVED,    MHL_CBUS_ECBUS_SPEEDS,    MHL_CBUS_TMDS_SPEEDS,    MHL_CBUS_ECBUS_DEV_ROLES,    MHL_CBUS_LOG_DEV_MAPX,};enum MHL_DEVICE_TYPE{    MHL_DEVICE_SINK = 1,    MHL_DEVICE_SOURCE = 2,    MHL_DEVICE_DONGLE = 3,    MHL_DEVICE_DIRECT_ATTACH_SINK = 5,    MHL_DEVICE_DIRECT_ATTACH_SOURCE = 6,};enum MHL_AV_LINK_RATE_TYPE{    MHL_AV_LINK_150 = 0,    MHL_AV_LINK_300,    MHL_AV_LINK_600,    MHL_AV_LINK_NONE,};enum MHL_BIST_AV_LINK_RATE_TYPE{    MHL_BIST_AV_LINK_RESERVED = 0,    MHL_BIST_AV_LINK_150 = 1,    MHL_BIST_AV_LINK_300 = 2,    MHL_BIST_AV_LINK_600 = 3,};enum MHL_BIST_ECBUS_PATTERN_TYPE{    MHL_BIST_ECBUS_PATTERN_RESERVED = 0,    MHL_BIST_ECBUS_PATTERN_PRBS = 1,    MHL_BIST_ECBUS_PATTERN_FIXED8 = 2,    MHL_BIST_ECBUS_PATTERN_FIXED10 = 3,};enum MHL_BIST_LINK_PATTERN_TYPE{    MHL_BIST_LINK_PATTERN_RESERVED = 0,    MHL_BIST_LINK_PATTERN_PRBS = 1,    MHL_BIST_LINK_PATTERN_FIXED8 = 2,    MHL_BIST_LINK_PATTERN_FIXED10 = 3,};enum MHL_BIST_IMPEDANCE_MODE_TYPE{    MHL_BIST_IMPEDANCE_AV_LINK_TX_LOW = 0,    MHL_BIST_IMPEDANCE_AV_LINK_TX_HIGH = 1,    MHL_BIST_IMPEDANCE_AV_LINK_RX = 2,    MHL_BIST_IMPEDANCE_ECBUS_D_TX_LOW = 4,    MHL_BIST_IMPEDANCE_ECBUS_D_TX_HIGH = 5,    MHL_BIST_IMPEDANCE_ECBUS_D_RX = 6,    MHL_BIST_IMPEDANCE_ECBUS_S_TX_LOW = 8,    MHL_BIST_IMPEDANCE_ECBUS_S_TX_HIGH = 9,    MHL_BIST_IMPEDANCE_ECBUS_S_RX = 10,};enum MHL_RAP_KEY_TYPE{    MHL_RAP_KEY_POLL = 0x00,    MHL_RAP_KEY_CONTENT_ON = 0x10,    MHL_RAP_KEY_CONTENT_OFF = 0x11,    MHL_RAP_KEY_CBUS_MODE_DOWN = 0x20,    MHL_RAP_KEY_CBUS_MODE_UP = 0x21,};enum MHL_BURST_ID_TYPE{    MHL_BURST_ID_3D_VIC = 0x0010,    MHL_BURST_ID_3D_DTD = 0x0011,    MHL_BURST_ID_HEV_VIC = 0x0020,    MHL_BURST_ID_HEV_DTDA = 0x0021,    MHL_BURST_ID_HEV_DTDB = 0x0022,    MHL_BURST_ID_VC_ASSIGN = 0x0038,    MHL_BURST_ID_VC_CONFIRM = 0x0039,    MHL_BURST_ID_AUD_DELAY = 0x0040,    MHL_BURST_ID_ADT_BURSTID = 0x0041,    MHL_BURST_ID_BIST_SETUP = 0x0051,    MHL_BURST_ID_BIST_RETURN_STAT = 0x0052,    MHL_BURST_ID_BIST_DISCARD = 0x0053,    MHL_BURST_ID_BIST_ECHO_REQUEST = 0x0054,    MHL_BURST_ID_BIST_ECHO_RESPONSE = 0x0055,    MHL_BURST_ID_EMSC_SUPPORT = 0x0061,    MHL_BURST_ID_HID_PAYLOAD = 0x0062,    MHL_BURST_ID_BLK_RCV_BUFFER_INFO = 0x0063,    MHL_BURST_ID_BITS_PER_PIXEL_FMT = 0x0064,};enum MHL_VIC_INDEX_TYPE{    MHL_VIC_INDEX1 = 1,     // 640x480p@60    MHL_VIC_INDEX2,         // 720x480p@60    MHL_VIC_INDEX3,         // 720x480p@60    MHL_VIC_INDEX4,         // 1280x720p@60    MHL_VIC_INDEX5,         // 1920x1080i@60    MHL_VIC_INDEX6,         // 720x480i@60    MHL_VIC_INDEX7,         // 720x480i@60    MHL_VIC_INDEX16 = 16,   // 1920x1080p@60    MHL_VIC_INDEX17,        // 720x576p@50    MHL_VIC_INDEX18,        // 720x576p@50    MHL_VIC_INDEX19,        // 1280x720p@50    MHL_VIC_INDEX20,        // 1920x1080i@50    MHL_VIC_INDEX21,        // 720x576i@50    MHL_VIC_INDEX22,        // 720x576i@50    MHL_VIC_INDEX31 = 31,   // 1920x1080p@50    MHL_VIC_INDEX34 = 34,   // 1920x1080p@30    MHL_VIC_INDEX63 = 63,   // 1920x1080p@120    MHL_VIC_INDEX64,        // 1920x1080p@100    MHL_VIC_INDEX93 = 93,   // 3840x2160p@24    MHL_VIC_INDEX94,        // 3840x2160p@25    MHL_VIC_INDEX95,        // 3840x2160p@30    MHL_VIC_INDEX98 = 98,   // 4096x2160p@24    MHL_VIC_INDEX99,        // 4096x2160p@25    MHL_VIC_INDEX100,       // 4096x2160p@30};enum MHL_TIMER_EVENT_TYPE{    MHL_TIMER_EVENT_CBUS_SILENCE = 0,    MHL_TIMER_EVENT_DISPLAY_COMMAND,    MHL_TIMER_EVENT_WAIT_MSG_RESPONSE,    MHL_TIMER_EVENT_RCP_AUTO_RELEASE,    MHL_TIMER_EVENT_WAIT_WRITE_GRANT,    MHL_TIMER_EVENT_CHECK_RECEIVE_LOSE,    MHL_TIMER_EVENT_SEND_MSG_RESPONSE,    MHL_TIMER_EVENT_CHECK_CONTENT_ON,    MHL_TIMER_EVENT_AUTO_SWITCH_STOP,    MHL_TIMER_EVENT_WAIT_ECBUS_LOCK,    MHL_TIMER_EVENT_AUTO_EQ_PROCESS,    MHL_TIMER_EVENT_BIST_PROCESS,    MHL_TIMER_EVENT_TX_QUQUE_FREEZE,    MHL_TIMER_EVENT_POWER_ON_PATCH,    MHL_TIMER_EVENT_MASK,};enum MHL_POWER_ON_PATCH_STATE_TYPE{    MHL_POWER_ON_PATCH_STATE_NONE = 0,    MHL_POWER_ON_PATCH_STATE_START,    MHL_POWER_ON_PATCH_STATE_WAIT_PATCH_ON,    MHL_POWER_ON_PATCH_STATE_PATCH_ON,    MHL_POWER_ON_PATCH_STATE_WAIT_PATCH_OFF,    MHL_POWER_ON_PATCH_STATE_PATCH_OFF,    MHL_POWER_ON_PATCH_STATE_DONE,};typedef struct{    MS_BOOL bEnableFlag;    MS_U16 usTimerTick;} stMHL_TIMER_EVENT_INFO;typedef struct{    MS_U8 ucQueueState;    MS_U8 ucData[MHL_CBUS_DATA_SIZE +1];    // Cbus message data    MS_U8 ucCommand;    // MSC command    MS_U8 ucLength;    // message length} stMHL_QUEUE_INFO;typedef struct{    MS_U8 lens;    MS_U16 databuf[DMHL_CBUS_TX_FIFO];} mhalCbusFifo_S;typedef struct{    MS_BOOL bVCConfirm;    MS_U8 ucVCNumber;    MS_U8 ucVCSlotSize;    MS_U8 ucVCResponseCode;    MS_U8 ucVCFeatureID;} stMHL_VIRTUAL_CHANNEL_INFO;typedef struct{    MS_BOOL bBISTeCbusTxFlag;    MS_BOOL bBISTeCbusRxFlag;    MS_U8 ucBISTReadyIndex;    MS_U8 ucBISTeCbusPattern;    MS_U8 ucBISTAVLinkPattern;    MS_U8 ucBISTAVLinkRate;    MS_U8 ucBISTAVLinkMode;    MS_U8 ucBISTAVLinkRateRandomizer;    MS_U8 ucBISTImpedanceMode;    MS_U16 usBISTeCbusPatternFixed;    MS_U16 usBISTeCbusDuration;    MS_U16 usBISTeCbusErrorCount;    MS_U16 usBISTAVLinkFixed;    MS_U16 usBISTAVLinkDuration;    MS_U16 usBISTAVLinkErrorCount;} stMHL_BIST_MODE_INFO;typedef struct{    MS_BOOL bAutoEnableFlag;    MS_BOOL bECbusEnableFlag;    MS_BOOL bBISTEnableFlag;    MS_BOOL bClockStableFlag;    MS_BOOL bSignalStableFlag;    MS_U8 ucMainLinkRate;    MS_U8 ucAutoEQState;    MS_U8 ucStableCount;    MS_U8 ucECbusTrainState;    MS_U8 ucImpedanceValue;    MS_U8 ucImpedanceOffset;    MS_U8 ucIControlValue;} stMHL_SIGNAL_STATUS_INFO;//-------------------------------------------------------------------------------------------------//  Type and Structure//-------------------------------------------------------------------------------------------------enum MHL_SYSTEM_FLAG_TYPE{    MHL_SYSTEM_CABLE_PLUG_FLAG = BIT(0),    MHL_SYSTEM_CBUS_CONNECT_FLAG = BIT(1),    MHL_SYSTEM_SOURCE_CHANGE_FLAG = BIT(2),    MHL_SYSTEM_CBUS_ENHANCE_FLAG = BIT(3),    MHL_SYSTEM_CBUS_NORMAL_FLAG = BIT(4),    MHL_SYSTEM_RECEIVE_LOSE_FLAG = BIT(5),    MHL_SYSTEM_CBUS_ISR_ATTACH_FLAG = BIT(6),    MHL_SYSTEM_ECBUS_ISR_ATTACH_FLAG = BIT(7),    MHL_SYSTEM_DISPLAY_COMMAND_ENABLE_FLAG = BIT(8),    MHL_SYSTEM_FORCE_SEND_COMMAND_FLAG = BIT(9),    MHL_SYSTEM_AUTO_SWITCH_SETTING_FLAG = BIT(11),    MHL_SYSTEM_CHECK_CONTENT_ENABLE_FLAG = BIT(12),    MHL_SYSTEM_GET_BASE_SUCCESS_FLAG = BIT(13),    MHL_SYSTEM_SELF_CREATE_TASK_FLAG = BIT(14),    MHL_SYSTEM_TASK_PROCESS_FLAG = BIT(15),    MHL_SYSTEM_PREVENT_REINITIAL_FLAG = BIT(16),};enum MHL_CHIP_CAPABILITY_TYPE{    MHL_CHIP_FORCE_SEND_COMMAND_FLAG = BIT(0),    MHL_CHIP_INTERRUPT_USE_PM_IRQ_FLAG = BIT(1),    MHL_CHIP_ECBUS_ENGINE_SUPPORT_FLAG = BIT(2),    MHL_CHIP_SELF_CREATE_TASK_FLAG = BIT(3),};enum MHL_TIMER_FLAG_TYPE{    MHL_TIMER_CBUS_SILENCE_FLAG = BIT(0),    MHL_TIMER_DISPLAY_COMMAND_FLAG = BIT(1),    MHL_TIMER_WAIT_MSG_RESPONSE_FLAG = BIT(2),    MHL_TIMER_RCP_AUTO_RELEASE_FLAG = BIT(3),    MHL_TIMER_WAIT_WRITE_GRANT_FLAG = BIT(4),    MHL_TIMER_CHECK_RECEIVE_LOSE_FLAG = BIT(5),    MHL_TIMER_SEND_MSG_RESPONSE_FLAG = BIT(6),    MHL_TIMER_CHECK_CONTENT_ON_FLAG = BIT(7),    MHL_TIMER_AUTO_SWITCH_STOP_FLAG = BIT(8),    MHL_TIMER_WAIT_ECBUS_LOCK_FLAG = BIT(9),    MHL_TIMER_AUTO_EQ_PROCESS_FLAG = BIT(10),    MHL_TIMER_BIST_PROCESS_FLAG = BIT(11),    MHL_TIMER_TX_QUEUE_FREEZE_FLAG = BIT(12),    MHL_TIMER_POWER_ON_PATCH_FLAG = BIT(13),};enum MHL_CBUS_DISPLAY_FLAG_TYPE{    MHL_CBUS_HPD_SET_FLAG = BIT(0),    MHL_CBUS_PATH_EN_FLAG = BIT(1),    MHL_CBUS_VERSION_CODE_FLAG = BIT(2),    MHL_CBUS_DEVCAP_READY_FLAG = BIT(3),    MHL_CBUS_DEVCAP_CHANGE_FLAG = BIT(4),    MHL_CBUS_LINK_STATUS_NORMAL_FLAG = BIT(5),};enum MHL_PROC_DONE_FLAG_TYPE{    MHL_GET_VENDER_ID_DONE_FLAG = BIT(0),    MHL_READ_DEVCAP_DONE_FLAG = BIT(1),    MHL_READ_XDEVCAP_DONE_FLAG = BIT(2),    MHL_AUTO_SWITCH_DONE_FLAG = BIT(3),};enum MHL_ENABLE_FLAG_TYPE{    MHL_ENABLE_CBUS_SEND_FLAG = BIT(0),    MHL_ENABLE_READ_DEVCAP_FLAG = BIT(1),    MHL_ENABLE_READ_XDEVCAP_FLAG = BIT(2),    MHL_ENABLE_GET_VENDER_ID_FLAG = BIT(3),    MHL_ENABLE_RCP_FUNCTION_FLAG = BIT(4),    MHL_ENABLE_RAP_FUNCTION_FLAG = BIT(5),    MHL_ENABLE_UCP_FUNCTION_FLAG = BIT(6),    MHL_ENABLE_RBP_FUNCTION_FLAG = BIT(7),    MHL_ENABLE_ECBUS_FUNCTION_FLAG = BIT(8),    MHL_ENABLE_AUTO_SWITCH_FLAG = BIT(9),    MHL_ENABLE_CBUS_TX_QUEUE_FREEZE_FLAG = BIT(10),    MHL_ENABLE_CHECK_CONTENT_ON_FLAG = BIT(11),    MHL_ENABLE_AUTO_SWITCH_STOP_FLAG = BIT(12),    MHL_ENABLE_CALLBACK_FUNCTION_FLAG = BIT(13),    MHL_ENABLE_AUTO_EQ_FUNCTION_FLAG = BIT(14),    MHL_ENABLE_COMMUNICATE_BUSY_FLAG = BIT(15),    MHL_ENABLE_CBUS1_FUNCTION_FLAG = BIT(16),    MHL_ENABLE_EMSC_FUNCTION_FLAG = BIT(17),};enum MHL_RECEIVE_FLAG_TYPE{    MHL_CBUS_RECEIVE_MSC_FLAG = BIT(0),    MHL_CBUS_RECEIVE_ACK_FLAG = BIT(1),    MHL_CBUS_RECEIVE_ABORT_FLAG = BIT(2),    MHL_CBUS_RECEIVE_MSG_FLAG = BIT(3),    MHL_CBUS_RECEIVE_WAKE_FLAG = BIT(4),    MHL_CBUS_RECEIVE_ERROR_FLAG = BIT(5),    MHL_CBUS_RECEIVE_DEVCAP_FLAG = BIT(6),    MHL_CBUS_RECEIVE_XDEVCAP_SUPPORT_FLAG = BIT(7),    MHL_CBUS_RECEIVE_PATH_EN_FLAG = BIT(8),    MHL_CBUS_RECEIVE_MUTED_FLAG = BIT(9),    MHL_CBUS_RECEIVE_MHL3_VERSION_FLAG = BIT(10),    MHL_CBUS_RECEIVE_3D_REQ_FLAG = BIT(11),    MHL_CBUS_RECEIVE_VC_ASSIGN_FLAG = BIT(12),    MHL_CBUS_RECEIVE_FEATURE_REQUEST_FLAG = BIT(13),    MHL_CBUS_RECEIVE_FEATURE_COMPLETE_FLAG = BIT(14),    MHL_CBUS_RECEIVE_LINK_RATE_FLAG = BIT(15),    MHL_CBUS_RECEIVE_24BIT_MODE_FLAG = BIT(16),    MHL_CBUS_RECEIVE_PP_MODE_FLAG = BIT(17),    MHL_CBUS_RECEIVE_DSCR_CHANGE_FLAG = BIT(18),    MHL_CBUS_RECEIVE_WRITE_REQUEST_FLAG = BIT(19),    MHL_CBUS_RECEIVE_WRITE_GRANT_FLAG = BIT(20),    MHL_CBUS_RECEIVE_WRITE_BURST_FLAG = BIT(21),    MHL_CBUS_RECEIVE_ECBUS_MODE_FLAG = BIT(22),};enum MHL_SEND_FLAG_TYPE{    MHL_CBUS_SEND_ASK_DATA_FLAG = BIT(0),    MHL_CBUS_SEND_ASK_FINISH_FLAG = BIT(1),    MHL_CBUS_SEND_RCP_ENABLE_FLAG = BIT(2),    MHL_CBUS_SEND_RAP_ENABLE_FLAG = BIT(3),    MHL_CBUS_SEND_MSG_FINISH_FLAG = BIT(4),    MHL_CBUS_SEND_MSG_COMMAND_FLAG = BIT(5),    MHL_CBUS_SEND_RCP_RELEASE_ENABLE_FLAG = BIT(6),    MHL_CBUS_SEND_CHECK_CONTENT_ON_FLAG = BIT(7),    MHL_CBUS_SEND_READ_DEVCAP_FLAG = BIT(8),    MHL_CBUS_SEND_GET_VENDER_ID_FLAG = BIT(9),    MHL_CBUS_SEND_3D_INFORMATION_FLAG = BIT(10),    MHL_CBUS_SEND_3D_DTD_FLAG = BIT(11),    MHL_CBUS_SEND_3D_VIC_FLAG = BIT(12),    MHL_CBUS_SEND_VC_INFORMATION_FLAG = BIT(13),    MHL_CBUS_SEND_VC_CONFIRM_FLAG = BIT(14),    MHL_CBUS_SEND_HIGH_END_VIDEO_FLAG = BIT(15),    MHL_CBUS_SEND_AUDIO_DATA_TUNNEL_FLAG = BIT(16),    MHL_CBUS_SEND_EMSC_DATA_TUNNEL_FLAG = BIT(17),    MHL_CBUS_SEND_USER_WRITE_BURST_FLAG = BIT(18),    MHL_CBUS_SEND_HEV_VIC_FLAG = BIT(19),    MHL_CBUS_SEND_HEV_DTDA_FLAG = BIT(20),    MHL_CBUS_SEND_HEV_DTDB_FLAG = BIT(21),    MHL_CBUS_SEND_BIST_RETURN_STATUS_FLAG = BIT(22),    MHL_CBUS_SEND_LINK_STATUS_NORMAL_FLAG = BIT(23),};enum MHL_DEVICE_FLAG_TYPE{    MHL_DEVICE_ROKU_DONGLE_FLAG = BIT(0),    MHL_DEVICE_PHONE_HTC_FLAG = BIT(1),    MHL_DEVICE_PHONE_SONY_FLAG = BIT(2),};enum MHL_CALLBACK_FLAG_TYPE{    MHL_CALLBACK_RCP_FUNCTION_FLAG = BIT(0),    MHL_CALLBACK_RAP_FUNCTION_FLAG = BIT(1),    MHL_CALLBACK_UCP_FUNCTION_FLAG = BIT(2),    MHL_CALLBACK_ATT_FUNCTION_FLAG = BIT(3),    MHL_CALLBACK_RBP_FUNCTION_FLAG = BIT(4),};#define MHL_CBUS_DISPLAY_MASK               (MHL_CBUS_HPD_SET_FLAG |MHL_CBUS_PATH_EN_FLAG |MHL_CBUS_DEVCAP_READY_FLAG)#define MHL_ECBUS_DISPLAY_MASK              (MHL_CBUS_VERSION_CODE_FLAG| MHL_CBUS_DEVCAP_CHANGE_FLAG| MHL_CBUS_LINK_STATUS_NORMAL_FLAG)#define MHL_CBUS_DISPLAY_MASK_SHIFT         8U#define MHL_CBUS_DISPLAY_CHECK_MASK         (MHL_CBUS_DISPLAY_MASK << MHL_CBUS_DISPLAY_MASK_SHIFT)#define MHL_3D_SUPPORT_MASK                 (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT |MHL_3D_LR_SUPPORT)//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Macro define//-------------------------------------------------------------------------------------------------#define GET_MHL_SYSTEM_FLAG(a, b)           (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_SYSTEM_FLAG(a, b)           (a |= b)#define CLR_MHL_SYSTEM_FLAG(a, b)           (a &= ~b)#define GET_MHL_CHIP_FLAG(a, b)             (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_CHIP_FLAG(a, b)             (a |= b)#define CLR_MHL_CHIP_FLAG(a, b)             (a &= ~b)#define GET_MHL_TIMER_FLAG(a, b)            (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_TIMER_FLAG(a, b)            (a |= b)#define CLR_MHL_TIMER_FLAG(a, b)            (a &= ~b)#define GET_MHL_DISPLAY_FLAG(a, b)          (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_DISPLAY_FLAG(a, b)          (a |= b)#define CLR_MHL_DISPLAY_FLAG(a, b)          (a &= ~b)#define GET_MHL_RECEIVE_FLAG(a, b)          (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_RECEIVE_FLAG(a, b)          (a |= b)#define CLR_MHL_RECEIVE_FLAG(a, b)          (a &= ~b)#define GET_MHL_SEND_FLAG(a, b)             (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_SEND_FLAG(a, b)             (a |= b)#define CLR_MHL_SEND_FLAG(a, b)             (a &= ~b)#define GET_MHL_DONE_FLAG(a, b)             (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_DONE_FLAG(a, b)             (a |= b)#define CLR_MHL_DONE_FLAG(a, b)             (a &= ~b)#define GET_MHL_ENABLE_FLAG(a, b)           (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_ENABLE_FLAG(a, b)           (a |= b)#define CLR_MHL_ENABLE_FLAG(a, b)           (a &= ~b)#define GET_MHL_DEVICE_FLAG(a, b)           (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_DEVICE_FLAG(a, b)           (a |= b)#define CLR_MHL_DEVICE_FLAG(a, b)           (a &= ~b)#define GET_MHL_CALLBACK_FLAG(a, b)         (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_CALLBACK_FLAG(a, b)         (a |= b)#define CLR_MHL_CALLBACK_FLAG(a, b)         (a &= ~b)#define GET_MHL_SUPPORT_FLAG(a, b)          (MS_BOOL)((a &b) ?TRUE :FALSE)#define SET_MHL_SUPPORT_FLAG(a, b)          (a |= b)#define CLR_MHL_SUPPORT_FLAG(a, b)          (a &= ~b)#ifdef __cplusplus}#endif#endif //_MDRV_MHL_ST_H_