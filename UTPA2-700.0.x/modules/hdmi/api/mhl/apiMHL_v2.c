//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// file    apiMHL.c/// @author MStar Semiconductor Inc./// @brief  MHL driver Function///////////////////////////////////////////////////////////////////////////////////////////////////#ifndef _API_MHL_V2_C_#define _API_MHL_V2_C_//-------------------------------------------------------------------------------------------------//  Include Files//-------------------------------------------------------------------------------------------------// Common Definition#include "MsCommon.h"#include "MsVersion.h"#ifdef MSOS_TYPE_LINUX_KERNEL#include <linux/string.h>#else#include <string.h>#endif#include "MsOS.h"#include "utopia.h"#include "utopia_dapi.h"#include "mdrv_mhl_st.h"#include "apiMHL.h"#include "drvMHL.h"#include "apiMHL_private.h"//-------------------------------------------------------------------------------------------------//  Local Defines//-------------------------------------------------------------------------------------------------#if(defined(CONFIG_MLOG))#include "ULog.h"#define MAPI_MHL_MSG_INFO(format, args...)      ULOGI("MHL", format, ##args)#define MAPI_MHL_MSG_WARNING(format, args...)   ULOGW("MHL", format, ##args)#define MAPI_MHL_MSG_DEBUG(format, args...)     ULOGD("MHL", format, ##args)#define MAPI_MHL_MSG_ERROR(format, args...)     ULOGE("MHL", format, ##args)#define MAPI_MHL_MSG_FATAL(format, args...)     ULOGF("MHL", format, ##args)#else#define MAPI_MHL_MSG_INFO(format, args...)      printf(format, ##args)#define MAPI_MHL_MSG_WARNING(format, args...)   printf(format, ##args)#define MAPI_MHL_MSG_DEBUG(format, args...)     printf(format, ##args)#define MAPI_MHL_MSG_ERROR(format, args...)     printf(format, ##args)#define MAPI_MHL_MSG_FATAL(format, args...)     printf(format, ##args)#endif//-------------------------------------------------------------------------------------------------//  Local Structures//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Local Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Local Functions//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Global Functions//-------------------------------------------------------------------------------------------------#if(MHL_USE_UTOPIA_VERSION == MHL_UTOPIA_VERSION_20)//**************************************************************************//  [Function Name]://                  MHLOpen()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHLOpen(void** ppInstance, const void* const pAttribute){    MHL_INSTANT_PRIVATE *psMHLInstPri = NULL;    //UTOPIA_TRACE(MS_UTOPIA_DB_LEVEL_TRACE,printf("enter %s %d\n",__FUNCTION__,__LINE__));    // instance is allocated here, also can allocate private for internal use, ex, BDMA_INSTANT_PRIVATE    UtopiaInstanceCreate(sizeof(MHL_INSTANT_PRIVATE), ppInstance);    // setup func in private and assign the calling func in func ptr in instance private    UtopiaInstanceGetPrivate(*ppInstance, (void**)&psMHLInstPri);    psMHLInstPri->fpMHLSupportPath = (IOCTL_MHL_SUPPORT_PATH)mdrv_mhl_MHLSupportPath;    psMHLInstPri->fpMHLInitial = (IOCTL_MHL_INITIAL)mdrv_mhl_Initial;    psMHLInstPri->fpMHLHandler = (IOCTL_MHL_HANDLER)mdrv_mhl_Handler;    psMHLInstPri->fpMHLAutoSwitchHandler = (IOCTL_MHL_AUTO_SWITCH)mdrv_mhl_AutoSwitchHandler;    psMHLInstPri->fpMHLSetPowerState = (IOCTL_MHL_SET_POWER_STATE)mdrv_mhl_SetPowerState;    psMHLInstPri->fpMHLCbusControl = (IOCTL_MHL_CBUS_CONTROL)mdrv_mhl_CbusControl;    psMHLInstPri->fpMHLLoadEDID = (IOCTL_MHL_LOAD_EDID)mdrv_mhl_LoadEDID;    psMHLInstPri->fpMHLReadEDID = (IOCTL_MHL_READ_EDID)mdrv_mhl_ReadEDID;    psMHLInstPri->fpMHLLoadDeviceCapability = (IOCTL_MHL_LOAD_DEVCAP)mdrv_mhl_LoadDeviceCapability;    psMHLInstPri->fpMHLSetVenderID = (IOCTL_MHL_SET_VENDER_ID)mdrv_mhl_SetVenderID;    psMHLInstPri->fpMHLCableDetectInvert = (IOCTL_MHL_CABLE_DETECT_INVERT)mdrv_mhl_InvertCableDetect;    psMHLInstPri->fpMHLVbusConfigSetting = (IOCTL_MHL_VBUS_CONFIG)mdrv_mhl_VbusConfigSetting;    psMHLInstPri->fpMHLAdjustIControl = (IOCTL_MHL_ADJUST_I_CONTROL)mdrv_mhl_AdjustSettingIControl;    psMHLInstPri->fpMHLAdjustImpedance = (IOCTL_MHL_ADJUST_IMPEDANCE)mdrv_mhl_AdjustImpedanceSetting;    psMHLInstPri->fpMHLCableDetectFlag = (IOCTL_MHL_CABLE_DETECT_FLAG)mdrv_mhl_GetCableDetectFlag;    psMHLInstPri->fpMHLCbusConnectFlag = (IOCTL_MHL_CBUS_CONNECT_FLAG)mdrv_mhl_GetCbusConnectFlag;    psMHLInstPri->fpMHLCbusWakeupIntFlag = (IOCTL_MHL_CBUS_WAKEUP_FLAG)mdrv_mhl_CbusWakeupIntFlag;    psMHLInstPri->fpMHLSourceSupportRCP = (IOCTL_MHL_SOURCE_SUPPORT_RCP)mdrv_mhl_SrcRCPSupportFlag;    psMHLInstPri->fpMHLSourceSupportRAP = (IOCTL_MHL_SOURCE_SUPPORT_RAP)mdrv_mhl_SrcRAPSupportFlag;    psMHLInstPri->fpMHLGetStatusFlag = (IOCTL_MHL_GET_STATUS_FLAG)mdrv_mhl_CbusGetStatusFlag;    psMHLInstPri->fpMHLSendRAPCommand = (IOCTL_MHL_SEND_RAP_COMMAND)mdrv_mhl_SendRAPCommand;    psMHLInstPri->fpMHLSendRCPCommand = (IOCTL_MHL_SEND_RCP_COMMAND)mdrv_mhl_SendRCPAutoReleaseCmd;    psMHLInstPri->fpMHLSendUCPCommand = (IOCTL_MHL_SEND_UCP_COMMAND)mdrv_mhl_SendUCPCommand;    psMHLInstPri->fpMHLSendWriteBurst = (IOCTL_MHL_SEND_WRITE_BURST)mdrv_mhl_SendWriteBurst;    psMHLInstPri->fpMHLSendUserWriteBurst = (IOCTL_MHL_SEND_USER_WRITE_BURST)mdrv_mhl_CbusSendUserWriteBurst;    psMHLInstPri->fpMHLGetDeviceCapability = (IOCTL_MHL_GET_DEVCAP)mdrv_mhl_GetDeviceCapability;    psMHLInstPri->fpMHLGetExtendDeviceCapability = (IOCTL_MHL_GET_EXTEND_DEVCAP)mdrv_mhl_GetExtendDeviceCapability;    psMHLInstPri->fpMHLGetVenderID = (IOCTL_MHL_GET_VENDER_ID)mdrv_mhl_GetDeviceVenderID;    psMHLInstPri->fpMHLGetWriteBurstData = (IOCTL_MHL_GET_WRITE_BURST_DATA)mdrv_mhl_GetWriteBurstData;    psMHLInstPri->fpMHLRegisterCallBackfunction = (IOCTL_MHL_CALL_BACK_FUNCTION)mdrv_mhl_RegisterCallBackFunctions;    psMHLInstPri->fpMHLRegisterRCPCallBackfunction = (IOCTL_MHL_RCP_CALL_BACK_FUNCTION)mdrv_mhl_RegisterRcpCallBackFunction;    psMHLInstPri->fpMHLRegisterRAPCallBackfunction = (IOCTL_MHL_RAP_CALL_BACK_FUNCTION)mdrv_mhl_RegisterRapCallBackFunction;    psMHLInstPri->fpMHLRegisterUCPCallBackfunction = (IOCTL_MHL_UCP_CALL_BACK_FUNCTION)mdrv_mhl_RegisterUcpCallBackFunction;    psMHLInstPri->fpMHLRegisterATTCallBackfunction = (IOCTL_MHL_ATT_CALL_BACK_FUNCTION)mdrv_mhl_RegisterAttCallBackFunction;    psMHLInstPri->fpMHLRegisterRBPCallBackfunction = (IOCTL_MHL_RBP_CALL_BACK_FUNCTION)mdrv_mhl_RegisterRbpCallBackFunction;    psMHLInstPri->fpMHLGetConfiguration = (IOCTL_MHL_GET_CONFIGURATION)mdrv_mhl_GetConfiguration;    return UTOPIA_STATUS_SUCCESS;}//**************************************************************************//  [Function Name]://                  MHLIoctl()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHLIoctl(void* pInstance, MS_U32 u32Cmd, void* pArgs){    void* pModule = NULL;    MS_U32 ulReturnValue = UTOPIA_STATUS_SUCCESS;    MHL_INSTANT_PRIVATE* psMHLInstPri = NULL;    UtopiaInstanceGetModule(pInstance, &pModule);    UtopiaInstanceGetPrivate(pInstance, (void**)&psMHLInstPri);    switch(u32Cmd)    {        case MAPI_CMD_MHL_SUPPORT_PATH:            {                pstMHL_SET_SUPPORT_PATH pMHLArgs = (pstMHL_SET_SUPPORT_PATH)pArgs;                psMHLInstPri->fpMHLSupportPath(pInstance, pMHLArgs->ucSupportPath);            }            break;        case MAPI_CMD_MHL_INITIAL:            {                pstMHL_INITIAL_SETTING pMHLArgs = (pstMHL_INITIAL_SETTING)pArgs;                psMHLInstPri->fpMHLInitial(pInstance, pMHLArgs->ucEDIDTable, pMHLArgs->ucDevcapTable);            }            break;        case MAPI_CMD_MHL_HANDLER:            {                pstMHL_POLLING_HANDLER pMHLArgs = (pstMHL_POLLING_HANDLER)pArgs;                pMHLArgs->usMSGKeyInfo = psMHLInstPri->fpMHLHandler(pInstance);            }            break;        case MAPI_CMD_MHL_AUTO_SWITCH:            {                pstMHL_AUTO_SWITCH_HANDLER pMHLArgs = (pstMHL_AUTO_SWITCH_HANDLER)pArgs;                pMHLArgs->bAutoSwitchFlag = psMHLInstPri->fpMHLAutoSwitchHandler(pInstance, pMHLArgs->bResetFlag, pMHLArgs->ucCbusPath);            }            break;        case MAPI_CMD_MHL_SET_POWER_STATE:            {                pstMHL_SET_POWER_STATE pMHLArgs = (pstMHL_SET_POWER_STATE)pArgs;                pMHLArgs->ulFailFlag = psMHLInstPri->fpMHLSetPowerState(pInstance, pMHLArgs->usPowerState);            }            break;        case MAPI_CMD_MHL_CBUS_CONTROL:            {                pstMHL_CBUS_CONTROL pMHLArgs = (pstMHL_CBUS_CONTROL)pArgs;                psMHLInstPri->fpMHLCbusControl(pInstance, pMHLArgs->ucState);            }            break;        case MAPI_CMD_MHL_LOAD_EDID:            {                pstMHL_LOAD_EDID pMHLArgs = (pstMHL_LOAD_EDID)pArgs;                psMHLInstPri->fpMHLLoadEDID(pInstance, pMHLArgs->ucEDIDTable);            }            break;        case MAPI_CMD_MHL_READ_EDID:            {                pstMHL_READ_EDID pMHLArgs = (pstMHL_READ_EDID)pArgs;                psMHLInstPri->fpMHLReadEDID(pInstance, pMHLArgs->ucEDIDSize, pMHLArgs->ucEDIDTable);            }            break;        case MAPI_CMD_MHL_LOAD_DEVCAP:            {                pstMHL_LOAD_DEVCAP pMHLArgs = (pstMHL_LOAD_DEVCAP)pArgs;                psMHLInstPri->fpMHLLoadDeviceCapability(pInstance, pMHLArgs->ucDevcapTable);            }            break;        case MAPI_CMD_MHL_SET_VENDER_ID:            {                pstMHL_SET_VENDER_ID pMHLArgs = (pstMHL_SET_VENDER_ID)pArgs;                psMHLInstPri->fpMHLSetVenderID(pInstance, pMHLArgs->ucVenderID);            }            break;        case MAPI_CMD_MHL_SET_CABLE_DETECT_INVERT:            {                pstMHL_SET_CABLE_DETECT_INVERT pMHLArgs = (pstMHL_SET_CABLE_DETECT_INVERT)pArgs;                psMHLInstPri->fpMHLCableDetectInvert(pInstance, pMHLArgs->bCableDetectInvert);            }            break;        case MAPI_CMD_MHL_VBUS_CONFIG_SETTING:            {                pstMHL_VBUS_CONFIG_SETTING pMHLArgs = (pstMHL_VBUS_CONFIG_SETTING)pArgs;                psMHLInstPri->fpMHLVbusConfigSetting(pInstance, pMHLArgs->ucConfigMode);            }            break;        case MAPI_CMD_MHL_ADJUST_I_CONTROL:            {                pstMHL_ADJUST_I_CONTROL pMHLArgs = (pstMHL_ADJUST_I_CONTROL)pArgs;                psMHLInstPri->fpMHLAdjustIControl(pInstance, pMHLArgs->ucIControlValue);            }            break;        case MAPI_CMD_MHL_ADJUST_IMPEDANCE:            {                pstMHL_ADJUST_IMPEDANCE pMHLArgs = (pstMHL_ADJUST_IMPEDANCE)pArgs;                psMHLInstPri->fpMHLAdjustImpedance(pInstance, pMHLArgs->ucImpedanceValue);            }            break;        case MAPI_CMD_MHL_CABLE_DETECT_FLAG:            {                pstMHL_CABLE_DETECT_FLAG pMHLArgs = (pstMHL_CABLE_DETECT_FLAG)pArgs;                pMHLArgs->bCableDetectFlag = psMHLInstPri->fpMHLCableDetectFlag(pInstance);            }            break;        case MAPI_CMD_MHL_CBUS_CONNECT_FLAG:            {                pstMHL_CBUS_CONNECT_FLAG pMHLArgs = (pstMHL_CBUS_CONNECT_FLAG)pArgs;                pMHLArgs->bCbusConnectFlag = psMHLInstPri->fpMHLCbusConnectFlag(pInstance);            }            break;        case MAPI_CMD_MHL_CBUS_WAKEUP_INT_FLAG:            {                pstMHL_CBUS_WAKEUP_INT_FLAG pMHLArgs = (pstMHL_CBUS_WAKEUP_INT_FLAG)pArgs;                pMHLArgs->bCbusWakeupFlag = psMHLInstPri->fpMHLCbusWakeupIntFlag(pInstance);            }            break;        case MAPI_CMD_MHL_SOURCE_SUPPORT_RCP:            {                pstMHL_SOURCE_SUPPORT_RCP pMHLArgs = (pstMHL_SOURCE_SUPPORT_RCP)pArgs;                pMHLArgs->bSourceSupportRCP = psMHLInstPri->fpMHLSourceSupportRCP(pInstance);            }            break;        case MAPI_CMD_MHL_SOURCE_SUPPORT_RAP:            {                pstMHL_SOURCE_SUPPORT_RAP pMHLArgs = (pstMHL_SOURCE_SUPPORT_RAP)pArgs;                pMHLArgs->bSourceSupportRAP = psMHLInstPri->fpMHLSourceSupportRAP(pInstance);            }            break;        case MAPI_CMD_MHL_GET_STATUS_FLAG:            {                pstMHL_GET_STATUS_FLAG pMHLArgs = (pstMHL_GET_STATUS_FLAG)pArgs;                pMHLArgs->bStatusFlag = psMHLInstPri->fpMHLGetStatusFlag(pInstance, pMHLArgs->ucStatusType);            }            break;        case MAPI_CMD_MHL_SEND_RAP_COMMAND:            {                pstMHL_SEND_RAP_COMMAND pMHLArgs = (pstMHL_SEND_RAP_COMMAND)pArgs;                pMHLArgs->bSendFlag = psMHLInstPri->fpMHLSendRAPCommand(pInstance, pMHLArgs->ucKeyCode);            }            break;        case MAPI_CMD_MHL_SEND_RCP_COMMAND:            {                pstMHL_SEND_RCP_COMMAND pMHLArgs = (pstMHL_SEND_RCP_COMMAND)pArgs;                pMHLArgs->bSendFlag = psMHLInstPri->fpMHLSendRCPCommand(pInstance, pMHLArgs->ucKeyCode);            }            break;        case MAPI_CMD_MHL_SEND_UCP_COMMAND:            {                pstMHL_SEND_UCP_COMMAND pMHLArgs = (pstMHL_SEND_UCP_COMMAND)pArgs;                pMHLArgs->bSendFlag = psMHLInstPri->fpMHLSendUCPCommand(pInstance, pMHLArgs->ucKeyCode);            }            break;        case MAPI_CMD_MHL_SEND_WRITE_BURST:            {                pstMHL_SEND_WRITE_BURST pMHLArgs = (pstMHL_SEND_WRITE_BURST)pArgs;                pMHLArgs->bSendFlag = psMHLInstPri->fpMHLSendWriteBurst(pInstance, pMHLArgs->ucAddress, pMHLArgs->ucLength, pMHLArgs->ucData);            }            break;        case MAPI_CMD_MHL_SEND_USER_WRITE_BURST:            {                pstMHL_SEND_USER_WRITE_BURST pMHLArgs = (pstMHL_SEND_USER_WRITE_BURST)pArgs;                pMHLArgs->bSendFlag = psMHLInstPri->fpMHLSendUserWriteBurst(pInstance, pMHLArgs->ucLength, pMHLArgs->ucData);            }            break;        case MAPI_CMD_MHL_GET_DEVICE_CAPABILITY:            {                pstMHL_GET_DEVICE_CAPABILITY pMHLArgs = (pstMHL_GET_DEVICE_CAPABILITY)pArgs;                pMHLArgs->bObtainFlag = psMHLInstPri->fpMHLGetDeviceCapability(pInstance, pMHLArgs->usDevcapMask, pMHLArgs->ucDeviceCapability);            }            break;        case MAPI_CMD_MHL_GET_EXTEND_DEVICE_CAPABILITY:            {                pstMHL_GET_EXTEND_DEVICE_CAPABILITY pMHLArgs = (pstMHL_GET_EXTEND_DEVICE_CAPABILITY)pArgs;                pMHLArgs->bObtainFlag = psMHLInstPri->fpMHLGetExtendDeviceCapability(pInstance, pMHLArgs->usExtendDevcapMask, pMHLArgs->ucExtendDeviceCapability);            }            break;        case MAPI_CMD_MHL_GET_VENDER_ID:            {                pstMHL_GET_VENDER_ID pMHLArgs = (pstMHL_GET_VENDER_ID)pArgs;                pMHLArgs->bObtainFlag = psMHLInstPri->fpMHLGetVenderID(pInstance, pMHLArgs->ucVenderID);            }            break;        case MAPI_CMD_MHL_GET_WRITE_BURST_DATA:            {                pstMHL_GET_WRITE_BURST_DATA pMHLArgs = (pstMHL_GET_WRITE_BURST_DATA)pArgs;                pMHLArgs->bObtainFlag = psMHLInstPri->fpMHLGetWriteBurstData(pInstance, pMHLArgs->ucWriteBurstData);            }            break;        case MAPI_CMD_MHL_CALL_BACK_FUNCTION:            {                pstMHL_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterCallBackfunction(pInstance, pMHLArgs->bRCPfunctionFlag, pMHLArgs->bRAPfunctionFlag);            }            break;        case MAPI_CMD_MHL_RCP_CALL_BACK_FUNCTION:            {                pstMHL_RCP_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_RCP_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterRCPCallBackfunction(pInstance, pMHLArgs->bRCPfunctionFlag);            }            break;        case MAPI_CMD_MHL_RAP_CALL_BACK_FUNCTION:            {                pstMHL_RAP_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_RAP_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterRAPCallBackfunction(pInstance, pMHLArgs->bRAPfunctionFlag);            }            break;        case MAPI_CMD_MHL_UCP_CALL_BACK_FUNCTION:            {                pstMHL_UCP_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_UCP_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterUCPCallBackfunction(pInstance, pMHLArgs->bUCPfunctionFlag);            }            break;        case MAPI_CMD_MHL_ATT_CALL_BACK_FUNCTION:            {                pstMHL_ATT_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_ATT_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterATTCallBackfunction(pInstance, pMHLArgs->bATTfunctionFlag);            }            break;        case MAPI_CMD_MHL_RBP_CALL_BACK_FUNCTION:            {                pstMHL_RBP_CALL_BACK_FUNCTION pMHLArgs = (pstMHL_RBP_CALL_BACK_FUNCTION)pArgs;                psMHLInstPri->fpMHLRegisterRBPCallBackfunction(pInstance, pMHLArgs->bRBPfunctionFlag);            }            break;        case MAPI_CMD_MHL_GET_CONFIGURATION:            {                pstMHL_GET_CONFIGURATION pMHLArgs = (pstMHL_GET_CONFIGURATION)pArgs;                pMHLArgs->stInitialConfigInfo = psMHLInstPri->fpMHLGetConfiguration(pInstance);            }            break;                        default:            ulReturnValue = UTOPIA_STATUS_FAIL;            break;    };    return ulReturnValue;}//**************************************************************************//  [Function Name]://                  MHLClose()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHLClose(void* pInstance){    UtopiaInstanceDelete(pInstance);    return TRUE;}//**************************************************************************//  [Function Name]://                  MHLSTR()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHLSTR(MS_U32 ulPowerState, void* pModule){    MS_U32 ulReturnValue = UTOPIA_STATUS_FAIL;        ulReturnValue = mdrv_mhl_STREventProc(pModule, (EN_POWER_MODE)ulPowerState);        return ulReturnValue;}#ifdef CONFIG_UTOPIA_PROC_DBG_SUPPORT//**************************************************************************//  [Function Name]://                  MHLMdbIoctl()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHLMdbIoctl(MS_U32 cmd, const void* const pArgs){    void* pInstance = NULL;    MS_U32 ulReturnValue = UTOPIA_STATUS_SUCCESS;    MDBCMD_CMDLINE_PARAMETER *paraCmdLine;    MDBCMD_GETINFO_PARAMETER *paraGetInfo;    pInstance = UtopiaModuleGetLocalInstantList(MODULE_MHL, pInstance);    switch(cmd)    {        case MDBCMD_CMDLINE:            paraCmdLine = (MDBCMD_CMDLINE_PARAMETER *)pArgs;            MdbPrint(paraCmdLine->u64ReqHdl,"u32CmdSize: %d\n", paraCmdLine->u32CmdSize);            mdrv_mhl_MDCMDEchoCommand(pInstance, paraCmdLine->u64ReqHdl, paraCmdLine->pcCmdLine);            paraCmdLine->result = MDBRESULT_SUCCESS_FIN;            break;        case MDBCMD_GETINFO:            paraGetInfo = (MDBCMD_GETINFO_PARAMETER *)pArgs;            mdrv_mhl_MDCMDGetInfo(pInstance, paraGetInfo->u64ReqHdl);            paraGetInfo->result = MDBRESULT_SUCCESS_FIN;            break;        default:            paraGetInfo = (MDBCMD_GETINFO_PARAMETER *)pArgs;            MdbPrint(paraGetInfo->u64ReqHdl,"unknown cmd\n", __LINE__);            break;    };    return ulReturnValue;}#endif//**************************************************************************//  [Function Name]://                  MHLRegisterToUtopia()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************void MHLRegisterToUtopia(FUtopiaOpen ModuleType){    void* pUtopiaModule = NULL;    void* psResource = NULL;        // 1. deal with module    UtopiaModuleCreate(MODULE_MHL, 0, &pUtopiaModule);    UtopiaModuleRegister(pUtopiaModule);    // register func for module, after register here, then ap call UtopiaOpen/UtopiaIoctl/UtopiaClose can call to these registered standard func    UtopiaModuleSetupFunctionPtr(pUtopiaModule, (FUtopiaOpen)MHLOpen, (FUtopiaClose)MHLClose, (FUtopiaIOctl)MHLIoctl);#if(defined(MSOS_TYPE_LINUX_KERNEL))    UtopiaModuleSetupSTRFunctionPtr(pUtopiaModule, (FUtopiaSTR)MHLSTR);    #endif#ifdef CONFIG_UTOPIA_PROC_DBG_SUPPORT    UtopiaModuleRegisterMdbNode("MHL", (FUtopiaMdbIoctl)MHLMdbIoctl);#endif    // 2. deal with resource    // start func to add res, call once will create 2 access in resource. Also can declare BDMA_POOL_ID_BDMA1 for another channel depend on driver owner.    UtopiaModuleAddResourceStart(pUtopiaModule, MHL_POOL);    // resource can alloc private for internal use, ex, BDMA_RESOURCE_PRIVATE    UtopiaResourceCreate("MHL", sizeof(MHL_RESOURCE_PRIVATE), &psResource);    // func to reg res    UtopiaResourceRegister(pUtopiaModule, psResource, MHL_POOL);    UtopiaModuleAddResourceEnd(pUtopiaModule, MHL_POOL);}#endif#endif // _API_MHL_V2_C_