//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// file    adpMHL.c/// @author MStar Semiconductor Inc./// @brief  MHL driver Function///////////////////////////////////////////////////////////////////////////////////////////////////#ifndef _ADP_MHL_C_#define _ADP_MHL_C_//-------------------------------------------------------------------------------------------------//  Include Files//-------------------------------------------------------------------------------------------------// Common Definition#include "MsCommon.h"#include "MsVersion.h"#include "MsDevice.h"#include <linux/kernel.h>#include <linux/sched.h>#ifdef MSOS_TYPE_LINUX_KERNEL#include <linux/string.h>#else#include <string.h>#endif#include <linux/slab.h>#include <asm/uaccess.h>#include <linux/compat.h>#include "utopia.h"#include "utopia_dapi.h"#include "utopia_adp.h"#include "apiMHL.h"#include "apiMHL_private.h"#include "adpMHL.h"//-------------------------------------------------------------------------------------------------//  Local Defines//-------------------------------------------------------------------------------------------------#if(defined(CONFIG_MLOG))#include "ULog.h"#define MADP_MHL_MSG_INFO(format, args...)      ULOGI("MHL", format, ##args)#define MADP_MHL_MSG_WARNING(format, args...)   ULOGW("MHL", format, ##args)#define MADP_MHL_MSG_DEBUG(format, args...)     ULOGD("MHL", format, ##args)#define MADP_MHL_MSG_ERROR(format, args...)     ULOGE("MHL", format, ##args)#define MADP_MHL_MSG_FATAL(format, args...)     ULOGF("MHL", format, ##args)#else#define MADP_MHL_MSG_INFO(format, args...)      printf(format, ##args)#define MADP_MHL_MSG_WARNING(format, args...)   printf(format, ##args)#define MADP_MHL_MSG_DEBUG(format, args...)     printf(format, ##args)#define MADP_MHL_MSG_ERROR(format, args...)     printf(format, ##args)#define MADP_MHL_MSG_FATAL(format, args...)     printf(format, ##args)#endif#ifdef MSOS_TYPE_LINUX_KERNEL#define CPY_FROM_USER(a,b,c)                    if(copy_from_user(a,b,c) != 0) { break; }#define CPY_TO_USER(a,b,c)                      if(copy_to_user(a,b,c) != 0) { break; }#else#define CPY_FROM_USER                           memcpy#define CPY_TO_USER                             memcpy#endif  //MSOS_TYPE_LINUX_KERNEL#if (defined(MSOS_TYPE_LINUX_KERNEL) && defined(CONFIG_COMPAT))#define COMPAT_PTR(a)                           compat_ptr(a)#define COMPAT_NEXT_PTR(a)                      (*((MS_U32*)compat_ptr((unsigned long)a)))#define IS_CMP_TASK()                           is_compat_task()#define CMP_CPY_FROM_USER(a,b,c)                if(copy_from_user(a, compat_ptr((unsigned long)b), c) != 0)  {  break; }#define CMP_CPY_TO_USER(a,b,c)                  if(copy_to_user(compat_ptr((unsigned long)a), b, c) != 0) { break;  }#define MS_COMPAT_MHL                           compat_uptr_t#else #define COMPAT_PTR(a)                           (a)#define COMPAT_NEXT_PTR(a)                      (*((MS_U32*)a))#define IS_CMP_TASK()                           (FALSE)#define CMP_CPY_FROM_USER                       CPY_FROM_USER#define CMP_CPY_TO_USER                         CPY_TO_USER#define MS_COMPAT_MHL                           MS_U8*#endif //CONFIG_COMPAT//-------------------------------------------------------------------------------------------------//  Local Structures//-------------------------------------------------------------------------------------------------typedef struct DLL_PACKED{    MS_U8 ucEDIDSize;    MS_COMPAT_MHL ucEDIDTable;} stMHL_READ_EDID_COMPAT, *pstMHL_READ_EDID_COMPAT;typedef struct DLL_PACKED{    MS_BOOL bSendFlag;    MS_U8 ucAddress;    MS_U8 ucLength;    MS_COMPAT_MHL ucData;} stMHL_SEND_WRITE_BURST_COMPAT, *pstMHL_SEND_WRITE_BURST_COMPAT;typedef struct DLL_PACKED{    MS_BOOL bSendFlag;    MS_U8 ucLength;    MS_COMPAT_MHL ucData;} stMHL_SEND_USER_WRITE_BURST_COMPAT, *pstMHL_SEND_USER_WRITE_BURST_COMPAT;//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Local Variables//-------------------------------------------------------------------------------------------------UADP_SPT_NAMEnNXT_DEF(MHL_MS_U8, 0);// MAPI_CMD_MHL_SUPPORT_PATH -- stMHL_SET_SUPPORT_PATHUADP_SPT_NAMEnNXT_DEF(MHL_SET_SUPPORT_PATH, 0);// MAPI_CMD_MHL_INITIAL -- stMHL_INITIAL_SETTINGUADP_SPT_NAMEnNXT_DEF(MHL_LOAD_EDID_TABLE, 0);UADP_SPT_NAMEnNXT_DEF(MHL_LOAD_DEVCAP_TABLE, 0);UADP_SPT_NAMEnNXT_DEF(MHL_INITIAL_SETTING, 2);// MAPI_CMD_MHL_HANDLER -- stMHL_POLLING_HANDLERUADP_SPT_NAMEnNXT_DEF(MHL_POLLING_HANDLER, 0);// MAPI_CMD_MHL_AUTO_SWITCH -- stMHL_AUTO_SWITCH_HANDLERUADP_SPT_NAMEnNXT_DEF(MHL_AUTO_SWITCH_HANDLER, 1);// MAPI_CMD_MHL_SET_POWER_STATE -- stMHL_SET_POWER_STATEUADP_SPT_NAMEnNXT_DEF(MHL_SET_POWER_STATE, 0);// MAPI_CMD_MHL_CBUS_CONTROL -- stMHL_CBUS_CONTROLUADP_SPT_NAMEnNXT_DEF(MHL_CBUS_CONTROL, 0);// MAPI_CMD_MHL_LOAD_EDID -- stMHL_LOAD_EDIDUADP_SPT_NAMEnNXT_DEF(MHL_LOAD_EDID, 1);// MAPI_CMD_MHL_LOAD_DEVCAP -- stMHL_LOAD_DEVCAPUADP_SPT_NAMEnNXT_DEF(MHL_LOAD_DEVCAP, 1);// MAPI_CMD_MHL_SET_VENDER_ID -- stMHL_SET_VENDER_IDUADP_SPT_NAMEnNXT_DEF(MHL_SET_VENDER_ID, 0);// MAPI_CMD_MHL_SET_CABLE_DETECT_INVERT -- stMHL_SET_CABLE_DETECT_INVERTUADP_SPT_NAMEnNXT_DEF(MHL_SET_CABLE_DETECT_INVERT, 0);// MAPI_CMD_MHL_VBUS_CONFIG_SETTING -- stMHL_VBUS_CONFIG_SETTINGUADP_SPT_NAMEnNXT_DEF(MHL_VBUS_CONFIG_SETTING, 0);// MAPI_CMD_MHL_ADJUST_I_CONTROL -- stMHL_ADJUST_I_CONTROLUADP_SPT_NAMEnNXT_DEF(MHL_ADJUST_I_CONTROL, 0);// MAPI_CMD_MHL_ADJUST_IMPEDANCE -- stMHL_ADJUST_IMPEDANCEUADP_SPT_NAMEnNXT_DEF(MHL_ADJUST_IMPEDANCE, 0);// MAPI_CMD_MHL_CABLE_DETECT_FLAG -- stMHL_CABLE_DETECT_FLAGUADP_SPT_NAMEnNXT_DEF(MHL_CABLE_DETECT_FLAG, 0);// MAPI_CMD_MHL_CBUS_CONNECT_FLAG -- stMHL_CBUS_CONNECT_FLAGUADP_SPT_NAMEnNXT_DEF(MHL_CBUS_CONNECT_FLAG, 0);// MAPI_CMD_MHL_CBUS_WAKEUP_INT_FLAG -- stMHL_CBUS_WAKEUP_INT_FLAGUADP_SPT_NAMEnNXT_DEF(MHL_CBUS_WAKEUP_INT_FLAG, 0);// MAPI_CMD_MHL_SOURCE_SUPPORT_RCP -- stMHL_SOURCE_SUPPORT_RCPUADP_SPT_NAMEnNXT_DEF(MHL_SOURCE_SUPPORT_RCP, 0);// MAPI_CMD_MHL_SOURCE_SUPPORT_RAP -- stMHL_SOURCE_SUPPORT_RAPUADP_SPT_NAMEnNXT_DEF(MHL_SOURCE_SUPPORT_RAP, 0);// MAPI_CMD_MHL_GET_STATUS_FLAG -- stMHL_GET_STATUS_FLAGUADP_SPT_NAMEnNXT_DEF(MHL_GET_STATUS_FLAG, 0);// MAPI_CMD_MHL_SEND_RAP_COMMAND -- stMHL_SEND_RAP_COMMANDUADP_SPT_NAMEnNXT_DEF(MHL_SEND_RAP_COMMAND, 0);// MAPI_CMD_MHL_SEND_RCP_COMMAND -- stMHL_SEND_RCP_COMMANDUADP_SPT_NAMEnNXT_DEF(MHL_SEND_RCP_COMMAND, 0);// MAPI_CMD_MHL_SEND_UCP_COMMAND -- stMHL_SEND_UCP_COMMANDUADP_SPT_NAMEnNXT_DEF(MHL_SEND_UCP_COMMAND, 0);// MAPI_CMD_MHL_GET_DEVICE_CAPABILITY -- stMHL_GET_DEVICE_CAPABILITYUADP_SPT_NAMEnNXT_DEF(MHL_GET_DEVCAP_TABLE, 0);UADP_SPT_NAMEnNXT_DEF(MHL_GET_DEVICE_CAPABILITY, 1);// MAPI_CMD_MHL_GET_EXTEND_DEVICE_CAPABILITY -- stMHL_GET_EXTEND_DEVICE_CAPABILITYUADP_SPT_NAMEnNXT_DEF(MHL_GET_XDEVCAP_TABLE, 0);UADP_SPT_NAMEnNXT_DEF(MHL_GET_EXTEND_DEVICE_CAPABILITY, 1);// MAPI_CMD_MHL_GET_VENDER_ID -- stMHL_GET_VENDER_IDUADP_SPT_NAMEnNXT_DEF(MHL_GET_VENDER_ID, 1);// MAPI_CMD_MHL_GET_WRITE_BURST_DATA -- stMHL_GET_WRITE_BURST_DATAUADP_SPT_NAMEnNXT_DEF(MHL_WRITE_BURST_TABLE, 0);UADP_SPT_NAMEnNXT_DEF(MHL_GET_WRITE_BURST_DATA, 1);// MAPI_CMD_MHL_CALL_BACK_FUNCTION -- stMHL_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_RCP_CALL_BACK_FUNCTION -- stMHL_RCP_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_RCP_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_RAP_CALL_BACK_FUNCTION -- stMHL_RAP_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_RAP_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_UCP_CALL_BACK_FUNCTION -- stMHL_UCP_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_UCP_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_ATT_CALL_BACK_FUNCTION -- stMHL_ATT_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_ATT_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_RBP_CALL_BACK_FUNCTION -- stMHL_RBP_CALL_BACK_FUNCTIONUADP_SPT_NAMEnNXT_DEF(MHL_RBP_CALL_BACK_FUNCTION, 0);// MAPI_CMD_MHL_GET_CONFIGURATION -- stMHL_GET_CONFIGURATIONUADP_SPT_NAMEnNXT_DEF(MHL_GET_CONFIGURATION, 0);//-------------------------------------------------------------------------------------------------//  Local Functions//-------------------------------------------------------------------------------------------------//-------------------------------------------------------------------------------------------------//  Global Functions//-------------------------------------------------------------------------------------------------//**************************************************************************//  [Function Name]://                  MHL_adp_Init()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHL_adp_Init(FUtopiaIOctl* pIoctl){    MS_U32 ulDataSize = 0;        UADP_SPT_NAME0NXT(MHL_MS_U8, MS_U8);    // MAPI_CMD_MHL_SUPPORT_PATH    UADP_SPT_NAME0NXT(MHL_SET_SUPPORT_PATH, stMHL_SET_SUPPORT_PATH);    // MAPI_CMD_MHL_INITIAL    ulDataSize = sizeof(MS_U8) *MHL_EDID_TABLE_SIZE;    UADP_SPT_BGN(&spt_MHL_LOAD_EDID_TABLE[0], ulDataSize);    UADP_SPT_FIN(&spt_MHL_LOAD_EDID_TABLE[1]);    ulDataSize = sizeof(MS_U8) *(MHL_DEVICE_CAPABILITY_SIZE +MHL_XDEVICE_CAPABILITY_SIZE);    UADP_SPT_BGN(&spt_MHL_LOAD_DEVCAP_TABLE[0], ulDataSize);    UADP_SPT_FIN(&spt_MHL_LOAD_DEVCAP_TABLE[1]);    UADP_SPT_NAME2NXT(MHL_INITIAL_SETTING, stMHL_INITIAL_SETTING, ucEDIDTable, MHL_LOAD_EDID_TABLE, ucDevcapTable, MHL_LOAD_DEVCAP_TABLE);    // MAPI_CMD_MHL_HANDLER    UADP_SPT_NAME0NXT(MHL_POLLING_HANDLER, stMHL_POLLING_HANDLER);    // MAPI_CMD_MHL_AUTO_SWITCH    UADP_SPT_NAME1NXT(MHL_AUTO_SWITCH_HANDLER, stMHL_AUTO_SWITCH_HANDLER, ucCbusPath, MHL_MS_U8);    // MAPI_CMD_MHL_SET_POWER_STATE    UADP_SPT_NAME0NXT(MHL_SET_POWER_STATE, stMHL_SET_POWER_STATE);    // MAPI_CMD_MHL_CBUS_CONTROL    UADP_SPT_NAME0NXT(MHL_CBUS_CONTROL, stMHL_CBUS_CONTROL);    // MAPI_CMD_MHL_LOAD_EDID    UADP_SPT_NAME1NXT(MHL_LOAD_EDID, stMHL_LOAD_EDID, ucEDIDTable, MHL_LOAD_EDID_TABLE);    // MAPI_CMD_MHL_LOAD_DEVCAP    UADP_SPT_NAME1NXT(MHL_LOAD_DEVCAP, stMHL_LOAD_DEVCAP, ucDevcapTable, MHL_LOAD_DEVCAP_TABLE);    // MAPI_CMD_MHL_SET_VENDER_ID    UADP_SPT_NAME0NXT(MHL_SET_VENDER_ID, stMHL_SET_VENDER_ID);    // MAPI_CMD_MHL_SET_CABLE_DETECT_INVERT    UADP_SPT_NAME0NXT(MHL_SET_CABLE_DETECT_INVERT, stMHL_SET_CABLE_DETECT_INVERT);    // MAPI_CMD_MHL_VBUS_CONFIG_SETTING    UADP_SPT_NAME0NXT(MHL_VBUS_CONFIG_SETTING, stMHL_VBUS_CONFIG_SETTING);    // MAPI_CMD_MHL_ADJUST_I_CONTROL    UADP_SPT_NAME0NXT(MHL_ADJUST_I_CONTROL, stMHL_ADJUST_I_CONTROL);    // MAPI_CMD_MHL_ADJUST_IMPEDANCE    UADP_SPT_NAME0NXT(MHL_ADJUST_IMPEDANCE, stMHL_ADJUST_IMPEDANCE);    // MAPI_CMD_MHL_CABLE_DETECT_FLAG    UADP_SPT_NAME0NXT(MHL_CABLE_DETECT_FLAG, stMHL_CABLE_DETECT_FLAG);    // MAPI_CMD_MHL_CBUS_CONNECT_FLAG    UADP_SPT_NAME0NXT(MHL_CBUS_CONNECT_FLAG, stMHL_CBUS_CONNECT_FLAG);    // MAPI_CMD_MHL_CBUS_WAKEUP_INT_FLAG    UADP_SPT_NAME0NXT(MHL_CBUS_WAKEUP_INT_FLAG, stMHL_CBUS_WAKEUP_INT_FLAG);    // MAPI_CMD_MHL_SOURCE_SUPPORT_RCP    UADP_SPT_NAME0NXT(MHL_SOURCE_SUPPORT_RCP, stMHL_SOURCE_SUPPORT_RCP);    // MAPI_CMD_MHL_SOURCE_SUPPORT_RAP    UADP_SPT_NAME0NXT(MHL_SOURCE_SUPPORT_RAP, stMHL_SOURCE_SUPPORT_RAP);    // MAPI_CMD_MHL_GET_STATUS_FLAG    UADP_SPT_NAME0NXT(MHL_GET_STATUS_FLAG, stMHL_GET_STATUS_FLAG);    // MAPI_CMD_MHL_SEND_RAP_COMMAND    UADP_SPT_NAME0NXT(MHL_SEND_RAP_COMMAND, stMHL_SEND_RAP_COMMAND);    // MAPI_CMD_MHL_SEND_RCP_COMMAND    UADP_SPT_NAME0NXT(MHL_SEND_RCP_COMMAND, stMHL_SEND_RCP_COMMAND);    // MAPI_CMD_MHL_SEND_UCP_COMMAND    UADP_SPT_NAME0NXT(MHL_SEND_UCP_COMMAND, stMHL_SEND_UCP_COMMAND);    // MAPI_CMD_MHL_GET_DEVICE_CAPABILITY    ulDataSize = sizeof(MS_U8) *MHL_DEVICE_CAPABILITY_SIZE;    UADP_SPT_BGN(&spt_MHL_GET_DEVCAP_TABLE[0], ulDataSize);    UADP_SPT_FIN(&spt_MHL_GET_DEVCAP_TABLE[1]);    UADP_SPT_NAME1NXT(MHL_GET_DEVICE_CAPABILITY, stMHL_GET_DEVICE_CAPABILITY, ucDeviceCapability, MHL_GET_DEVCAP_TABLE);    // MAPI_CMD_MHL_GET_EXTEND_DEVICE_CAPABILITY    ulDataSize = sizeof(MS_U8) *MHL_XDEVICE_CAPABILITY_SIZE;    UADP_SPT_BGN(&spt_MHL_GET_XDEVCAP_TABLE[0], ulDataSize);    UADP_SPT_FIN(&spt_MHL_GET_XDEVCAP_TABLE[1]);    UADP_SPT_NAME1NXT(MHL_GET_EXTEND_DEVICE_CAPABILITY, stMHL_GET_EXTEND_DEVICE_CAPABILITY, ucExtendDeviceCapability, MHL_GET_XDEVCAP_TABLE);    // MAPI_CMD_MHL_GET_VENDER_ID    UADP_SPT_NAME1NXT(MHL_GET_VENDER_ID, stMHL_GET_VENDER_ID, ucVenderID, MHL_MS_U8);    // MAPI_CMD_MHL_GET_WRITE_BURST_DATA    ulDataSize = sizeof(MS_U8) *MHL_MSC_SCRATCHPAD_SIZE;    UADP_SPT_BGN(&spt_MHL_WRITE_BURST_TABLE[0], ulDataSize);    UADP_SPT_FIN(&spt_MHL_WRITE_BURST_TABLE[1]);    UADP_SPT_NAME1NXT(MHL_GET_WRITE_BURST_DATA, stMHL_GET_WRITE_BURST_DATA, ucWriteBurstData, MHL_WRITE_BURST_TABLE);    // MAPI_CMD_MHL_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_CALL_BACK_FUNCTION, stMHL_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_RCP_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_RCP_CALL_BACK_FUNCTION, stMHL_RCP_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_RAP_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_RAP_CALL_BACK_FUNCTION, stMHL_RAP_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_UCP_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_UCP_CALL_BACK_FUNCTION, stMHL_UCP_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_ATT_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_ATT_CALL_BACK_FUNCTION, stMHL_ATT_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_RBP_CALL_BACK_FUNCTION    UADP_SPT_NAME0NXT(MHL_RBP_CALL_BACK_FUNCTION, stMHL_RBP_CALL_BACK_FUNCTION);    // MAPI_CMD_MHL_GET_CONFIGURATION    UADP_SPT_NAME0NXT(MHL_GET_CONFIGURATION, stMHL_GET_CONFIGURATION);    *pIoctl= (FUtopiaIOctl)MHL_adp_Ioctl;        return 0;}//**************************************************************************//  [Function Name]://                  MHL_adp_Ioctl()//  [Description]//                  //  [Arguments]:////  [Return]:////**************************************************************************MS_U32 MHL_adp_Ioctl(void* pInstanceTmp, MS_U32 u32Cmd, void* const pArgs){    char usbuffer_arg[2];    MS_U32 ulReturnValue = UTOPIA_STATUS_SUCCESS;    MS_U32 ulDataSize = 0;        switch(u32Cmd)    {        case MAPI_CMD_MHL_SUPPORT_PATH:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SET_SUPPORT_PATH, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_INITIAL:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_INITIAL_SETTING, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_HANDLER:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_POLLING_HANDLER, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_AUTO_SWITCH:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_AUTO_SWITCH_HANDLER, spt_MHL_AUTO_SWITCH_HANDLER, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SET_POWER_STATE:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SET_POWER_STATE, spt_MHL_SET_POWER_STATE, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_CBUS_CONTROL:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_CBUS_CONTROL, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_LOAD_EDID:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_LOAD_EDID, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_READ_EDID:            {                stMHL_READ_EDID stMHLArgs = {0};                                if(IS_CMP_TASK())                {                    stMHL_READ_EDID_COMPAT stCompatMHLArgs = {0};                    CMP_CPY_FROM_USER(&stCompatMHLArgs, pArgs, sizeof(stMHL_READ_EDID_COMPAT));                    ulDataSize = sizeof(MS_U8) *stCompatMHLArgs.ucEDIDSize;                                        stMHLArgs.ucEDIDTable = malloc(ulDataSize);                    stMHLArgs.ucEDIDSize = stCompatMHLArgs.ucEDIDSize;                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                                        CMP_CPY_TO_USER(stCompatMHLArgs.ucEDIDTable, stMHLArgs.ucEDIDTable, ulDataSize);                    CMP_CPY_TO_USER(pArgs, &stCompatMHLArgs, sizeof(stMHL_READ_EDID_COMPAT));                    free(stMHLArgs.ucEDIDTable);                }                else                {                    CPY_FROM_USER(&stMHLArgs, pArgs, sizeof(stMHL_READ_EDID));                    ulDataSize = sizeof(MS_U8) *stMHLArgs.ucEDIDSize;                                        stMHLArgs.ucEDIDTable = malloc(ulDataSize);                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                    CPY_TO_USER(pArgs, &stMHLArgs, sizeof(stMHL_READ_EDID));                    free(stMHLArgs.ucEDIDTable);                }            }            break;        case MAPI_CMD_MHL_LOAD_DEVCAP:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_LOAD_DEVCAP, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SET_VENDER_ID:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SET_VENDER_ID, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SET_CABLE_DETECT_INVERT:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SET_CABLE_DETECT_INVERT, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_VBUS_CONFIG_SETTING:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_VBUS_CONFIG_SETTING, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_ADJUST_I_CONTROL:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_ADJUST_I_CONTROL, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_ADJUST_IMPEDANCE:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_ADJUST_IMPEDANCE, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_CABLE_DETECT_FLAG:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_CABLE_DETECT_FLAG, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_CBUS_CONNECT_FLAG:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_CBUS_CONNECT_FLAG, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_CBUS_WAKEUP_INT_FLAG:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_CBUS_WAKEUP_INT_FLAG, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SOURCE_SUPPORT_RCP:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_SOURCE_SUPPORT_RCP, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SOURCE_SUPPORT_RAP:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_SOURCE_SUPPORT_RAP, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_GET_STATUS_FLAG:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_GET_STATUS_FLAG, spt_MHL_GET_STATUS_FLAG, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SEND_RAP_COMMAND:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SEND_RAP_COMMAND, spt_MHL_SEND_RAP_COMMAND, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SEND_RCP_COMMAND:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SEND_RCP_COMMAND, spt_MHL_SEND_RCP_COMMAND, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SEND_UCP_COMMAND:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_SEND_UCP_COMMAND, spt_MHL_SEND_UCP_COMMAND, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_SEND_WRITE_BURST:            {                stMHL_SEND_WRITE_BURST stMHLArgs = {0};                                if(IS_CMP_TASK())                {                    stMHL_SEND_WRITE_BURST_COMPAT stCompatMHLArgs = {0};                    CMP_CPY_FROM_USER(&stCompatMHLArgs, pArgs, sizeof(stMHL_SEND_WRITE_BURST_COMPAT));                    ulDataSize = sizeof(MS_U8) *stCompatMHLArgs.ucLength;                                        stMHLArgs.ucData = malloc(ulDataSize);                    CMP_CPY_FROM_USER(stMHLArgs.ucData, stCompatMHLArgs.ucData, ulDataSize);                    stMHLArgs.ucAddress = stCompatMHLArgs.ucAddress;                    stMHLArgs.ucLength = stCompatMHLArgs.ucLength;                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                    stCompatMHLArgs.bSendFlag = stMHLArgs.bSendFlag;                                        CMP_CPY_TO_USER(pArgs, &stCompatMHLArgs, sizeof(stMHL_SEND_WRITE_BURST_COMPAT));                    free(stMHLArgs.ucData);                }                else                {                    void *pData = NULL;                                        CPY_FROM_USER(&stMHLArgs, pArgs, sizeof(stMHL_SEND_WRITE_BURST));                    ulDataSize = sizeof(MS_U8) *stMHLArgs.ucLength;                                        pData = stMHLArgs.ucData;                    stMHLArgs.ucData = malloc(ulDataSize);                    CPY_FROM_USER(stMHLArgs.ucData, pData, ulDataSize);                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                    CPY_TO_USER(pArgs, &stMHLArgs, sizeof(stMHL_SEND_WRITE_BURST));                    free(stMHLArgs.ucData);                }            }            break;        case MAPI_CMD_MHL_SEND_USER_WRITE_BURST:            {                stMHL_SEND_USER_WRITE_BURST stMHLArgs = {0};                                if(IS_CMP_TASK())                {                    stMHL_SEND_USER_WRITE_BURST_COMPAT stCompatMHLArgs = {0};                    CMP_CPY_FROM_USER(&stCompatMHLArgs, pArgs, sizeof(stMHL_SEND_USER_WRITE_BURST_COMPAT));                                        ulDataSize = sizeof(MS_U8) *stCompatMHLArgs.ucLength;                                        stMHLArgs.ucData = malloc(ulDataSize);                    CMP_CPY_FROM_USER(stMHLArgs.ucData, stCompatMHLArgs.ucData, ulDataSize);                    stMHLArgs.ucLength = stCompatMHLArgs.ucLength;                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                    stCompatMHLArgs.bSendFlag = stMHLArgs.bSendFlag;                                        CMP_CPY_TO_USER(pArgs, &stCompatMHLArgs, sizeof(stMHL_SEND_USER_WRITE_BURST_COMPAT));                    free(stMHLArgs.ucData);                }                else                {                    void *pData = NULL;                                        CPY_FROM_USER(&stMHLArgs, pArgs, sizeof(stMHL_SEND_USER_WRITE_BURST));                                        ulDataSize = sizeof(MS_U8) *stMHLArgs.ucLength;                                        pData = stMHLArgs.ucData;                    stMHLArgs.ucData = malloc(ulDataSize);                    CPY_FROM_USER(stMHLArgs.ucData, pData, ulDataSize);                    ulReturnValue = UtopiaIoctl(pInstanceTmp, u32Cmd, &stMHLArgs);                    CPY_TO_USER(pArgs, &stMHLArgs, sizeof(stMHL_SEND_USER_WRITE_BURST));                    free(stMHLArgs.ucData);                }            }            break;        case MAPI_CMD_MHL_GET_DEVICE_CAPABILITY:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_GET_DEVICE_CAPABILITY, spt_MHL_GET_DEVICE_CAPABILITY, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_GET_EXTEND_DEVICE_CAPABILITY:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_GET_EXTEND_DEVICE_CAPABILITY, spt_MHL_GET_EXTEND_DEVICE_CAPABILITY, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_GET_VENDER_ID:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_GET_VENDER_ID, spt_MHL_GET_VENDER_ID, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_GET_WRITE_BURST_DATA:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_GET_WRITE_BURST_DATA, spt_MHL_GET_WRITE_BURST_DATA, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_RCP_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_RCP_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_RAP_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_RAP_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_UCP_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_UCP_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_ATT_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_ATT_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_RBP_CALL_BACK_FUNCTION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, spt_MHL_RBP_CALL_BACK_FUNCTION, NULL, usbuffer_arg, sizeof(usbuffer_arg));            break;        case MAPI_CMD_MHL_GET_CONFIGURATION:            ulReturnValue = UADPBypassIoctl(pInstanceTmp, u32Cmd, pArgs, NULL, spt_MHL_GET_CONFIGURATION, usbuffer_arg, sizeof(usbuffer_arg));            break;                        default:                        break;    };        return ulReturnValue;}#endif // _ADP_MHL_C_