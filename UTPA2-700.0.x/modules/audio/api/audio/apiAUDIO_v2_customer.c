//<MStar Software>
//******************************************************************************
// MStar Software
// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.
// All software, firmware and related documentation herein ("MStar Software") are
// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by
// law, including, but not limited to, copyright law and international treaties.
// Any use, modification, reproduction, retransmission, or republication of all
// or part of MStar Software is expressly prohibited, unless prior written
// permission has been granted by MStar.
//
// By accessing, browsing and/or using MStar Software, you acknowledge that you
// have read, understood, and agree, to be bound by below terms ("Terms") and to
// comply with all applicable laws and regulations:
//
// 1. MStar shall retain any and all right, ownership and interest to MStar
//    Software and any modification/derivatives thereof.
//    No right, ownership, or interest to MStar Software and any
//    modification/derivatives thereof is transferred to you under Terms.
//
// 2. You understand that MStar Software might include, incorporate or be
//    supplied together with third party`s software and the use of MStar
//    Software may require additional licenses from third parties.
//    Therefore, you hereby agree it is your sole responsibility to separately
//    obtain any and all third party right and license necessary for your use of
//    such third party`s software.
//
// 3. MStar Software and any modification/derivatives thereof shall be deemed as
//    MStar`s confidential information and you agree to keep MStar`s
//    confidential information in strictest confidence and not disclose to any
//    third party.
//
// 4. MStar Software is provided on an "AS IS" basis without warranties of any
//    kind. Any warranties are hereby expressly disclaimed by MStar, including
//    without limitation, any warranties of merchantability, non-infringement of
//    intellectual property rights, fitness for a particular purpose, error free
//    and in conformity with any international standard.  You agree to waive any
//    claim against MStar for any loss, damage, cost or expense that you may
//    incur related to your use of MStar Software.
//    In no event shall MStar be liable for any direct, indirect, incidental or
//    consequential damages, including without limitation, lost of profit or
//    revenues, lost or damage of data, and unauthorized system use.
//    You agree that this Section 4 shall still apply without being affected
//    even if MStar Software has been modified by MStar in accordance with your
//    request or instruction for your use, except otherwise agreed by both
//    parties in writing.
//
// 5. If requested, MStar may from time to time provide technical supports or
//    services in relation with MStar Software to you for your use of
//    MStar Software in conjunction with your or your customer`s product
//    ("Services").
//    You understand and agree that, except otherwise agreed by both parties in
//    writing, Services are provided on an "AS IS" basis and the warranty
//    disclaimer set forth in Section 4 above shall apply.
//
// 6. Nothing contained herein shall be construed as by implication, estoppels
//    or otherwise:
//    (a) conferring any license or right to use MStar name, trademark, service
//        mark, symbol or any other identification;
//    (b) obligating MStar or any of its affiliates to furnish any person,
//        including without limitation, you and your customers, any assistance
//        of any kind whatsoever, or any information; or
//    (c) conferring any license or right under any intellectual property right.
//
// 7. These terms shall be governed by and construed in accordance with the laws
//    of Taiwan, R.O.C., excluding its conflict of law rules.
//    Any and all dispute arising out hereof or related hereto shall be finally
//    settled by arbitration referred to the Chinese Arbitration Association,
//    Taipei in accordance with the ROC Arbitration Law and the Arbitration
//    Rules of the Association by three (3) arbitrators appointed in accordance
//    with the said Rules.
//    The place of arbitration shall be in Taipei, Taiwan and the language shall
//    be English.
//    The arbitration award shall be final and binding to both parties.
//
//******************************************************************************
//<MStar Software>
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2008-2009 MStar Semiconductor, Inc.
// All rights reserved.
//
// Unless otherwise stipulated in writing, any and all information contained
// herein regardless in any format shall remain the sole proprietary of
// MStar Semiconductor Inc. and be kept in strict confidence
// ("MStar Confidential Information") by the recipient.
// Any unauthorized act including without limitation unauthorized disclosure,
// copying, use, reproduction, sale, distribution, modification, disassembling,
// reverse engineering and compiling of the contents of MStar Confidential
// Information is unlawful and strictly prohibited. MStar hereby reserves the
// rights to any and all damages, losses, costs and expenses resulting therefrom.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// file    apiAUDIO_v2_customer.c
/// @brief  Audio 1.0 API wrapper for Audio 2.0
/// @author MStar Semiconductor,Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef ROLLS_ROYCE

//-------------------------------------------------------------------------------------------------------------------------------------
// [Distinction Area] [kernel space / user space] [#include standard header] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
#include <linux/string.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/kthread.h>
#include <linux/module.h>  // Needed by all modules
#include <linux/kernel.h>  // Needed for KERN_INFO
#include <linux/fs.h>      // Needed by filp
#include <asm/uaccess.h>   // Needed by segment descriptors
#include <linux/proc_fs.h>
#include <linux/io.h>

#else //User Space
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <pthread.h>
#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Share Area] shared [#include local header] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#include "apiAUDIO_v2_customer.h"
#include "apiAUDIO_v2_customer_utopia.h"
#include "apiAUDIO_v2_customer_config.h"
#include "MsTypes.h"
#include "MsOS.h"
#include "MsCommon.h"
#include "apiXC.h"
#include "drvXC_HDMI_if.h"
#include "apiDMX.h"

//-------------------------------------------------------------------------------------------------------------------------------------
// [Distinction Area] [kernel space / user space] [#include local library] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space

#else //User Space
#if (UTPA_SUPPORT_AAC_ENCODE == 1)
#include "./aenc/libaac/inc/exp_emz_common.h"
#include "./aenc/libaac/inc/exp_emz_memory.h"
#include "./aenc/libaac/inc/exp_Mp4AacEnc_API.h"
#endif
#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Share Area] shared [#define] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#define AU_VERSION                          0x04E2
#define AU_NDBG_LOG_TO_FILE_PATH            "/tmp/AudioCUSnDBGLog.log"
#define AU_NDBG_MENULOG_TO_FILE_PATH        "/tmp/AudioCUSnDBGMenuLog.log"
#define AU_R2_LOG_TO_FILE_PATH              "/tmp/AudioR2Log.log"
#define AU_DDR_BIN_PATH                     "/tmp/AUDIO_DDR.bin"
#define AU_ADEC_PCM_DUMP_PATH               "/tmp/AdecPcmDump.pcm"
#define AU_PCM_CAPTURE_SOURCE_DUMP_PATH     "/tmp/PcmCaptureSourceDump.pcm"
#define AU_R2_UART_ENABLE_MESSAGE           "R2_UART_ENABLE (TV: 0x0 / 0xCCCC, STB: 0x456 / 0x466 / 0x65c / ... : \n"
#define AU_HW_DMA_READER1                   "HW DMA Reader1"
#define AU_UNUSED(x)                        ((x)=(x))

//Bifrost parser
#define DTS_AUDIO_PARSER_ENABLE     1
#define WMA_AUDIO_PARSER_ENABLE     1
#define XPCM_AUDIO_PARSER_ENABLE    1

//HDMI set non-pcm
//Main Sub: 0/1
//PCM NPCM: 0/1
#define AU_HDMI_MAIN_PCM  0x00
#define AU_HDMI_MAIN_NPCM 0x01
#define AU_HDMI_SUB_PCM   0x10
#define AU_HDMI_SUB_NPCM  0x11

/* MP3 Encode parameter */
#define MP3_REQUEST_BYTES (384*2)

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
/* AAC Encode parameter */
#define AAC_ENCODED_LENTH (6144)
#define AAC_REQUEST_BYTES (4096)
#endif

//AU Demo MM New Mode Get PCM
#define AU_DEMO_MM_NEW_MODE_GET_PCM_BUFFER_SIZE 1024000
#define AU_DEMO_MM_NEW_MODE_GET_PCM_FILE_PATH   "/tmp/Demo_Audio_AdecPcmDump.pcm"

//AU Demo MM New Mode Get PCM
#define AU_MM_MODE_GET_ES_BUFFER_PATH   "/tmp/MM_Audio_ESDump.bin"

//AU debug get string input
#define AU_DEBUG_INPUT_STR_LENGTH       255
#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0

#ifdef  CONFIG_MBOOT
#define fflush(x)           //define for mboot compile error
#define fwrite(a,b,c,d)     //define for mboot compile error
#endif

//MSTAR GEQ Max band
#define MSTAR_SE_GEQ_MAX_BAND 5

//MSTAR PEQ Max band
#define MSTAR_SE_PEQ_MAX_BAND 8

//-------------------------------------------------------------------------------------------------------------------------------------
// [Distinction Area] [kernel space / user space] [#define] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
#define AU_nDBG(_f,_a...)                                                                                                                   \
    {                                                                                                                                       \
        if(pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg)                                                              \
        {                                                                                                                                   \
            printf("\033[1;32m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);    \
        }                                                                                                                                   \
    }

#define AU_nPRINT(_f,_a...)                                                                                                                 \
    {                                                                                                                                       \
        printf("\033[1;32m"_f"\033[0m", ##_a);                                                                                              \
    }

#define AU_nThreadDBG(_f,_a...)                                                                                                                 \
    {                                                                                                                                           \
        if( (pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg) && (pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg) )  \
        {                                                                                                                                       \
            printf("\033[0;33m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);        \
        }                                                                                                                                       \
    }

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
#define E_EMZ_TRUE               1
#define E_EMZ_FALSE              0
#define E_EMZ_ON                 1
#define E_EMZ_OFF                0

/* Common error code definitions */
#define E_EMZ_SUCCESS            0
#define E_EMZ_FAILURE           (-1)
#define E_EMZ_OUT_OF_MEMORY     (-2)
#define E_EMZ_INVALID_ARGS      (-3)
#define E_EMZ_NOT_SUPPORTED     (-4)
#define E_EMZ_INVALID_HANDLE    (-5)
#define E_EMZ_ENC_UNINITIALIZED (-6)
#define E_EMZ_ENCODE_COMPLETE   (-7)

/* Individual component error code base definitions */
#define E_EMZ_AUDIO_DECODER_ERROR_BASE   ((tEmzInt32) -1000)
#define E_EMZ_AUDIO_ENCODER_ERROR_BASE   ((tEmzInt32) -2000)
#define E_EMZ_VIDEO_DECODER_ERROR_BASE   ((tEmzInt32) -3000)
#define E_EMZ_VIDEO_ENCODER_ERROR_BASE   ((tEmzInt32) -4000)
#define E_EMZ_IMAGE_DECODER_ERROR_BASE   ((tEmzInt32) -5000)
#define E_EMZ_IMAGE_ENCODER_ERROR_BASE   ((tEmzInt32) -6000)
#define E_EMZ_SYSTEM_ERROR_BASE          ((tEmzInt32)-10000)
#endif

/* kernel debug proc */
#define AU_CUS_KERNEL_DEBUG_PROC_STRING_BUFFER_LENGTH             128
#define AU_CUS_KERNEL_DEBUG_PROC_ROOT_NAME                        "MstarAudioCustomerDebug"
#define AU_CUS_KERNEL_DEBUG_PROC_MAX_CHILD                        2 //<--Remember add one when add new proc
#define AU_CUS_KERNEL_DEBUG_PROC_CHILD_0001_NDBG                  "0001_nDBG"          /* proc child 1  */
#define AU_CUS_KERNEL_DEBUG_PROC_CHILD_0002_SHOW_VERSION          "0002_ShowVersion"   /* proc child 2  */

#else //User Space
#define SYS_SHM_QUERY          0x00000000UL
#define SYS_SHM_CREATE         0x00000001UL

#ifdef CONFIG_MBOOT
#define AU_nDBG(_f,_a...)                                                                                                                   \
    {                                                                                                                                       \
        if(pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg)                                                              \
        {                                                                                                                                   \
            printf("\033[1;32m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);    \
        }                                                                                                                                   \
    }

#define AU_nPRINT(_f,_a...)                                                                                                                 \
    {                                                                                                                                       \
        printf("\033[1;32m"_f"\033[0m", ##_a);                                                                                              \
    }

#define AU_nThreadDBG(_f,_a...)                                                                                                                 \
    {                                                                                                                                           \
        if( (pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg) && (pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg) )  \
        {                                                                                                                                       \
            if(__LINE__ != pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line)                                                      \
            {                                                                                                                                   \
                printf("\033[0;33m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);    \
                pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line = __LINE__;                                                      \
            }                                                                                                                                   \
        }                                                                                                                                       \
    }
#else
#define AU_nDBG(_f,_a...)                                                                                                                                           \
    {                                                                                                                                                               \
        if(pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg)                                                                                      \
        {                                                                                                                                                           \
            printf("\033[1;32m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);                            \
        }                                                                                                                                                           \
        if(pAU_nDBG_Log_To_File)                                                                                                                                    \
        {                                                                                                                                                           \
            fprintf(pAU_nDBG_Log_To_File, "\033[1;32m" "[A]" "[%ld]" "[%s]" "[%d]"_f "\033[0m" , (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);     \
            fflush(pAU_nDBG_Log_To_File);                                                                                                                           \
        }                                                                                                                                                           \
    }

#define AU_nPRINT(_f,_a...)                                                                                                                                         \
    {                                                                                                                                                               \
        printf("\033[1;32m"_f"\033[0m", ##_a);                                                                                                                      \
        if(pAU_nDBG_MenuLog_To_File)                                                                                                                                \
        {                                                                                                                                                           \
            fprintf(pAU_nDBG_MenuLog_To_File, _f, ##_a);                                                                                                            \
            fflush(pAU_nDBG_MenuLog_To_File);                                                                                                                       \
        }                                                                                                                                                           \
    }

#define AU_nThreadDBG(_f,_a...)                                                                                                                                         \
    {                                                                                                                                                                   \
        if( (pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg) && (pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg) )                          \
        {                                                                                                                                                               \
            if(__LINE__ != pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line)                                                                              \
            {                                                                                                                                                           \
                printf("\033[0;33m" "[A]" "[%ld]" "[%s]" "[%d]" _f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);                            \
                pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line = __LINE__;                                                                              \
            }                                                                                                                                                           \
        }                                                                                                                                                               \
        if((pAU_nDBG_Log_To_File) && (pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg) && (pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg))  \
        {                                                                                                                                                               \
            fprintf(pAU_nDBG_Log_To_File, "\033[0;33m" "[A]" "[%ld]" "[%s]" "[%d]"_f "\033[0m", (long int)MsOS_GetSystemTime(), __FUNCTION__, __LINE__, ##_a);          \
            fflush(pAU_nDBG_Log_To_File);                                                                                                                               \
        }                                                                                                                                                               \
    }
#endif

#define NON_SCANF_DEBUG_CMD_PARAMS_MAX 30

#if(DTS_AUDIO_PARSER_ENABLE)
#define DTS_BOOLEAN_CONVERT(n) ((n) ? dtsTrue : dtsFalse)

/* pre-calculate sizeof for speed */
#define dtsInt32SizeBytes                        (sizeof(dtsInt32))
#define dtsUint16SizeBytes                       (sizeof(dtsUint16))
#define dtsUint32SizeBytes                       (sizeof(dtsUint32))
#define dtsUint64SizeBytes                       (sizeof(dtsUint64))

#define DTS_WAV_FILE_CHUNK_ID_LENGTH     (4)
#define DTS_WAV_FILE_CHUNK_LENGTH_LENGTH (4)

#define DTS_WAV_FILE_FORMAT_CHUNK_ID     "fmt " /* Note that the space is important at the end of this */
#define DTS_WAV_FILE_DATA_CHUNK_ID       "data"

/* Identifiers for wave file start */
#define DTS_WAV_FILE_IDENTIFIER          "RIFF"
#define DTS_WAV_FILE_ID_LENGTH           (4)
#define DTS_WAV_FILE_CONTENT             "WAVE"
#define DTS_WAV_FILE_CONTENT_LENGTH      (4)

/* Format chunk information */
#define DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE  (16)
#define DTS_WAV_FILE_FORMAT_PCM_ID                  (0x0001)

/* RIFF header length */
//(4 + (2*4) + (2*4) + 16) = 0x24
#define DTS_WAV_FILE_RIFF_HEADER_LENGTH     (DTS_WAV_FILE_CONTENT_LENGTH + (2*DTS_WAV_FILE_CHUNK_ID_LENGTH) + (2*DTS_WAV_FILE_CHUNK_LENGTH_LENGTH) + DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE)

#define DTS_FILETYPE_WAV       1
#define DTS_FILETYPE_DTSHD     2
#define DTS_FILETYPE_RAW_PCM   3

#define DTS_HD_MAX_ASSETS           (8)
#define DTS_HD_MAX_BUILDVER_BYTES   (128)

/* Macro definitions for HD file contents */
#define DTS_HD_CHUNK_ID_LENGTH      (8)
#define DTS_HD_CHUNK_LENGTH_LENGTH  (8)

#define DTS_HD_CHUNK_HDR        "DTSHDHDR"
#define DTS_HD_CHUNK_FILEINFO   "FILEINFO"
#define DTS_HD_CHUNK_CORESSMD   "CORESSMD"
#define DTS_HD_CHUNK_EXTSS_MD   "EXTSS_MD"
#define DTS_HD_CHUNK_AUPR_HDR   "AUPR-HDR"
#define DTS_HD_CHUNK_AUPRINFO   "AUPRINFO"
#define DTS_HD_CHUNK_NAVI_TBL   "NAVI-TBL"
#define DTS_HD_CHUNK_BITSHVTB   "BITSHVTB"
#define DTS_HD_CHUNK_STRMDATA   "STRMDATA"
#define DTS_HD_CHUNK_TIMECODE   "TIMECODE"
#define DTS_HD_CHUNK_BUILDVER   "BUILDVER"

/* Minimum lengths required for chunks */
#define DTS_HD_DTSHDR_MIN_LENGTH_IN_BYTES   (13)
#define DTS_HD_CORESSMD_MIN_LENGTH_IN_BYTES (11)
#define DTS_HD_EXTSSMD_MIN_LENGTH_IN_BYTES  (7)
#define DTS_HD_EXTSSMD_MAX_LENGTH_IN_BYTES  (8)
#define DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES  (21)
#define DTS_HD_AUPRHDR_MAX_LENGTH_IN_BYTES  (29)
#define DTS_HD_NAVITBL_MIN_LENGTH_IN_BYTES  (7)
#define DTS_HD_BUILDVER_MAX_LENGTH_IN_BYTES (128)
#define DTS_HD_TIMECODE_MIN_LENGTH_IN_BYTES (29)
#endif //#if(DTS_AUDIO_PARSER_ENABLE)

#if(WMA_AUDIO_PARSER_ENABLE)
#ifndef _WMAERR_DEFINED
#define _WMAERR_DEFINED
typedef int WMAERR;
#endif /* _WMAERR_DEFINED */

#define WMA_DBG_PRINT(x)        //x
#define WMAERR_OK               0
#define WMAERR_FAIL             1
#define WMAERR_INVALIDARG       2
#define WMAERR_BUFFERTOOSMALL   3
#define WMAERR_INVALIDHEADER    4
#define WMAERR_OUTOFMEMORY      5
#define WMAERR_CORRUPTDATA      6
#define WMAERR_NOTDONE          7 /* need more data to finish the work */
#define WMAERR_INVALIDSTATE     8
#define MIN_OBJECT_SIZE         24
#define DATA_OBJECT_SIZE        50
#define FILEPROPFLAG_BROADCAST  1
#define WMAPRO_DECODE_FIFO_SIZE (1024*20)
#define WMA_MAX_DATA_REQUESTED  128
#define WMA_MAX_METADATA_LEN    512 // Max length (in bytes) of any metadata field - note that metadata is WCHAR, so use even numbers
                                    // We will truncate incoming metadata to this length (and skip past the remaining data).
                                    // If you want to support max allowable size, set this to 65535 (0xFFFF).
#define MAX_BUFSIZE 128

#define WMA_IsEqualGUID(rguid1, rguid2) (!memcmp((void *)rguid1, (void *)rguid2, sizeof(GUID)))

#define GetUnalignedWord( pb, w ) \
            (w) = ((unsigned short) *(pb + 1) << 8) + *pb;

#define GetUnalignedDword( pb, dw ) \
            (dw) = ((unsigned int) *(pb + 3) << 24) + \
                   ((unsigned int) *(pb + 2) << 16) + \
                   ((unsigned int) *(pb + 1) << 8)  + *pb;

#define GetUnalignedQword(pb, qw)               \
            GetUnalignedDword(pb, (qw).dwLo);   \
            GetUnalignedDword((pb + 4), (qw).dwHi);

#define GetUnalignedDouble( pb, d ) (d) = *(UNALIGNED double*)(pb);

#define GetUnalignedWordEx(pb, w)     GetUnalignedWord(pb, w)   ; (pb) += sizeof(unsigned short);
#define GetUnalignedDwordEx(pb, dw)   GetUnalignedDword(pb, dw) ; (pb) += sizeof(unsigned int);
#define GetUnalignedQwordEx(pb, qw)   GetUnalignedQword(pb, qw) ; (pb) += sizeof(QWORD);
#define GetUnalignedDoubleEx(pb, d)   GetUnalignedDouble(pb, d) ; (pb) += sizeof(double);

#define LoadBYTE(b, p)    b = *(unsigned char *)(p);  (p) += sizeof(unsigned char)

#define LoadWORD(w, p)    GetUnalignedWordEx(p, w)
#define LoadDWORD(dw, p)  GetUnalignedDwordEx(p, dw)
#define LoadQWORD(qw, p)  GetUnalignedQwordEx(p, qw)

#define LoadGUID( g, p ) \
        { \
            LoadDWORD( (g).Data1,    p ); \
            LoadWORD(  (g).Data2,    p ); \
            LoadWORD(  (g).Data3,    p ); \
            LoadBYTE(  (g).Data4[0], p ); \
            LoadBYTE(  (g).Data4[1], p ); \
            LoadBYTE(  (g).Data4[2], p ); \
            LoadBYTE(  (g).Data4[3], p ); \
            LoadBYTE(  (g).Data4[4], p ); \
            LoadBYTE(  (g).Data4[5], p ); \
            LoadBYTE(  (g).Data4[6], p ); \
            LoadBYTE(  (g).Data4[7], p ); \
        }

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

typedef struct tWAVEFORMATEX
{
    unsigned short  wFormatTag;        /* format type */
    unsigned short  nChannels;         /* number of channels (i.e. mono, stereo...) */
    unsigned int    nSamplesPerSec;    /* sample rate */
    unsigned int    nAvgBytesPerSec;   /* for buffer estimation */
    unsigned short  nBlockAlign;       /* block size of data */
    unsigned short  wBitsPerSample;    /* Number of bits per sample of mono data */
    unsigned short  cbSize;            /* The count in bytes of the size of
                                          extra information (after cbSize) */
} WAVEFORMATEX;

typedef WAVEFORMATEX *PWAVEFORMATEX;
typedef WAVEFORMATEX *NPWAVEFORMATEX;
typedef WAVEFORMATEX *LPWAVEFORMATEX;
#endif /* _WAVEFORMATEX_ */

#ifndef WAVE_FORMAT_PCM
#define WAVE_FORMAT_PCM 1
#endif /* WAVE_FORMAT_PCM */

#if !defined (WAVE_FORMAT_WMAUDIO_LOSSLESS)
#define WAVE_FORMAT_WMAUDIO_LOSSLESS  0x0163
#endif

#ifndef WAVE_FORMAT_EXTENSIBLE
#define WAVE_FORMAT_EXTENSIBLE 65534
#endif /* WAVE_FORMAT_EXTENSIBLE */

#if !defined (WAVE_FORMAT_WMAUDIO3)
#define WAVE_FORMAT_WMAUDIO3  0x0162

typedef struct wmaudio3waveformat_tag
{
    WAVEFORMATEX wfx;
    unsigned short  wValidBitsPerSample; // bits of precision
    unsigned int    dwChannelMask;       // which channels are present in stream
    unsigned int    dwReserved1;
    unsigned int    dwReserved2;
    unsigned short  wEncodeOptions;
    unsigned short  wReserved3;
} WMAUDIO3WAVEFORMAT;
#endif

#if !defined (WAVE_FORMAT_WMAUDIO_LOSSLESS_ES)
#define WAVE_FORMAT_WMAUDIO_LOSSLESS_ES  0x0167
#endif

#define WAVE_FORMAT_MSAUDIO1  0x0160
#define WAVE_FORMAT_WMAUDIO2  0x0161

#ifndef _SPEAKER_POSITIONS_
#define _SPEAKER_POSITIONS_
/* Speaker Positions for dwChannelMask in WAVEFORMATEXTENSIBLE: from ksmedia.h */
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000
#endif /* _SPEAKER_POSITIONS_ */

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef struct tQWORD
{
    unsigned int   dwLo;
    unsigned int   dwHi;
}   QWORD;
#endif /* _QWORD_DEFINED */

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct // size is 16
{
    unsigned int   Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;
#endif //!GUID_DEFINED

#ifndef _WMAFILECONTDESC_DEFINED
#define _WMAFILECONTDESC_DEFINED
typedef struct tagWMAFileContDesc
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */
    unsigned short title_len;
    unsigned short author_len;
    unsigned short copyright_len;
    unsigned short description_len;   /* rarely used */
    unsigned short rating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */
    unsigned char *pTitle;
    unsigned char *pAuthor;
    unsigned char *pCopyright;
    unsigned char *pDescription;
    unsigned char *pRating;

} tWMAFileContDesc;
#endif /* _WMAFILECONTDESC_DEFINED */

#define DESC_NAME_MAX_LENGTH   64
typedef struct _MarkerEntry
{
    QWORD   m_qOffset;
    QWORD   m_qtime;
    unsigned short  m_wEntryLen;
    unsigned int    m_dwSendTime;
    unsigned int    m_dwFlags;
    unsigned int    m_dwDescLen;
    unsigned short  m_pwDescName[DESC_NAME_MAX_LENGTH];
} MarkerEntry;

#ifndef _ECD_DEFINED_
#define _ECD_DEFINED_
enum
{
    ECD_STRING  = 0,
    ECD_BINARY  = 1,
    ECD_BOOL    = 2,
    ECD_DWORD   = 3,
    ECD_QWORD   = 4,
    ECD_WORD    = 5
};

typedef struct _ECD_DESCRIPTOR
{
    unsigned short  cbName;
    unsigned short  *pwszName;
    unsigned short  data_type;
    unsigned short  cbValue;
    union
    {
        unsigned short      *pwszString;
        char                *pbBinary;
        unsigned int        *pfBool;
        unsigned int        *pdwDword;
        unsigned long long  *pqwQword;
        unsigned short      *pwWord;
    } uValue;
} ECD_DESCRIPTOR;
#endif //_ECD_DEFINED_

#ifndef _WMAFILESTATUS_DEFINED
#define _WMAFILESTATUS_DEFINED
typedef enum tagWMAFileStatus
{
    cWMA_NoErr,  /* -> always first entry */

    /* remaining entry order is not guaranteed */
    cWMA_Failed,
    cWMA_BadArgument,
    cWMA_BadAsfHeader,
    cWMA_BadPacketHeader,
    cWMA_BrokenFrame,
    cWMA_NoMoreFrames,
    cWMA_BadSamplingRate,
    cWMA_BadNumberOfChannels,
    cWMA_BadVersionNumber,
    cWMA_BadWeightingMode,
    cWMA_BadPacketization,

    cWMA_BadDRMType,
    cWMA_DRMFailed,
    cWMA_DRMUnsupported,

    cWMA_DemoExpired,

    cWMA_BadState,
    cWMA_Internal,/* really bad */
    cWMA_NoMoreDataThisTime
} tWMAFileStatus;
#endif /* _WMAFILESTATUS_DEFINED */

#if !defined (COPY_KSDATAFORMAT_SUBTYPE_PCM)
#define COPY_KSDATAFORMAT_SUBTYPE_PCM(guid) \
     (guid)->Data1      = 0x01;             \
     (guid)->Data2      = 0x00;             \
     (guid)->Data3      = 0x10;             \
     (guid)->Data4[0]   = 0x80;             \
     (guid)->Data4[1]   = 0x00;             \
     (guid)->Data4[2]   = 0x00;             \
     (guid)->Data4[3]   = 0xaa;             \
     (guid)->Data4[4]   = 0x00;             \
     (guid)->Data4[5]   = 0x38;             \
     (guid)->Data4[6]   = 0x9b;             \
     (guid)->Data4[7]   = 0x71;
#endif //COPY_KSDATAFORMAT_SUBTYPE_PCM
#endif //#if(WMA_AUDIO_PARSER_ENABLE)

#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Share Area] shared [variable / struct / enum] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
typedef struct
{
    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Initialize, STR */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Audio init flag
    MS_BOOL g_audio_customer_Init_Done;
    MS_BOOL g_audio_customer_STR_bSuspendStart;
    MS_BOOL g_audio_customer_STR_bResumeFinish;
    MS_BOOL g_audio_customer_scanf_bSupport;
    API_AUDIO_CUSTOMER_CHIP_PLATFORM g_audio_customer_Chip_Platform;

    //Dynamic Enable all apiAUDIO_v2_customer debug msg
    MS_BOOL g_audio_customer_bEnableNonThreadPrintMsg;
    MS_BOOL g_audio_customer_bEnableThreadPrintMsg;
    MS_U32  g_audio_customer_bEnableThreadPrintMsg_Interval;
    MS_BOOL g_audio_customer_bThreadPrintMsg;
    MS_U32  g_audio_customer_bThreadPrintMsg_Interval;
    MS_U32  g_audio_customer_bThreadPrintMsg_Line;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Connect & Disconnect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Parser connect
    API_AUDIO_CUSTOMER_PARSER_MODE  g_audio_customer_PARSER_Mode;
    API_AUDIO_CUSTOMER_PARSER_INPUT g_audio_customer_PARSER_A_Connect;
    API_AUDIO_CUSTOMER_PARSER_INPUT g_audio_customer_PARSER_B_Connect;
    API_AUDIO_CUSTOMER_PARSER_INPUT g_audio_customer_PARSER_C_Connect;
    API_AUDIO_CUSTOMER_PARSER_INPUT g_audio_customer_PARSER_D_Connect;

    //ADEC connect / ID / Gain / Mute
    API_AUDIO_CUSTOMER_ADEC_INPUT g_audio_customer_ADEC0_Connect;
    API_AUDIO_CUSTOMER_ADEC_INPUT g_audio_customer_ADEC1_Connect;
    API_AUDIO_CUSTOMER_ADEC_INPUT g_audio_customer_ADEC_ATV_Connect;
    AUDIO_DEC_ID g_audio_customer_ADEC0_DecID;
    AUDIO_DEC_ID g_audio_customer_ADEC1_DecID;
    AUDIO_DEC_ID g_audio_customer_ADEC_ATV_DecID;
    int     g_audio_customer_ADEC0_Gain;
    int     g_audio_customer_ADEC1_Gain;
    MS_BOOL g_audio_customer_ADEC0_bMute;
    MS_BOOL g_audio_customer_ADEC1_bMute;

    //ADC connect
    API_AUDIO_CUSTOMER_ADC_IN_PORT g_audio_customer_ADC0_Connect;
    API_AUDIO_CUSTOMER_ADC_IN_PORT g_audio_customer_ADC1_Connect;

    //PCM Mixer connect / ID / Gain / Mute
    MS_BOOL g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_MAX];
    int g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_MAX];
    int g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_MAX];
    MS_BOOL g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_MAX];

    //Channel Sound Connect / inDelay
    API_AUDIO_CUSTOMER_CH_INPUT g_audio_customer_CH5_Sound_Connect;
    API_AUDIO_CUSTOMER_CH_INPUT g_audio_customer_CH6_Sound_Connect;
    API_AUDIO_CUSTOMER_CH_INPUT g_audio_customer_CH7_Sound_Connect;
    API_AUDIO_CUSTOMER_CH_INPUT g_audio_customer_CH8_Sound_Connect;
    int g_audio_customer_CH5_Sound_inDelay;
    int g_audio_customer_CH6_Sound_inDelay;
    int g_audio_customer_CH7_Sound_inDelay;
    int g_audio_customer_CH8_Sound_inDelay;

    //FW Mixer Connect / Gain / Mute / Delay
    MS_BOOL g_audio_customer_FW_Mixer0_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer1_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer2_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_U32  g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_U32  g_audio_customer_FW_Mixer1_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_U32  g_audio_customer_FW_Mixer2_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer1_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer2_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    int     g_audio_customer_FW_Mixer0_Channel_Delay;
    int     g_audio_customer_FW_Mixer1_Channel_Delay;
    int     g_audio_customer_FW_Mixer2_Channel_Delay;

    //FW Mixer During Limit time mute
    MS_BOOL g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer1_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer2_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];

    //FW Mixer final mute
    MS_BOOL g_audio_customer_FW_Mixer0_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer1_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];
    MS_BOOL g_audio_customer_FW_Mixer2_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_MAX];

    //SE delay, SE(PreR2 / SeDSP / PostR2) connect
    int                         g_audio_customer_SE_UpperDelay;
    int                         g_audio_customer_SE_DriverDelay;
    API_AUDIO_CUSTOMER_SE_INPUT g_audio_customer_SE_PreR2_Connect;
    API_AUDIO_CUSTOMER_SE_INPUT g_audio_customer_SE_DspSE_Connect;
    API_AUDIO_CUSTOMER_SE_INPUT g_audio_customer_SE_PostR2_Connect;

    //SOUND OUT connect / Gain / Mute / SPDIF,HDMI(fg/Mode/PCM,NPCM mute/Delay)
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_I2S_Connect;
    int     g_audio_customer_Sound_Out_I2S_Gain;
    MS_BOOL g_audio_customer_Sound_Out_I2S_bMute;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_Line0_Connect;
    int     g_audio_customer_Sound_Out_Line0_Gain;
    MS_BOOL g_audio_customer_Sound_Out_Line0_bMute;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_Line1_Connect;
    int     g_audio_customer_Sound_Out_Line1_Gain;
    MS_BOOL g_audio_customer_Sound_Out_Line1_bMute;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_Line2_Connect;
    int     g_audio_customer_Sound_Out_Line2_Gain;
    MS_BOOL g_audio_customer_Sound_Out_Line2_bMute;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_Line3_Connect;
    int     g_audio_customer_Sound_Out_Line3_Gain;
    MS_BOOL g_audio_customer_Sound_Out_Line3_bMute;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_SPDIF_Connect;
    int     g_audio_customer_Sound_Out_SPDIF_Gain;
    MS_BOOL g_audio_customer_Sound_Out_SPDIF_bMute;
    int     g_audio_customer_Sound_Out_SPDIF_UpperDelay;
    int     g_audio_customer_Sound_Out_SPDIF_DriverDelay;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_ARC_Connect;
    API_AUDIO_CUSTOMER_SPDIF_TX_MODE  g_audio_customer_Sound_Out_ARC_mode;
    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT g_audio_customer_Sound_Out_HDMI_Connect;
    int     g_audio_customer_Sound_Out_HDMI_Gain;
    MS_BOOL g_audio_customer_Sound_Out_HDMI_bMute;
    int     g_audio_customer_Sound_Out_HDMI_UpperDelay;
    int     g_audio_customer_Sound_Out_HDMI_DriverDelay;

    //SetSourceInfo / InputSwitch
    AUDIO_SOURCE_INFO_TYPE  g_audio_customer_AU_SetSourceInfo_eSourceType;
    AUDIO_INPUT_TYPE        g_audio_customer_AU_InputSwitch_enSource;
    AUDIO_SWITCH_GROUP      g_audio_customer_AU_InputSwitch_enGroup;

    //sound out During Limit time mute
    MS_BOOL g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_OUTPUT_MAX];

    //sound out final mute
    MS_BOOL g_audio_customer_Sound_Out_I2S_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_Line0_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_Line1_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_Line2_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_Line3_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_SPDIF_final_bMute;
    MS_BOOL g_audio_customer_Sound_Out_HDMI_final_bMute;

    //PCM Capture connect / bEnable / Gain / Mute /  Delay
    API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT g_audio_customer_PCM_CAPTURE0_Connect;
    MS_BOOL g_audio_customer_PCM_CAPTURE0_bEnable;
    int     g_audio_customer_PCM_CAPTURE0_Gain;
    MS_BOOL g_audio_customer_PCM_CAPTURE0_bMute;
    int     g_audio_customer_PCM_CAPTURE0_Delay;
    API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT g_audio_customer_PCM_CAPTURE1_Connect;
    MS_BOOL g_audio_customer_PCM_CAPTURE1_bEnable;
    int     g_audio_customer_PCM_CAPTURE1_Gain;
    MS_BOOL g_audio_customer_PCM_CAPTURE1_bMute;
    int     g_audio_customer_PCM_CAPTURE1_Delay;
    API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT g_audio_customer_PCM_CAPTURE2_Connect;
    MS_BOOL g_audio_customer_PCM_CAPTURE2_bEnable;
    int     g_audio_customer_PCM_CAPTURE2_Gain;
    MS_BOOL g_audio_customer_PCM_CAPTURE2_bMute;
    int     g_audio_customer_PCM_CAPTURE2_Delay;

    //MP3 ENC connect / bEnable
    API_AUDIO_CUSTOMER_MP3_ENC_INPUT g_audio_customer_MP3_ENC_Connect;
    MS_BOOL g_audio_customer_MP3_ENC_bEnable;

    //AAC ENC connect / bEnable
    API_AUDIO_CUSTOMER_AAC_ENC_INPUT g_audio_customer_AAC_ENC_Connect;
    MS_BOOL g_audio_customer_AAC_ENC_bEnable;

    //AENC Gain
    MS_U32 g_audio_customer_AENC_Gain;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Start & Stop */
    //-------------------------------------------------------------------------------------------------------------------------------------
    API_AUDIO_CUSTOMER_ADEC_INDEX g_audio_customer_MainDecoderOutput;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* SPDIF */
    //-------------------------------------------------------------------------------------------------------------------------------------
    API_AUDIO_CUSTOMER_SPDIF_TX_MODE        g_audio_customer_SPDIF_TX_UpperOutputType;
    API_AUDIO_CUSTOMER_SPDIF_TX_MODE        g_audio_customer_SPDIF_TX_DriverOutputType;
    API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT      g_audio_customer_SPDIF_TX_CopyInfo;
    MS_U8                                   g_audio_customer_SPDIF_TX_CategoryCode;
    MS_BOOL                                 g_audio_customer_SPDIF_TX_LightOnOff;
    MS_BOOL                                 g_audio_customer_SPDIF_TX_MonitorOnOff;
    API_AUDIO_CUSTOMER_SPDIF_CS_TYPE        g_audio_customer_SPDIF_TX_ChannelStatus_Type;
    API_AUDIO_CUSTOMER_SPDIF_CS_TYPE_STATUS g_audio_customer_SPDIF_TX_ChannelStatus_Type_Status;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* HDMI */
    //-------------------------------------------------------------------------------------------------------------------------------------
    API_AUDIO_CUSTOMER_CODEC_TYPE           g_audio_customer_HDMI_RX_Current_Codec_Type;
    API_AUDIO_CUSTOMER_CODEC_TYPE           g_audio_customer_HDMI_RX_Previous_Codec_Type;
    MS_BOOL                                 g_audio_customer_HDMI_RX_AudioReturnChannel;
    API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT      g_audio_customer_HDMI_RX_CopyInfo;
    MS_BOOL                                 g_audio_customer_HDMI_RX_MonitorOnOff;
    API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE  g_audio_customer_HDMI_TX_UpperOutputType;
    API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE  g_audio_customer_HDMI_TX_DriverOutputType;
    MS_BOOL                                 g_audio_customer_HDMI_TX_MonitorOnOff;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* ATV */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //ATV_Prescale(A2)
    int g_audio_customer_ADEC_ATV_Prescale_A2_FM;
    int g_audio_customer_ADEC_ATV_Prescale_NICAM;
    int g_audio_customer_ADEC_ATV_Prescale_AM;
    int g_audio_customer_ADEC_ATV_Prescale_HIDEV;
    int g_audio_customer_ADEC_ATV_Prescale_FM_M;
    int g_audio_customer_ADEC_ATV_Prescale_HIDEV_M;

    //ATV_Prescale(BTSC)
    int g_audio_customer_ADEC_ATV_Prescale_BTSC;
    int g_audio_customer_ADEC_ATV_Prescale_BTSC_MONO;
    int g_audio_customer_ADEC_ATV_Prescale_BTSC_STEREO;
    int g_audio_customer_ADEC_ATV_Prescale_BTSC_SAP;

    //Monitor
    MS_BOOL g_audio_customer_SIF_MonitorOnOff;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Decoder */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Codec Type (Upper layer)
    API_AUDIO_CUSTOMER_CODEC_TYPE   g_audio_customer_ADEC0_UpperCodec;
    API_AUDIO_CUSTOMER_CODEC_TYPE   g_audio_customer_ADEC1_UpperCodec;
    API_AUDIO_CUSTOMER_SIF_TYPE     g_audio_customer_ADEC_ATV_UpperSifType;

    //Codec Type (Driver layer)
    En_DVB_decSystemType            g_audio_customer_ADEC0_DriverCodec;
    En_DVB_decSystemType            g_audio_customer_ADEC1_DriverCodec;
    En_DVB_decSystemType            g_audio_customer_ADEC_ATV_DriverSifType;

    //Play Cmd (Upper layer)
    API_AUDIO_CUSTOMER_UPPER_PLAYCMD g_audio_customer_ADEC0_UpperPlay;
    API_AUDIO_CUSTOMER_UPPER_PLAYCMD g_audio_customer_ADEC1_UpperPlay;
    API_AUDIO_CUSTOMER_UPPER_PLAYCMD g_audio_customer_ADEC_ATV_UpperPlay;

    //Play Cmd (Driver layer)
    AU_DVB_DECCMD g_audio_customer_ADEC0_DriverPlay;
    AU_DVB_DECCMD g_audio_customer_ADEC1_DriverPlay;
    AU_DVB_DECCMD g_audio_customer_ADEC_ATV_DriverPlay;

    //---Play/pause Cmd Delay---
    int g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay;
    int g_audio_customer_AU_CUS_PauseDecoding_Delay;

    //bMM mode (ADEC is used by MM)
    MS_BOOL g_audio_customer_ADEC0_bMM;
    MS_BOOL g_audio_customer_ADEC1_bMM;

    //Sync mode
    MS_BOOL g_audio_customer_ADEC0_SyncMode;
    MS_BOOL g_audio_customer_ADEC1_SyncMode;

    //DRC mode
    API_AUDIO_CUSTOMER_DOLBY_DRC_MODE g_audio_customer_ADEC0_AC3P_DolbyDRCMode;
    API_AUDIO_CUSTOMER_DOLBY_DRC_MODE g_audio_customer_ADEC1_AC3P_DolbyDRCMode;

    //Downmix mode
    API_AUDIO_CUSTOMER_DOWNMIX_MODE g_audio_customer_ADEC0_AC3P_DownmixMode;
    API_AUDIO_CUSTOMER_DOWNMIX_MODE g_audio_customer_ADEC1_AC3P_DownmixMode;

    //DualMono mode
    API_AUDIO_CUSTOMER_DUALMONO_MODE g_audio_customer_ADEC0_DualmonoMode;
    API_AUDIO_CUSTOMER_DUALMONO_MODE g_audio_customer_ADEC1_DualmonoMode;

    //Trick mode
    API_AUDIO_CUSTOMER_TRICK_MODE g_audio_customer_ADEC0_TrickMode;
    API_AUDIO_CUSTOMER_TRICK_MODE g_audio_customer_ADEC1_TrickMode;

    //AD bMain
    MS_BOOL g_audio_customer_ADEC0_AD_bMain;
    MS_BOOL g_audio_customer_ADEC1_AD_bMain;

    //AD Gain
    int g_audio_customer_ADEC0_AD_Gain;
    int g_audio_customer_ADEC1_AD_Gain;

    //ES Exist
    MS_BOOL g_audio_customer_ADEC0_bESExist;
    MS_BOOL g_audio_customer_ADEC1_bESExist;

    //ES Info
    API_AUDIO_CUSTOMER_HEAAC_ES_INFO g_audio_customer_ADEC0_HEAAC_EsInfo;
    API_AUDIO_CUSTOMER_MPEG_ES_INFO  g_audio_customer_ADEC0_MPEG_EsInfo;
    API_AUDIO_CUSTOMER_AC3_ES_INFO   g_audio_customer_ADEC0_AC3_EsInfo;
    API_AUDIO_CUSTOMER_HEAAC_ES_INFO g_audio_customer_ADEC1_HEAAC_EsInfo;
    API_AUDIO_CUSTOMER_MPEG_ES_INFO  g_audio_customer_ADEC1_MPEG_EsInfo;
    API_AUDIO_CUSTOMER_AC3_ES_INFO   g_audio_customer_ADEC1_AC3_EsInfo;

    //ADEC PCM output path
    API_AUDIO_CUSTOMER_ADEC_PCM_PATH g_audio_customer_ADEC0_PCM_OutputPath;
    API_AUDIO_CUSTOMER_ADEC_PCM_PATH g_audio_customer_ADEC1_PCM_OutputPath;

    //dump adec pcm (MCU path)
    MS_BOOL g_audio_customer_bEnableAdecPcmDump;

    //ADEC End of stream
    MS_BOOL g_audio_customer_ADEC0_End_Of_Stream_bRegister;
    MS_BOOL g_audio_customer_ADEC1_End_Of_Stream_bRegister;
    MS_U32  g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt;

    //ADEC Underrun
    MS_BOOL g_audio_customer_ADEC0_Underrun_bRegister;
    MS_U32  g_audio_customer_ADEC0_Underrun_Threshold_in_ms;
    MS_U32  g_audio_customer_ADEC0_Underrun_Debounce_Cnt;
    MS_BOOL g_audio_customer_ADEC1_Underrun_bRegister;
    MS_U32  g_audio_customer_ADEC1_Underrun_Threshold_in_ms;
    MS_U32  g_audio_customer_ADEC1_Underrun_Debounce_Cnt;

    //Monitor
    MS_BOOL g_audio_customer_Auto_Recovery_MonitorOnOff;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Common */
    //-------------------------------------------------------------------------------------------------------------------------------------
    #if (UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
    MS_U32 g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd;
    #endif //#if (UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Customized patch */
    //-------------------------------------------------------------------------------------------------------------------------------------
    #if (CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)
    MS_BOOL g_audio_customer_patch_HDMI_RX_ByPass_bEnable;
    #endif //#if (CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)

    #if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)
    MS_BOOL g_audio_customer_patch_Low_Latency_Limiter_bEnable;
    MS_U32  g_audio_customer_patch_Low_Latency_Limiter_ES_Threshold;
    MS_U32  g_audio_customer_patch_Low_Latency_Limiter_PCM_Threshold;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)

    #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
    MS_BOOL g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable;
    MS_U16  g_audio_customer_patch_MCU_Dump_R2_Log_Option;
    MS_U16  g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)

    #if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
    MS_BOOL g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable;
    MS_BOOL g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable;
    MS_BOOL g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)

    #if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
    MS_BOOL g_audio_customer_patch_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_bEnable;
    MS_BOOL g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)

    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
    MS_U32  g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)

    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI;
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI;
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM;
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM;
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType;
    API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO g_audio_customer_HDMI_RX_Monitr_Event_Previous_CodecType;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Customized Internal patch */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //---MS12 HDMI TX PCM ouput Auto Delay (for sync with NPCM)---
    //input: MS12 DD/DDP/DP
    int g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DD_in_Auto_Audio_Delay;
    int g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DDP_in_Auto_Audio_Delay;
    int g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DP_in_Auto_Audio_Delay;
    int g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay;

    //---General Buffer Dump---
    MS_BOOL g_audio_customer_internal_patch_General_Buffer_Dump_bEnable;
    MS_BOOL g_audio_customer_internal_patch_Dump_MM_ES1_bEnable;
    MS_BOOL g_audio_customer_internal_patch_Dump_PCM1_bEnable;
    MS_BOOL g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable;
    MS_BOOL g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable;
    MS_BOOL g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable;

    //---MS12 SNDR2 PCMR METADATA SELECT---
    int g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select;

    //---HW SRC Output Gain Compensate---
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out;
    int g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out;

    //---DDP_71 Auto Bypass check---
    API_AUDIO_CUSTOMER_ADEC_INDEX g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex;
    int g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_bEnable;
    int g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt;
    int g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt;
    int g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream;

    //---Avoid ADEC Pop Noise---
    int g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time;
    int g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time;

    //---ADEC mute delay---
    int g_audio_customer_AU_CUS_ADEC_SetMute_Delay;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Clip Play for ES */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Clip Play for PCM */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Gain, Mute & Delay */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AENC */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Dynamic dump file for debug
    MS_BOOL g_audio_customer_AENC_bDumpEncData;

    //AENC Enable
    MS_BOOL g_audio_customer_AENC0_bEnable;
    MS_BOOL g_audio_customer_AENC1_bEnable;

    //AENC Type
    API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT g_audio_customer_AENC0_Type;
    API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT g_audio_customer_AENC1_Type;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* PCM Capture */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //PCM capture Dump to file for debug
    MS_BOOL g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable;

    //PCM capture request data in byte
    MS_U32 g_audio_customer_PCM_CAPTURE_Request_data_in_byte;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* PCM IO Control */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* MM New Mode */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Mstar Sound Effect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //API_AUDIO_CUSTOMER_MSTAR_SE_Enable
    MS_BOOL g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_MSTAR_SE_MAX];
    MS_U32  g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_MSTAR_SE_MAX];

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ
    MS_S8   g_audio_customer_MSTAR_SE_SET_GEQ[MSTAR_SE_GEQ_MAX_BAND];
    MS_U32  g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[MSTAR_SE_GEQ_MAX_BAND];

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef
    API_AUDIO_CUSTOMER_MSTAR_PEQ_COEF g_audio_customer_MSTAR_SE_SET_PEQCoef[MSTAR_SE_PEQ_MAX_BAND];
    MS_U32  g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[MSTAR_SE_PEQ_MAX_BAND];

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef
    API_AUDIO_CUSTOMER_MSTAR_HPF_COEF g_audio_customer_MSTAR_SE_SET_HPFCoef;
    MS_U32  g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE
    API_AUDIO_CUSTOMER_MSTAR_AVC_MODE g_audio_customer_MSTAR_SE_SET_AVC_MODE;
    MS_U32  g_audio_customer_MSTAR_SE_SET_AVC_MODE_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL
    MS_U16  g_audio_customer_MSTAR_SE_SET_AVC_LEVEL;
    MS_U32  g_audio_customer_MSTAR_SE_SET_AVC_LEVEL_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin
    MS_U16  g_audio_customer_MSTAR_SE_SET_R_MODE_Begin;
    MS_U32  g_audio_customer_MSTAR_SE_SET_R_MODE_Begin_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End
    MS_U16  g_audio_customer_MSTAR_SE_SET_R_MODE_End;
    MS_U32  g_audio_customer_MSTAR_SE_SET_R_MODE_End_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Slope
    MS_U16  g_audio_customer_MSTAR_SE_SET_R_MODE_Slope;
    MS_U32  g_audio_customer_MSTAR_SE_SET_R_MODE_Slope_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET
    MS_U16  g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET;
    MS_U32  g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime
    MS_U8   g_audio_customer_MSTAR_SE_SET_AVC_AttackTime;
    MS_U32  g_audio_customer_MSTAR_SE_SET_AVC_AttackTime_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime
    MS_U8   g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime;
    MS_U32  g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL
    MS_U16  g_audio_customer_MSTAR_SE_SET_DRC_LEVEL;
    MS_U32  g_audio_customer_MSTAR_SE_SET_DRC_LEVEL_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE
    MS_U16  g_audio_customer_MSTAR_SE_SET_BALANCE_L;
    MS_U16  g_audio_customer_MSTAR_SE_SET_BALANCE_R;
    MS_U32  g_audio_customer_MSTAR_SE_SET_BALANCE_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold
    MS_U16  g_audio_customer_MSTAR_SE_SET_NR_Threshold;
    MS_U32  g_audio_customer_MSTAR_SE_SET_NR_Threshold_UpperSetCnt;

    //API_AUDIO_CUSTOMER_MSTAR_SE_GET_NR_Status
    MS_S32  g_audio_customer_MSTAR_SE_GET_NR_Threshold;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Advanced Sound Effect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //API_AUDIO_CUSTOMER_DTS_SE_Enable
    MS_BOOL g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_MAX];
    MS_U32  g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_MAX];

    //API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable
    MS_BOOL g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_MAX];
    MS_U32  g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_MAX];

    //API_AUDIO_CUSTOMER_DTS_SE_SetParam
    MS_U32  g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_MAX];
    MS_U32  g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_MAX];

    //API_AUDIO_CUSTOMER_Dolby_DAP_Enable
    MS_BOOL g_audio_customer_Dolby_DAP_Enable;
    MS_U32  g_audio_customer_Dolby_DAP_Enable_UpperSetCnt;

    //API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable
    MS_BOOL g_audio_customer_Dolby_DAP_ProcessUnit_Enable;
    MS_U32  g_audio_customer_Dolby_DAP_ProcessUnit_Enable_UpperSetCnt;

    //API_AUDIO_CUSTOMER_Dolby_DAP_SetParam
    API_AUDIO_CUSTOMER_DOLBY_DAP_PARAM g_audio_customer_Dolby_DAP_SetParam;
    MS_U32  g_audio_customer_Dolby_DAP_SetParam_UpperSetCnt;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Thread monitor Enable */
    //-------------------------------------------------------------------------------------------------------------------------------------
    MS_BOOL g_audio_customer_AU_CUS_ClipDecoderMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_MP3EncodeMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_MonitorService_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_AACEncodeMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_MuteDuringLimitedTime_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_AdecPcmOutMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_PCMCaptureMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_EndOfStreamMonitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_ADEC_Underrun_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_PATCH_Dump_R2_Log_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_INTERNAL_PATCH_R2_Active_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_Demo_MM_New_Mode_Play_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_Demo_PCMIO_Play_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_AV_Sync_Info_Monitor_bEnable;
    MS_BOOL g_audio_customer_AU_CUS_ThreadPrintMsg_Monitor_bEnable;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Thread monitor interval */
    //-------------------------------------------------------------------------------------------------------------------------------------
    MS_U32 g_audio_customer_AU_ClipDecoderMonitor_Interval;                         //ms
    MS_U32 g_audio_customer_AU_MP3EncodeMonitor_Interval;                           //ms
    MS_U32 g_audio_customer_AU_MonitorService_Interval;                             //ms
    MS_U32 g_audio_customer_AU_AACEncodeMonitor_Interval;                           //ms
    MS_U32 g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval;              //ms
    MS_U32 g_audio_customer_AU_AdecPcmOut_Interval;                                 //ms
    MS_U32 g_audio_customer_AU_PCMCapture_Interval;                                 //ms
    MS_U32 g_audio_customer_AU_EndOfStreamMonitor_Interval;                         //ms
    MS_U32 g_audio_customer_AU_AdecUnderrun_Interval;                               //ms
    MS_U32 g_audio_customer_patch_Dump_R2_Log_Monitor_Interval;                     //ms
    MS_U32 g_audio_customer_internal_patch_Auto_Audio_Delay_Monitor_Interval;       //ms
    MS_U32 g_audio_customer_internal_patch_General_Buffer_Dump_Monitor_Interval;    //ms
    MS_U32 g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_Interval;     //ms
    MS_U32 g_audio_customer_internal_patch_R2_Active_Monitor_Interval;              //ms

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AU Demo PCMIO play */
    //-------------------------------------------------------------------------------------------------------------------------------------
    API_AUDIO_CUSTOMER_PCMIO_PARAM   g_audio_customer_AU_Demo_PCMIO_pcmParam;
    API_AUDIO_CUSTOMER_UPPER_PLAYCMD g_audio_customer_AU_Demo_PCMIO_UpperPlay;
    MS_U32  g_audio_customer_AU_Demo_PCMIO_repeatNum;
    MS_U32  g_audio_customer_AU_Demo_PCMIO_Monitor_Interval;
    int     g_audio_customer_AU_Demo_PCMIO_input_file_length;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AU Demo MM New Mode */
    //-------------------------------------------------------------------------------------------------------------------------------------
    MS_U32  g_audio_customer_AU_Demo_MM_New_Mode_Play_StartTime;
    MS_U32  g_audio_customer_AU_Demo_MM_New_Mode_AD_Play_StartTime;
    MS_U32  g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AV Sync Info */
    //-------------------------------------------------------------------------------------------------------------------------------------
    API_AUDIO_CUSTOMER_ADEC_INDEX g_audio_customer_AU_AV_Sync_Info_adecIndex;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_bEnable;
    int     g_audio_customer_AU_AV_Sync_Info_Monitor_Interval;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_PCMlevel;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_PCMlevel_in_ms;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_Upper_es_size;
    MS_BOOL g_audio_customer_AU_AV_Sync_Info_Upper_ptsExist;
    MS_U64  g_audio_customer_AU_AV_Sync_Info_Upper_pts;
    MS_U64  g_audio_customer_AU_AV_Sync_Info_R2_pts;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_DMX_stc;
    MS_U32  g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt;
    MS_BOOL g_audio_customer_AU_AV_Sync_Info_inputAesFinished_ret;
    int     g_audio_customer_AU_AV_Sync_Info_pts_offset;
    API_AUDIO_CUSTOMER_AES_INFO g_audio_customer_AU_AV_Sync_Info_aes_info;

} St_Audio_Customer_Shm_data;

static St_Audio_Customer_Shm_data *pstAudioCustomerShmData = NULL;

//---Audio init finish---
MS_BOOL g_api_audio_InitializeModule_R2_bActive = FALSE;

//---Call back functions---
typedef struct
{
    pfnAudioCustomerAdecoderClipDone pFunc_ClipDec;
    pfnAudioCustomerAENCDataHandling pFunc_AencMP3;
    pfnAudioCustomerAENCDataHandling pFunc_AencAAC;
    pfnAudioCustomerPCMSending       pFunc_PCMCaptureDone;
    pfnAudioCustomerMP3EncodeDone    pFunc_MP3Encode;
    pfnAudioCustomerAdecDecodeDone   pFunc_AdecDecDone;
    pfnAudioCustomerAdecEndOfStream  pFunc_Adec0_EndOfStream;
    pfnAudioCustomerAdecEndOfStream  pFunc_Adec1_EndOfStream;
    pfnAudioCustomerAdecUnderrun     pFunc_Adec0_Underrun;
    pfnAudioCustomerAdecUnderrun     pFunc_Adec1_Underrun;
    pfnAudioCustomerHDMIMonitorEvent pFunc_HDMIMonitorEvent;
} St_Audio_Callback_Func;

St_Audio_Callback_Func madCallBack;

//---buffer info---
typedef struct
{
    MS_U32 u32BufStartAddr_P;
    MS_U32 u32BufEndAddr_P;
    MS_U32 u32BufWptr_P;
    MS_U32 u32BufRptr_P;
    MS_U32 u32BufStartAddr_V;
    MS_U32 u32BufEndAddr_V;
    MS_U32 u32BufWptr_V;
    MS_U32 u32BufRptr_V;
    MS_U32 u32BufSize;
} St_Audio_Buf_Info;

/* Main sound */
St_Audio_Buf_Info ES1BufInfo;
St_Audio_Buf_Info ES3BufInfo;
St_Audio_Buf_Info ExternalBufInfo;

/* Ad sound */
St_Audio_Buf_Info AD_ES2BufInfo;
St_Audio_Buf_Info AD_ExternalBufInfo;

//---Clip play info---
typedef struct
{
    void           *address;
    MS_U32         u32Size;
    MS_BOOL        bIsStart;
    MS_BOOL        bIsPause;
    MS_U8          u8Sink;
    AUDIO_DEC_ID   decID;
    MS_U32         u32RepeatNum;
} St_Audio_Clip_Decoder_Info;

St_Audio_Clip_Decoder_Info clipDecoderInfo;
St_Audio_Buf_Info *pClipDecESBufInfo = NULL;
St_Audio_Buf_Info *pClipDecExtBufInfo = NULL;

//---get pcm (uni-play)---
typedef struct
{
    MS_U32  U32DecodeFrame;
    MS_U32  U32WrtAddr;
    MS_U32  U32WrtBytes;
} API_AUDIO_MM_PCM_Info;

typedef struct
{
    MS_U32 u32BufStartAddr;
    MS_U32 u32BufEndAddr;
    MS_U32 u32BufWrPtr;
    MS_U32 u32BufTotalSize;
    MS_U32 u32BufOffset;
} API_AUDIO_MM_PCM_BufControl;

typedef struct
{
    API_AUDIO_MM_PCM_Info       PcmInfo;
    API_AUDIO_MM_PCM_BufControl PcmBuf;
    MS_U32                      u32LastDecodeFrame;
} API_AUDIO_MM_PCM_HANDLE;

API_AUDIO_MM_PCM_HANDLE stADEC_PCM_HANDLE;
API_AUDIO_MM_PCM_HANDLE* pAdecPcmHandle = &stADEC_PCM_HANDLE;

//---audio demo (MM new mode)---
typedef struct
{
    API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex;
    void    *extBufaddr_V;
    MS_U32  u32Size;
    MS_BOOL bIsStart;
    MS_BOOL bIsPause;
    MS_U32  u32RepeatNum;
} St_AU_Demo_MM_New_Mode_Decoder_Info;

/* Main sound */
St_AU_Demo_MM_New_Mode_Decoder_Info AU_Demo_MM_New_Mode_DecInfo;
St_Audio_Buf_Info *pAU_Demo_MM_New_Mode_DecESBufInfo = NULL;
St_Audio_Buf_Info *pAU_Demo_MM_New_Mode_DecExtBufInfo = NULL;

/* Ad sound */
St_AU_Demo_MM_New_Mode_Decoder_Info AU_Demo_MM_New_Mode_AD_DecInfo;
St_Audio_Buf_Info *pAU_Demo_MM_New_Mode_AD_DecESBufInfo = NULL;
St_Audio_Buf_Info *pAU_Demo_MM_New_Mode_AD_DecExtBufInfo = NULL;

//---audio chip type---
typedef enum
{
    API_AUDIO_CUSTOMER_CHIP_TYPE_INVALID = -1,
    API_AUDIO_CUSTOMER_CHIP_TYPE_2R1D,
    API_AUDIO_CUSTOMER_CHIP_TYPE_1R1D,
    API_AUDIO_CUSTOMER_CHIP_TYPE_2D1R,
    API_AUDIO_CUSTOMER_CHIP_TYPE_2D,
    API_AUDIO_CUSTOMER_CHIP_TYPE_1D,
} API_AUDIO_CUSTOMER_CHIP_TYPE;

typedef enum
{
    API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_INVALID  = -1,
    API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC      = 0x0, //decoder
    API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_MCH      = 0x1, //multi-channel
    API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX      = 0x2, //downmix
}API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT;

//---Customized internal patch---
typedef enum
{
    AU_CUS_INTERNAL_PATCH_PARAM_TYPE_INVALID = -1,

    //--------------------------------------------------------------------------------------
    // (AU_CUS_"INTERNAL_PATCH"_PARAM_XXXXXXXX), PARAM: Set
    //--------------------------------------------------------------------------------------
    //---ADEC set gain, mute---
    AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN,
    AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE,

    //---MS12 HDMI TX PCM ouput Auto Delay (for sync with NPCM)---
    AU_CUS_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUDIO_DELAY,

    //---General Buffer Dump---
    AU_CUS_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP_ENABLE,

    //---SNDR2_MS12_PCMR_METADATA_SELECT---
    AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT,

    //---MAX---
    AU_CUS_INTERNAL_PATCH_PARAM_MAX = AU_CUS_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP_ENABLE,
} AU_CUS_INTERNAL_PATCH_PARAM_TYPE;

typedef enum
{
    AU_CUS_INTERNAL_PATCH_INFO_TYPE_INVALID = -1,

    //--------------------------------------------------------------------------------------
    // (AU_CUS_"INTERNAL_PATCH"_INFO_XXXXXXXX), INFO: Get
    //--------------------------------------------------------------------------------------
    //---RESERVE---
    AU_CUS_INTERNAL_PATCH_INFO_RESERVE0,

    //---MAX---
    AU_CUS_INTERNAL_PATCH_INFO_MAX = AU_CUS_INTERNAL_PATCH_INFO_RESERVE0,
} AU_CUS_INTERNAL_PATCH_INFO_TYPE;

//---Debug cmd---
typedef enum
{
    AU_DebugMenu_IDX,
    API_AUDIO_CUSTOMER_MAX_COMMNAD_IDX, //maximum commnad index
}EN_COMMNAD_INDEX;

typedef struct
{
    char              cCommmandName[64];
    EN_COMMNAD_INDEX  u32CommmandIndex;
} API_AUDIO_CUSTOMER_COMMAND_ST;

const API_AUDIO_CUSTOMER_COMMAND_ST API_AUDIO_CUSTOMER_COMMNAD_INFO[] =
{
    {{"AU_DebugMenu"} , AU_DebugMenu_IDX},
};

/* ATV parameter */
AUDIOSTANDARD_TYPE SIF_AudioStandard = E_AUDIOSTANDARD_NOTSTANDARD;
AUDIOSTATUS SIF_AudioStatus = E_STATE_AUDIO_NO_CARRIER;
AUDIOMODE_TYPE SIF_AudioMode = E_AUDIOMODE_INVALID;

/* Encode parameter */
API_AUDIO_CUSTOMER_AENC_INFO AENC_INFO;
static MS_BOOL firstGetEncodeTimeFlag = FALSE;
static MS_U32 encStartTime = 0;

/* MP3 Encode parameter */
MS_U8 *pMP3EncBuffer = NULL;
static MS_U32  retryCounterMP3Encode = 0;

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
/* AAC Encode parameter */
MS_U8 *pAACEncPCMBuffer = NULL;
unsigned char aacEncodedBuffer[AAC_ENCODED_LENTH];
static MS_U32 retryCounterAACEncode = 0;
AUDIO_DEVICE_TYPE AACEncPCMCaptureDevice = E_DEVICE0;
void  *aacEncodeHandler = NULL;
#endif

/* PCM Capture parameter */
MS_U8 *pPCMCaptureBuffer = NULL;
MS_U32 retryCounterPCMCapture = 0;

//Mute during limit time (Output)
static MS_U32 MuteLimitedTimeOfSoundOut[API_AUDIO_CUSTOMER_OUTPUT_MAX] = {0,0,0,0,0,0,0,0,0};

//Mute during limit time of FM0 (Input)
static MS_U32 MuteLimitedTimeOfFWM0In[API_AUDIO_CUSTOMER_FWM_INPUT_MAX] = {0,0,0};

//for apiAUDIO.c / apiAUDIO_V2.c nDBG MSG.
MS_U8 g_api_audio_V2_bEnableNonThreadPrintMsg = 0;
MS_U8 g_api_audio_V2_bEnableThreadPrintMsg    = 0;
MS_U8 g_api_audio_V2_bEnableReturnPrintMsg    = 0;

//Audio Chip type
static API_AUDIO_CUSTOMER_CHIP_TYPE AUDIO_CHIP_TYPE = API_AUDIO_CUSTOMER_CHIP_TYPE_INVALID;

//REG_BANK
static MS_U32 REG_BANK_ADEC1_PLAY               = 0;
static MS_U32 REG_BANK_ADEC1_CODEC              = 0;
static MS_U32 REG_BANK_ADEC2_PLAY               = 0;
static MS_U32 REG_BANK_ADEC2_CODEC              = 0;
static MS_U32 REG_BANK_R2_UART                  = 0;
static MS_U32 REG_BANK_R2_DEC_UART_ENABLE       = 0;
static MS_U32 REG_BANK_R2_SND_UART_ENABLE       = 0;
static MS_U32 REG_BANK_R2_WFI                   = 0;
static MS_U32 REG_BANK_R2_WFI_ENABLE            = 0;
static MS_U32 REG_BANK_R2_LOG_DBG               = 0;
static MS_U32 REG_BANK_R2_SYSTEM_DBG            = 0;
static MS_U32 REG_BANK_ADEC_DSP_DBG             = 0;
static MS_U32 REG_BANK_ADEC_DSP_RESULT1         = 0;
static MS_U32 REG_BANK_ADEC_DSP_RESULT2         = 0;
static MS_U32 REG_BANK_ASND_DSP_DBG             = 0;
static MS_U32 REG_BANK_ASND_DSP_RESULT1         = 0;
static MS_U32 REG_BANK_ASND_DSP_RESULT2         = 0;
static MS_U32 REG_BANK_DEC_R2_VERSION           = 0;
static MS_U32 REG_BANK_SND_R2_VERSION           = 0;
static MS_U32 REG_BANK_SND_R2_SRS               = 0;
static MS_U32 REG_BANK_SNDOUT_INPUT_PATH_SEL1   = 0;
static MS_U32 REG_BANK_SNDOUT_INPUT_PATH_SEL2   = 0;
static MS_U32 REG_BANK_SNDOUT_INPUT_PATH_SEL3   = 0;
static MS_U32 REG_BANK_ADEC_DSP_IDMA            = 0;
static MS_U32 REG_BANK_ASND_DSP_IDMA            = 0;

//AU Demo MM New mode Get PCM
char AU_Demo_MM_New_Mode_Get_PCM_Buffer[AU_DEMO_MM_NEW_MODE_GET_PCM_BUFFER_SIZE];
char *pAU_Demo_MM_New_Mode_Get_PCM_Buffer = AU_Demo_MM_New_Mode_Get_PCM_Buffer;

//MM dump ES
MS_U8 g_api_audio_V2_bEnableMMESDump = 0;

//AU Demo MM file read in buffer
MS_U8 *AU_Demo_MM_File_read_in_buffer  = NULL;
MS_U8 *AU_Demo_MM_File_read_in_buffer2 = NULL;
MS_U8 *AU_Demo_MM_File_read_in_buffer3 = NULL;

//-------------------------------------------------------------------------------------------------------------------------------------
// [Distinction Area] [kernel space / user space] [variable / struct / enum] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
//file for nDBG log
struct file *pAU_nDBG_Log_To_File      = NULL;
struct file *pAU_nDBG_MenuLog_To_File  = NULL;

//Shm Data
static St_Audio_Customer_Shm_data stAudioCustomerShmData;

//mutex
struct mutex AU_Customer_ReadAbsReg_mutex_lock;
struct mutex AU_Customer_WriteAbsReg_mutex_lock;
struct mutex AU_Customer_ReadDM_mutex_lock;
struct mutex AU_Customer_WriteDM_mutex_lock;
struct mutex AU_Customer_ReadPM_mutex_lock;
struct mutex AU_Customer_WritePM_mutex_lock;
struct mutex AU_Customer_ReadAbsXbox_mutex_lock;
struct mutex AU_Customer_WriteAbsXbox_mutex_lock;
struct mutex AU_Customer_MP3Encode_mutex_lock;
#if (UTPA_SUPPORT_AAC_ENCODE == 1)
struct mutex AU_Customer_AACEncode_mutex_lock;
#endif
struct mutex AU_Customer_PCMCapture_mutex_lock;
struct mutex AU_Customer_MM2_initAesInfo_mutex_lock;
struct mutex AU_Customer_MM2_checkAesInfo_mutex_lock;
struct mutex AU_Customer_MM2_inputAesFinished_mutex_lock;
struct mutex AU_Customer_SPDIF_TX_SetOutputType_mutex_lock;

//MP3 Encode (Dump file)
struct file *pAU_MP3EncDumpFile = NULL;

//ADEC PCM dump file
struct file *pAU_AdecPcmDumpFile = NULL;

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
typedef signed char          tEmzInt8;
typedef unsigned char        tEmzUint8;
typedef short int            tEmzInt16;
typedef unsigned short int   tEmzUint16;
typedef int                  tEmzInt32;
typedef unsigned int         tEmzUint32;
typedef float                tEmzFlt32;
typedef double               tEmzFlt64;
typedef unsigned char        tEmzBool;
typedef signed int           tEmzError;

typedef enum OpFormat
{
    FORMAT_RAW  = 0,
    FORMAT_ADIF = 1,
    FORMAT_ADTS = 2
}tOutputFormat;

typedef enum channelMode
{
    SINGLE_CHANNEL = 0,
    DUAL_MONO      = 1,
    JOINT_STEREO   = 2
}tChannelMode;

typedef struct Mp4AacEncParams tMp4AacEncParams;
struct Mp4AacEncParams
{
    tEmzUint32    NumberOfChannels;
    tEmzUint32    SamplingFrequency;
    tEmzUint32    TurnOnPns;
    tEmzUint32    TurnOnTns;
    tEmzUint32    VersionInfo;
    tOutputFormat OutputFormat;
    tEmzUint32    OutputBitRate;
    tChannelMode  ChannelMode;
    tEmzUint32    Flag_VBR;
    tEmzUint16    BandWidthSel;
};

//AAC Encode (Dump file)
struct file *pAU_AACEncDumpFile = NULL;
struct file *pAU_AACEncPCMCaptureDumpFile = NULL;
#endif

//PCM Capture dump file
struct file *pAU_PcmCaptureSourceDumpFile = NULL;

//DDR Dump file
struct file *pAU_DDR_BIN_File = NULL;

//AU Demo MM New Mode Get PCM
struct file *pAU_Demo_MM_New_Mode_AdecPcmDump = NULL;

//MM mode ES real time dump file
struct file *pAU_MMESDumpFile = NULL;

//General buffer dump file
struct file *pAU_GeneralBufferDumpFile = NULL;

//General buffer dump file
struct file *pAU_GeneralBufferDumpFile2 = NULL;

//General buffer dump file
struct file *pAU_GeneralBufferDumpFile3 = NULL;

//General buffer dump file
struct file *pAU_GeneralBufferDumpFile4 = NULL;

//R2 Log buffer dump file
struct file *pAU_R2LogBufferDumpFile = NULL;

/* kernel debug proc */
/* Define a Proc structure for debug */
struct AU_CUS_kernel_debug_proc_st
{
    struct proc_dir_entry *proc_entry;
    struct file_operations proc_fops;
    char *proc_name;
    umode_t proc_mode;
};
static struct proc_dir_entry *g_proc_root = NULL;

#else //User Space
//file for nDBG log
FILE *pAU_nDBG_Log_To_File      = NULL;
FILE *pAU_nDBG_MenuLog_To_File  = NULL;

//mutex
static MS_S32 AU_Customer_ReadAbsReg_mutex_lock             = -1;
static MS_S32 AU_Customer_WriteAbsReg_mutex_lock            = -1;
static MS_S32 AU_Customer_ReadDM_mutex_lock                 = -1;
static MS_S32 AU_Customer_WriteDM_mutex_lock                = -1;
static MS_S32 AU_Customer_ReadPM_mutex_lock                 = -1;
static MS_S32 AU_Customer_WritePM_mutex_lock                = -1;
static MS_S32 AU_Customer_ReadAbsXbox_mutex_lock            = -1;
static MS_S32 AU_Customer_WriteAbsXbox_mutex_lock           = -1;
static MS_S32 AU_Customer_MP3Encode_mutex_lock              = -1;
#if (UTPA_SUPPORT_AAC_ENCODE == 1)
static MS_S32 AU_Customer_AACEncode_mutex_lock              = -1;
#endif
static MS_S32 AU_Customer_PCMCapture_mutex_lock             = -1;
static MS_S32 AU_Customer_MM2_initAesInfo_mutex_lock        = -1;
static MS_S32 AU_Customer_MM2_checkAesInfo_mutex_lock       = -1;
static MS_S32 AU_Customer_MM2_inputAesFinished_mutex_lock   = -1;
static MS_S32 AU_Customer_SPDIF_TX_SetOutputType_mutex_lock = -1;

//MP3 Encode (Dump file)
FILE *pAU_MP3EncDumpFile = NULL;

//ADEC PCM dump file
FILE *pAU_AdecPcmDumpFile = NULL;

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
//AAC Encode (Dump file)
FILE *pAU_AACEncDumpFile = NULL;
FILE *pAU_AACEncPCMCaptureDumpFile = NULL;
#endif

//PCM Capture dump file
FILE *pAU_PcmCaptureSourceDumpFile = NULL;

//DDR Dump file
FILE *pAU_DDR_BIN_File = NULL;

//AU Demo MM New Mode Get PCM
FILE *pAU_Demo_MM_New_Mode_AdecPcmDump = NULL;

//MM mode ES real time dump file
FILE *pAU_MMESDumpFile = NULL;

//General buffer dump file
FILE *pAU_GeneralBufferDumpFile = NULL;

//General buffer dump file
FILE *pAU_GeneralBufferDumpFile2 = NULL;

//General buffer dump file
FILE *pAU_GeneralBufferDumpFile3 = NULL;

//General buffer dump file
FILE *pAU_GeneralBufferDumpFile4 = NULL;

//R2 Log buffer dump file
FILE *pAU_R2LogBufferDumpFile = NULL;

//debug menu operate by non_scanf
unsigned int  non_scanf_params[NON_SCANF_DEBUG_CMD_PARAMS_MAX];      // store the decimal command number
unsigned int  non_scanf_paramsHex[NON_SCANF_DEBUG_CMD_PARAMS_MAX];   // store the heximal command number
char          non_scanf_paramsStr[AU_DEBUG_INPUT_STR_LENGTH+1];      // store the string
unsigned char non_scanf_paramIdx = 0;
unsigned char non_scanf_paramsCount = 0;

//AU debug get string input
char au_debug_input_string[AU_DEBUG_INPUT_STR_LENGTH+1] = {'\0'};
FILE *pAU_debug_input_file  = NULL;
FILE *pAU_debug_input_file2 = NULL;
FILE *pAU_debug_input_file3 = NULL;

#if(DTS_AUDIO_PARSER_ENABLE)
typedef unsigned long long  uint64_t;
typedef unsigned char       uint8_t;
typedef signed char         int8_t;
typedef unsigned short      uint16_t;
typedef short               int16_t;
typedef unsigned int        uint32_t;
typedef int                 int32_t;
typedef fpos_t              fpos_tt;
typedef uint64_t            dtsUint64;

/* basic abstract data types */
typedef int32_t     bool_t;
typedef uint8_t     dtsUint8;
typedef uint8_t     Uint8;
typedef int8_t      Int8;
typedef int8_t      dtsInt8;
typedef int16_t     dtsInt16;
typedef int16_t     Int16;
typedef uint16_t    Uint16;
typedef uint16_t    dtsUint16;
typedef uint32_t    Uint32;
typedef uint32_t    dtsUint32;
typedef uint32_t    dtsUint32b;
typedef uint32_t    uintptr_t;
typedef int         Int32;
typedef int         dtsInt32b;
typedef int         dtsInt32;

typedef enum
{
    dtsTrue = 1,
    dtsFalse = 0
} dtsBoolean;

typedef struct dtsHDHdr
{
    dtsBoolean  valid;
    dtsUint32   hdrVersion;
    dtsUint64   timeCode;
    dtsUint8    TCFrameRate;
    struct bitWStreamMetaData
    {
        dtsBoolean  vbr;
        dtsBoolean  pbrs;
        dtsBoolean  navi;
        dtsBoolean  coreSStrm;
        dtsBoolean  extSStrm;
    } bitWStreamMetaData;
    dtsUint8    NumAudioPres;
} dtsHDHdr;

typedef struct dtsCoreSSMD
{
    dtsBoolean  valid;
    dtsUint32   maxSampleRateHz;
    dtsUint16   bitRateKbps;
    dtsUint16   channelMask;
    dtsUint32   framePayloadBytes;
} dtsCoreSSMD;

typedef struct dtsExtSSMD
{
    dtsBoolean  valid;
    dtsUint32   avgBitRateKbps;
    dtsUint32   peakBitRateKbps;
    dtsUint16   pbrSmoothBuffSizeKb;
    dtsUint32   framePayloadBytes;
} dtsExtSSMD;

typedef struct dtsAuPrHdr
{
    dtsBoolean  valid;

    struct bitWAupresMetaData
    {
        dtsBoolean  BCCCComp;
        dtsBoolean  BCCCCompInExtSS;
        dtsBoolean  LLCComp;
        dtsBoolean  LBRCComp;
    } bitWAupresMetaData;

    dtsUint32   maxSampleRate;
    dtsUint32   numFrames;
    dtsUint16   samplesPerFrameMaxFs;
    dtsUint64   numSamplesOrigAudioMaxFs;
    dtsUint16   channelMask;
    dtsUint16   codecDelayMaxFs;
    dtsUint32   BCCoreMaxSampleRate;
    dtsUint16   BCCoreBitRate;
    dtsUint16   BCCoreChannelMask;
    dtsUint8    LSBTrimPercent;
} dtsAuPrHdr;

typedef struct dtsSTRMData
{
    dtsBoolean  valid;
    dtsUint64   streamDataByteSize;
    dtsUint64   bytesRead;
    fpos_tt     currentFilePosition;
    fpos_tt     positionStartOfData;
} dtsSTRMData;

typedef struct dtsNaviTbl
{
    dtsBoolean  valid;
    dtsUint32   numEntries;
    dtsUint16   intervalFrames;
    dtsUint8    entrySize;
    fpos_tt     tblEntryStartPos;
} dtsNaviTbl;

typedef struct dtsBuildVer
{
    dtsBoolean  valid;
    dtsUint8    dataSizeBytes;
    dtsUint8    data[DTS_HD_MAX_BUILDVER_BYTES];
} dtsBuildVer;

typedef struct dtsTimecode
{
    dtsBoolean  valid;
    dtsUint32   clock;
    dtsUint8    frameRate;
    dtsUint64   startSampSinceMidnight;
    dtsUint32   startResidual;
    dtsUint64   refSampSinceMidnight;
    dtsUint32   refResidual;
    dtsUint64   endSampSinceMidnight;
} dtsTimecode;

typedef struct
{
    dtsHDHdr    hdr;
    dtsCoreSSMD coreSSMD;
    dtsExtSSMD  extSSMD;
    dtsAuPrHdr  auPrHdr[DTS_HD_MAX_ASSETS];
    dtsSTRMData data;
    dtsNaviTbl  navi;
    dtsBuildVer bldVer;
    dtsTimecode timecode;
    dtsBoolean  eof;
} dtsHDFileInfo;

typedef enum HDParserState
{
    HD_PS_START = 0,
    HD_PS_HDR_FOUND,
    HD_PS_STREAM_FOUND,
    HD_PS_EOF,
    HD_PS_ERROR
} HDParserState;

typedef struct
{
    dtsUint64 size;
    dtsUint64 pos;
} dtsFilePCMInfo;

typedef struct dtsWavFileFormatInfo
{
    dtsUint16 wFormatTag;
    dtsUint16 wChannels;
    dtsUint32 dwSamplesPerSec;
    dtsUint32 dwAvgBytesPerSec;
    dtsUint16 wBlockAlign;
    dtsUint16 wBitsPerSample;
} dtsWavFileFormatInfo;

typedef struct dtsWavFileDataInfo
{
    dtsUint64 lengthInBytes;
    dtsUint64 bytesRead;
} dtsWavFileDataInfo;

typedef struct dtsWavFileWriteInfo
{
    fpos_tt riffChunkLengthLocation;
    fpos_tt dataChunkLengthLocation;
    fpos_tt nextWritePosition;
} dtsWavFileWriteInfo;

typedef struct dtsWavFileReadInfo
{
    fpos_tt nextReadPosition;
} dtsWavFileReadInfo;

typedef struct dtsWavFileInfo
{
    dtsWavFileFormatInfo format;
    dtsWavFileDataInfo data;
    dtsBoolean isWritable;
    dtsBoolean isInit;
    dtsBoolean eof;
    dtsWavFileWriteInfo writeInfo;
    dtsWavFileReadInfo readInfo;
} dtsWavFileInfo;

typedef struct dtsWavFileHeader
{
    dtsUint32 length;
    dtsUint8  id[DTS_WAV_FILE_ID_LENGTH];
    dtsUint8  content[DTS_WAV_FILE_CONTENT_LENGTH];
} dtsWavFileHeader;

typedef struct
{
    int type;

    union
    {
        dtsWavFileInfo wav;
        dtsHDFileInfo  dtshd;
        dtsFilePCMInfo pcm;
    } info;
} DTS_FILEINFO;

DTS_FILEINFO dtsfile_info;
#endif //#if(DTS_AUDIO_PARSER_ENABLE)

#if(WMA_AUDIO_PARSER_ENABLE)
const GUID CLSID_CAsfHeaderObjectV0                     = {0x75b22630, 0x668e, 0x11cf, {0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c} };
const GUID CLSID_CAsfPropertiesObjectV2                 = {0x8cabdca1, 0xa947, 0x11cf, {0x8e, 0xe4, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };
const GUID CLSID_CAsfStreamPropertiesObjectV1           = {0xb7dc0791, 0xa9b7, 0x11cf, {0x8e, 0xe6, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };
const GUID CLSID_CAsfContentDescriptionObjectV0         = {0x75b22633, 0x668e, 0x11cf, {0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c} };
const GUID CLSID_CAsfDataObjectV0                       = {0x75b22636, 0x668e, 0x11cf, {0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c} };
const GUID CLSID_AsfXNullErrorMaskingStrategy           = {0x20fb5700, 0x5b55, 0x11cf, {0xa8, 0xfd, 0x00, 0x80, 0x5f, 0x5c, 0x44, 0x2b} };
const GUID CLSID_AsfXAcmAudioErrorMaskingStrategy       = {0xbfc3cd50, 0x618f, 0x11cf, {0x8b, 0xb2, 0x00, 0xaa, 0x00, 0xb4, 0xe2, 0x20} };
const GUID CLSID_AsfXSignatureAudioErrorMaskingStrategy = {0x49f1a440, 0x4ece, 0x11d0, {0xa3, 0xac, 0x0 , 0xa0, 0xc9, 0x3 , 0x48, 0xf6} };
const GUID CLSID_AsfXStreamTypeAcmAudio                 = {0xf8699e40, 0x5b4d, 0x11cf, {0xa8, 0xfd, 0x00, 0x80, 0x5f, 0x5c, 0x44, 0x2b} };
const GUID CLSID_CAsfContentEncryptionObject            = {0x2211b3fb, 0xbd23, 0x11d2, {0xb4, 0xb7, 0x0 , 0xa0, 0xc9, 0x55, 0xfc, 0x6e} };
const GUID CLSID_CAsfExtendedContentDescObject          = {0xd2d0a440, 0xe307, 0x11d2, {0x97, 0xf0, 0x0 , 0xa0, 0xc9, 0x5e, 0xa8, 0x50} };
const GUID CLSID_CAsfMarkerObjectV0                     = {0xf487cd01, 0xa951, 0x11cf, {0x8e, 0xe6, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };
const GUID CLSID_CAsfLicenseStoreObject                 = {0x8fa7857b, 0xddc0, 0x11d3, {0xb6, 0xbd, 0x0 , 0xc0, 0x4f, 0x61, 0xd , 0x62} };
const GUID CLSID_CAsfStreamPropertiesObjectV2           = {0x818d0d47, 0x43  , 0x4451, {0x92, 0x37, 0xda, 0xef, 0xbc, 0x48, 0x4f, 0x50} };
const GUID CLSID_CAsfExtendedStreamPropertiesObject     = {0x14E6A5CB, 0xC672, 0x4332, {0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A} };
const GUID CLSID_AsfXStreamTypeDRMAuxData               = {0xd5c82c81, 0x8264, 0x4abd, {0xa7, 0x14, 0xcd, 0x4f, 0x85, 0x54, 0xc7, 0x2e} };
const GUID CLSID_CAsfClockObjectV0                      = {0x5fbf03b5, 0xa92e, 0x11cf, {0x8e, 0xe3, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };
const GUID CLSID_AsfXMetaDataObject                     = {0xC5F8CBEA, 0x5BAF, 0x4877, {0x84, 0x67, 0xAA, 0x8C, 0x44, 0xFA, 0x4C, 0xCA} };
const GUID CLSID_CAsfPacketClock1                       = {0xabd3d211, 0xa9ba, 0x11cf, {0x8e, 0xe6, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };
const GUID CLSID_CAsfReserved1                          = {0xabd3d211, 0xa9ba, 0x11cf, {0x8e, 0xe6, 0x0 , 0xc0, 0xc , 0x20, 0x53, 0x65} };

typedef struct tagWMAExtendedContentDescription
{
    unsigned short cDescriptors;   // number of descriptors
    ECD_DESCRIPTOR *pDescriptors;  // pointer to all the descriptors
} tWMAExtendedContentDesc;

typedef struct tagWMA_MetaDataDescRecords
{
    unsigned short  wLangIdIndex;   // Specifies the index of the language ID in the Language List Object
    unsigned short  wStreamNumber;  // Specifies whether the entry applies to a specific media stream or
    // whether it applies to the whole file. A value of 0 in this field
    // indicates that it applies to the whole file; otherwise, the entry
    // applies only to the indicated stream number.
    unsigned short  wNameLenth;     // Specifies the number of valid bytes stored in the Name field.
    unsigned short  wDataType;      // Specifies the type of information being stored. The following values are recognized:
    unsigned int    dwDataLength;   // Specifies the length in bytes of the Data field.
    unsigned short  *pwName;        // Specifies the name that uniquely identifies the attribute being described. Names are case-sensitive.
    unsigned char   *pData;         // Specifies the actual metadata being stored. The Data field should be interpreted according to the value
    // stored in the Data Type field. If the Data Type is one of the extended values, this field may not contain
    // any data if the file is being streamed over the wire.
} WMA_MetaDataDescRecords;

typedef struct tagWMA_MetaDataEntry
{
    unsigned short          m_wDescRecordsCount;
    WMA_MetaDataDescRecords *pDescRec;
} WMA_MetaDataEntry;

typedef struct tagWMAFileHdrStateInternal
{
    unsigned int    currPacketOffset;     /* not just for packets */
    unsigned int    nextPacketOffset;

    /* ASF header */
    unsigned int    cbHeader;
    unsigned int    cbPacketSize;
    unsigned int    cbAudioSize;
    unsigned int    cPackets;
    unsigned int    msDuration;
    unsigned int    msPreroll;
    unsigned int    cbFirstPacketOffset;
    unsigned int    cbLastPacketOffset;
    unsigned int    dwFilePropertiesFlags;

    /* audio prop */
    unsigned short  nVersion;
    unsigned short  wFormatTag;
    unsigned int    nSamplesPerSec;
    unsigned int    nAvgBytesPerSec;
    unsigned int    payload_size;
    unsigned int    nBlockAlign;
    unsigned short  nChannels;
    unsigned int    nSamplesPerBlock;
    unsigned short  nEncodeOpt;
    unsigned short  nAdvancedEncodeOpt;
    unsigned int    nAdvancedEncodeOpt2;

    // Added in V9
    unsigned short  wPCMFormatTag;
    unsigned short  wBitsPerSample;      // container size
    unsigned short  wValidBitsPerSample; // actual valid data depth in the decoded stream
    unsigned int    dwChannelMask;
    GUID            SubFormat;
    unsigned short  wOriginalBitDepth;   // actual valid data depth in the original source (informational)

    /* DRM */
    unsigned char   pbSecretData[32];
    unsigned int    cbSecretData;
    unsigned char   pbType[16];
    unsigned char   pbKeyID[32];

    /* Content Description */
    tWMAFileContDesc        *m_pDesc;

    /* Extended Content Description */
    tWMAExtendedContentDesc *m_pECDesc;

    /* Marker */
    unsigned int    m_dwMarkerNum;
    MarkerEntry     *m_pMarker;

    /* License Store */
    unsigned int    m_dwLicenseLen;
    unsigned char   *m_pLicData;

    // Members added by Amit
    unsigned short      wAudioStreamId;
    WMA_MetaDataEntry   *ptMetaDataEntry;

    // Members added by Naveen for MBR support
    unsigned short      wTargetAudioStreamNumber;
    unsigned short      cAudioStreams;

    int                 bMstarHeader;
    unsigned long long  u64CurrHeaderOffset;
    unsigned long long  u64NextHeaderOffset;
    unsigned long long  u64CurPayloadOffset;
    unsigned long long  u64NextPayloadOffset;
} tWMAFileHdrStateInternal;

typedef struct
{
    unsigned int    u32Size;
    unsigned int    u32Level;
    unsigned int    consumed_bytes;
    unsigned char   *pStartAddr;
    unsigned char   *pRptr;
    unsigned char   *pWptr;
    unsigned char   *pEndAddr;
} Buffer_Control_t;

/* parser state */
typedef enum
{
    csWMA_NotValid = 0,
    csWMA_HeaderStart,
    csWMA_HeaderError,
    csWMA_NewAsfPacket,

    /* packet parsing states */
    csWMA_DecodePayloadStart,
    csWMA_DecodePayload,
    csWMA_DecodeAudioData,
    csWMA_DecodePayloadEnd,
    csWMA_DecodeCompressedPayload,

    csWMA_End_
} tWMAParseState;

typedef struct tPACKET_PARSE_INFO_EX
{
    int             fParityPacket;
    unsigned int    cbParseOffset;

    int             fEccPresent;
    unsigned char   bECLen;

    unsigned char   bPacketLenType;
    unsigned int    cbPacketLenTypeOffset;

    unsigned char   bPadLenType;
    unsigned char   bSequenceLenType;

    int             fMultiPayloads;
    unsigned char   bOffsetBytes;
    unsigned char   bOffsetLenType;
    unsigned int    cbPacketLenOffset;
    unsigned int    cbExplicitPacketLength;
    unsigned int    cbSequenceOffset;
    unsigned int    dwSequenceNum;

    unsigned int    cbPadLenOffset;
    unsigned int    cbPadding;

    unsigned int    dwSCR;
    unsigned short  wDuration;

    unsigned char   bPayLenType;
    unsigned char   bPayBytes;
    unsigned int    cbPayLenTypeOffset;
    unsigned int    cPayloads;
}   PACKET_PARSE_INFO_EX;

typedef struct tPAYLOAD_MAP_ENTRY_EX
{
    unsigned short  cbPacketOffset;
    unsigned short  cbTotalSize;

    unsigned char   bStreamId;
    unsigned char   bObjectId;

    unsigned int    cbObjectOffset;
    unsigned int    cbObjectSize;
    unsigned int    msObjectPres;

    unsigned char   cbRepData;
    unsigned short  cbPayloadSize;

    //Added by Amit
    unsigned short  wBytesRead;
    unsigned short  wTotalDataBytes;
    unsigned char   bSubPayloadState;
    unsigned char   bIsCompressedPayload;
    unsigned int    dwDeltaTime;
}   PAYLOAD_MAP_ENTRY_EX;

typedef struct tagWMAFileStateInternal
{
    tWMAFileHdrStateInternal hdr_parse;

    /* parse_state */
    tWMAParseState parse_state;

    /* payload parsing */
    unsigned long long   cbPayloadOffset;
    unsigned long long   cbPayloadLeft;

    int          bBlockStart;
    unsigned int cbBlockLeft;

    /* packet parsing */
    PACKET_PARSE_INFO_EX ppex;
    PAYLOAD_MAP_ENTRY_EX payload;
    unsigned int   iPayload;
    unsigned short wPayStart;
} tWMAFileStateInternal;

tWMAFileStateInternal sWmaHandle;

typedef enum {MS_OK=0, MS_FAIL=1}       MS_RESULT;
typedef enum {BUF_WRITE=0, BUF_READ=1}  MS_BUF_ACCESS;

Buffer_Control_t sDecodeFifo_Info;

unsigned char WMAPRO_DecodeFifo[WMAPRO_DECODE_FIFO_SIZE];

FILE *g_wmaInput_fp = NULL;
int  bEOF = 0;
unsigned long long  u64FileOffset = 0;
unsigned int        MaxRequestSize = WMA_MAX_DATA_REQUESTED;
unsigned long long  u64offset_expect = 0;

typedef struct tAsfXAcmAudioErrorMaskingData
{
    unsigned char   span;
    unsigned short  virtualPacketLen;
    unsigned short  virtualChunkLen;
    unsigned short  silenceLen;
    unsigned char   silence[1];
}   AsfXAcmAudioErrorMaskingData;

typedef struct tAsfXSignatureAudioErrorMaskingData
{
    unsigned int    maxObjectSize;
    unsigned short  chunkLen;
    unsigned short  signatureLen;
    unsigned char   signature[1];
}   AsfXSignatureAudioErrorMaskingData;

typedef void * tHWMAFileState;
#endif //#if(WMA_AUDIO_PARSER_ENABLE)

#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Pre-Declaration Area] pre-declared [function] declare in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
/* Initialize, STR */

/* Connect & Disconnect */
MS_BOOL AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect);
MS_BOOL AU_CUS_ADEC_Disconnect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect);
MS_BOOL AU_CUS_ADC_Connect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum);
MS_BOOL AU_CUS_ADC_Disconnect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum);
MS_BOOL AU_CUS_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect);
MS_BOOL AU_CUS_CH_Sound_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect);
MS_BOOL AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect);
MS_BOOL AU_CUS_FW_MIXER_Disconnect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect);
MS_BOOL AU_CUS_SNDOUT_Connect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect);
MS_BOOL AU_CUS_SNDOUT_Disconnect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect);
API_AUDIO_CUSTOMER_CH_SOUND AU_CUS_Mapping_ADEC_to_FWM_INPUT(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect);
void    AU_CUS_SetSourceInfo(AUDIO_SOURCE_INFO_TYPE eSourceType);
void    AU_CUS_InputSwitch(AUDIO_INPUT_TYPE enSource, AUDIO_SWITCH_GROUP enGroup);

/* Start & Stop */
MS_BOOL AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE audioType);
MS_BOOL AU_CUS_StartDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex);
MS_BOOL AU_CUS_StopDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex);
MS_BOOL AU_CUS_PauseDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex);

/* SPDIF */
MS_BOOL AU_CUS_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_MODE eSPDIFMode);
void    AU_CUS_SPDIF_TX_Monitor(void);

/* HDMI */
MS_BOOL AU_CUS_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE eHDMIMode);
void    AU_CUS_HDMI_RX_Monitor(void);
void    AU_CUS_HDMI_TX_Monitor(void);
MS_BOOL AU_CUS_HDMI_RX_GetAudioMode(void);

/* ATV */
void AU_CUS_CheckATVSoundMode(void);
void AU_CUS_SIF_Monitor(void);

/* Decoder */
MS_BOOL AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff);

/* Common Decoder */
MS_S32 AU_CUS_COMMON_DECODER_Open(void * pData);
MS_S32 AU_CUS_COMMON_DECODER_Close(MS_S32 s32DeviceID);
MS_S32 AU_CUS_COMMON_DECODER_Start(MS_S32 s32DeviceID);
MS_S32 AU_CUS_COMMON_DECODER_Stop(MS_S32 s32DeviceID);
MS_S32 AU_CUS_COMMON_DECODER_Set(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData);
MS_S32 AU_CUS_COMMON_DECODER_Get(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData);
MS_U32 AU_CUS_COMMON_DECODER_Read(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size);
MS_U32 AU_CUS_COMMON_DECODER_Write(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size);
MS_S32 AU_CUS_COMMON_DECODER_Flush(MS_S32 s32DeviceID);

/* Common */
MS_BOOL AU_CUS_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_PARAM_TYPE paramType, void *pParam);
MS_BOOL AU_CUS_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_INFO_TYPE infoType, void *pInfo);

/* Customized patch */
MS_BOOL AU_CUS_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_PARAM_TYPE paramType, void *pParam);
MS_BOOL AU_CUS_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_INFO_TYPE infoType, void *pInfo);
void    AU_CUS_PATCH_SeDSP_MS12_Enc_wo_Main_Snd_disable(void);
void    AU_CUS_PATCH_SndR2_MS12_Enc_wo_Main_Snd_disable(void);

/* Customized Internal patch */
MS_BOOL AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, AU_CUS_INTERNAL_PATCH_PARAM_TYPE paramType, void *pParam);
MS_BOOL AU_CUS_INTERNAL_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, AU_CUS_INTERNAL_PATCH_INFO_TYPE infoType, void *pInfo);
MS_BOOL AU_CUS_ADEC_SetGain(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, int gain);
MS_BOOL AU_CUS_ADEC_SetMute(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff);

/* Clip Play for ES */

/* Clip Play for PCM */

/* Gain, Mute & Delay */
//---Gain---
MS_BOOL AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_U32 gain);
MS_BOOL AU_CUS_SetI2SOutGain(MS_U32 gain);
MS_BOOL AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_U32 gain);
MS_BOOL AU_CUS_SetSPDIFOutGain(MS_U32 gain);
//---Mute---
MS_BOOL AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_BOOL bOnOff);
MS_BOOL AU_CUS_SetI2SOutMute(MS_BOOL bOnOff);
MS_BOOL AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL bOnOff);
MS_BOOL AU_CUS_SetSPDIFOutMute(MS_BOOL bOnOff);
MS_BOOL AU_CUS_SetHDMIOutMute(MS_BOOL bOnOff);
MS_BOOL AU_CUS_MuteDuringLimitedTime_Input(MS_U32 per_50ms, API_AUDIO_CUSTOMER_FWM_INDEX eFWM, API_AUDIO_CUSTOMER_FWM_INPUT eCh);
MS_BOOL AU_CUS_MuteDuringLimitedTime_Output(MS_U32 per_50ms, API_AUDIO_CUSTOMER_OUTPUT_TYPE ePort);
void    AU_CUS_SetI2SOutMuteStatus(void);
void    AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex);
void    AU_CUS_SetSPDIFOutMuteStatus(void);
void    AU_CUS_SetHDMIOutMuteStatus(void);
void    AU_CUS_SetSoundOutMuteStatus(API_AUDIO_CUSTOMER_OUTPUT_TYPE port);
void    AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 per_50ms);
//---Delay---
MS_BOOL AU_CUS_SetAudioDelay(MS_U32 delay);
MS_BOOL AU_CUS_SetSpdifDelay(MS_U32 delay);
MS_BOOL AU_CUS_SetHdmiDelay(MS_U32 delay);

/* AENC */

/* PCM Capture */

/* PCM IO Control */

/* MM New Mode */
AUDIO_DEC_ID AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(AUDIO_DEC_ID DecID);

/* Mstar Sound Effect */

/* Advanced Sound Effect */

/* internal used functions */
void    AU_CUS_SHOW_ALL_VERSION(void);
void    AU_CUS_Delay1MS(int delay1MS);
MS_U8*  AU_CUS_MemoryAlloc(MS_U32 allocSize);
void    AU_CUS_MemoryFree(void *pMemoryBuffer);
void    AU_CUS_ShowAudioBlockDiagram(void);
void    AU_CUS_Dump_RegBank(int bank);
void    AU_CUS_Dump_Audio_Related_Bank(void);
void    AU_CUS_Show_R2_Debug_Option(void);
void    AU_CUS_Show_Bifrost_Test_File_Option(void);
void    AU_CUS_Show_Codec_Type_Option(void);
MS_BOOL AU_CUS_DebugMenu(void);
static MS_U16 AU_CUS_ReadAbsReg(MS_U32 regaddr);
static void   AU_CUS_WriteAbsReg(MS_U32 regaddr, MS_U16 data);
static void   AU_CUS_WriteAbsMaskReg(MS_U32 u32RegAddr, MS_U16 u16Mask, MS_U16 u16Val);
static MS_U16 AU_CUS_ReadDM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_BOOL bIsIDMA);
static void   AU_CUS_WriteDM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_U16 data, MS_BOOL bIsIDMA);
static MS_U16 AU_CUS_ReadPM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_BOOL bIsIDMA);
static void   AU_CUS_WritePM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_U32 data, MS_BOOL bIsIDMA);
static MS_U32 AU_CUS_ReadAbsXbox(MS_U32 xboxaddr);
static void   AU_CUS_WriteAbsXbox(MS_U32 xboxaddr, MS_U32 data);
static long long AU_CUS_long_div(long long a, int b);

#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel space
struct file * AU_CUS_FileOpen(const char * filename, const char *mode);
void AU_CUS_FileClose(struct file *fp);
void AU_CUS_FileWrite(const void *p, size_t size, size_t nmemb, struct file * fp);

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
tEmzInt32 Mpeg4AacEnc_Create(void **aHandle);
tEmzInt32 Mpeg4AacEnc_Reset(void *aHandle, tMp4AacEncParams *aEncPrms);
tEmzInt32 Mpeg4AacEnc_Encode(void *aHandle, tEmzInt16 aSrc[], tEmzInt32 aSrcLen, tEmzUint8 aDst[], tEmzInt32 *aDstLen);
tEmzInt32 Mpeg4AacEnc_Delete(void  *aHandle);
#endif

/* kernel debug proc */
/* proc child 1 */
static ssize_t AU_CUS_kernel_debug_proc_read_nDBG(struct file *file, char __user *buffer, size_t count, loff_t *pos);
static ssize_t AU_CUS_kernel_debug_proc_write_nDBG(struct file *file, const char __user *buffer, size_t count, loff_t *pos);

/* proc child 2 */
static ssize_t AU_CUS_kernel_debug_proc_read_ShowVersion(struct file *file, char __user *buffer, size_t count, loff_t *pos);

#else //User space
FILE * AU_CUS_FileOpen(const char * filename, const char *mode);
int  AU_CUS_FileClose(FILE * fp);
void AU_CUS_FileWrite(const void *p, size_t size, size_t nmemb, FILE *fp);

#if(DTS_AUDIO_PARSER_ENABLE)
typedef void (*AU_CUS_DTS_Parser_dtsDecodeChunkFunction)(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);

/* Decode functions for HD file chunks */
void AU_CUS_DTS_Parser_dtsDecodeDTSHDHR( FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeCORESSMD(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeEXTSSMD( FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeAUPRHDR( FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeSTRMDATA(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeNAVITBL( FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeBUILDVER(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);
void AU_CUS_DTS_Parser_dtsDecodeTIMECODE(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength);

struct
{
    const char *pChunkdId;
    AU_CUS_DTS_Parser_dtsDecodeChunkFunction pChunkDecode;
} dtsHDChunkDecodeMatrix[] =
{
    { DTS_HD_CHUNK_HDR     , AU_CUS_DTS_Parser_dtsDecodeDTSHDHR     },
    { DTS_HD_CHUNK_FILEINFO, NULL                                   },
    { DTS_HD_CHUNK_CORESSMD, AU_CUS_DTS_Parser_dtsDecodeCORESSMD    },
    { DTS_HD_CHUNK_EXTSS_MD, AU_CUS_DTS_Parser_dtsDecodeEXTSSMD     },
    { DTS_HD_CHUNK_AUPR_HDR, AU_CUS_DTS_Parser_dtsDecodeAUPRHDR     },
    { DTS_HD_CHUNK_AUPRINFO, NULL                                   },
    { DTS_HD_CHUNK_NAVI_TBL, AU_CUS_DTS_Parser_dtsDecodeNAVITBL     },
    { DTS_HD_CHUNK_BITSHVTB, NULL                                   },
    { DTS_HD_CHUNK_STRMDATA, AU_CUS_DTS_Parser_dtsDecodeSTRMDATA    },
    { DTS_HD_CHUNK_TIMECODE, AU_CUS_DTS_Parser_dtsDecodeTIMECODE    },
    { DTS_HD_CHUNK_BUILDVER, AU_CUS_DTS_Parser_dtsDecodeBUILDVER    }
};
#endif //#if(DTS_AUDIO_PARSER_ENABLE)

#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Share Area] shared [function] declare / implement in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
void AU_CUS_ShmInit_All_variables(void)
{
    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Initialize, STR */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Audio init flag
    pstAudioCustomerShmData->g_audio_customer_Init_Done         = FALSE;
    pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart = FALSE;
    pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish = TRUE;
    pstAudioCustomerShmData->g_audio_customer_scanf_bSupport    = TRUE;
    pstAudioCustomerShmData->g_audio_customer_Chip_Platform     = API_AUDIO_CUSTOMER_CHIP_PLATFORM_INVALID;

    //Dynamic Enable all apiAUDIO_v2_customer debug msg
    pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg          = FALSE;
    pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg             = FALSE;
    pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval    = 500;
    pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg                   = FALSE;
    pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval          = 1000;
    pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line              = 0;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Connect & Disconnect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Parser connect
    pstAudioCustomerShmData->g_audio_customer_PARSER_Mode      = API_AUDIO_CUSTOMER_PARSER_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_INVALID;

    //ADEC connect / ID / Gain / Mute
    pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect     = API_AUDIO_CUSTOMER_ADEC_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect     = API_AUDIO_CUSTOMER_ADEC_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect  = API_AUDIO_CUSTOMER_ADEC_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID       = AU_DEC_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID       = AU_DEC_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID    = AU_DEC_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC0_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC0_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_bMute       = FALSE;

    //ADC connect
    pstAudioCustomerShmData->g_audio_customer_ADC0_Connect      = API_AUDIO_CUSTOMER_ADC_IN_PORT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADC1_Connect      = API_AUDIO_CUSTOMER_ADC_IN_PORT_INVALID;

    //PCM Mixer connect / ID / Gain / Mute
    memset(&pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect,    FALSE, sizeof(pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect));
    memset(&pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID,         API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_INVALID, sizeof(pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID));
    memset(&pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain,       0,                                          sizeof(pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain));
    memset(&pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute,      FALSE,                                      sizeof(pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute));

    //Channel Sound Connect
    pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_CH8_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_CH5_Sound_inDelay = 0;
    pstAudioCustomerShmData->g_audio_customer_CH6_Sound_inDelay = 0;
    pstAudioCustomerShmData->g_audio_customer_CH7_Sound_inDelay = 0;
    pstAudioCustomerShmData->g_audio_customer_CH8_Sound_inDelay = 0;

    //FW Mixer Connect / Gain / Mute / Delay
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect,        FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect,        FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect,        FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain,   0,      sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain,   0,      sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain,   0,      sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute,  FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute,  FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute));
    memset(&pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute,  FALSE,  sizeof(pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute));
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Delay = 0;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Delay = 0;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Delay = 0;

    //FW Mixer During Limit time mute
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;

    //FW Mixer final mute
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_final_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8] = FALSE;

    //SE delay, SE(PreR2 / SeDSP / PostR2) connect
    pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay     = 32; //ms
    pstAudioCustomerShmData->g_audio_customer_SE_DriverDelay    = 32; //ms
    pstAudioCustomerShmData->g_audio_customer_SE_PreR2_Connect  = API_AUDIO_CUSTOMER_SE_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_SE_DspSE_Connect  = API_AUDIO_CUSTOMER_SE_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_SE_PostR2_Connect = API_AUDIO_CUSTOMER_SE_INPUT_INVALID;

    //SOUND OUT connect / Gain / Mute / SPDIF,HDMI(fg/Mode/PCM,NPCM mute/Delay)
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect       = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Gain          = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute         = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect     = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect     = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect     = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect     = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect     = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Gain        = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_UpperDelay  = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_DriverDelay = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_Connect       = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_mode          = API_AUDIO_CUSTOMER_SPDIF_TX_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect      = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Gain         = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute        = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_UpperDelay   = 0;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_DriverDelay  = 0;

    //SetSourceInfo / InputSwitch
    pstAudioCustomerShmData->g_audio_customer_AU_SetSourceInfo_eSourceType  = E_AUDIO_INFO_KTV_STB_IN;
    pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enSource       = AUDIO_NULL_INPUT;
    pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enGroup        = E_AUDIO_GROUP_INVALID;

    //sound out During Limit time mute
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT1_OUTPUT] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT2_OUTPUT] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_SPDIF_OUTPUT]    = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_I2S_OUTPUT]      = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_HDMI_ARC_OUTPUT] = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_HDMI_OUTPUT]     = FALSE;

    //sound out final mute
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_final_bMute   = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_final_bMute = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_final_bMute = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_final_bMute = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_final_bMute = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_final_bMute  = FALSE;

    //PCM Capture connect / bEnable / Gain / Mute /  Delay
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect  = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Gain     = 0;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bMute    = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Delay    = 0;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect  = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Gain     = 0;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bMute    = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Delay    = 0;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Connect  = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Gain     = 0;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bMute    = FALSE;
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Delay    = 0;

    //MP3 ENC connect / bEnable
    pstAudioCustomerShmData->g_audio_customer_MP3_ENC_Connect = API_AUDIO_CUSTOMER_MP3_ENC_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_MP3_ENC_bEnable = FALSE;

    //AAC ENC connect / bEnable
    pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect = API_AUDIO_CUSTOMER_MP3_ENC_INPUT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable = FALSE;

    //AENC Gain
    pstAudioCustomerShmData->g_audio_customer_AENC_Gain = 0x00;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Start & Stop */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput = API_AUDIO_CUSTOMER_ADEC0;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* SPDIF */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType           = API_AUDIO_CUSTOMER_SPDIF_TX_PCM;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_DriverOutputType          = API_AUDIO_CUSTOMER_SPDIF_TX_PCM;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_CopyInfo                  = API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_CategoryCode              = 0;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_LightOnOff                = FALSE;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff              = TRUE;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_ChannelStatus_Type        = API_AUDIO_CUSTOMER_SPDIF_CS_CategoryCode;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_ChannelStatus_Type_Status = API_AUDIO_CUSTOMER_SPDIF_CS_Category_General;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* HDMI */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type    = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type   = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_AudioReturnChannel    = FALSE;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_CopyInfo              = API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff          = FALSE;
    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType       = API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM;
    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_DriverOutputType      = API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM;
    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff          = TRUE;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* ATV */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //ATV_Prescale(A2)
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_A2_FM       = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_NICAM       = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_AM          = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_HIDEV       = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_FM_M        = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_HIDEV_M     = 0;

    //ATV_Prescale(BTSC)
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC        = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_MONO   = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_STEREO = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_SAP    = 0;

    //Monitor
    pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff              = FALSE;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Decoder */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Codec Type (Upper layer)
    pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec          = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec          = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType     = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;

    //Codec Type (Driver layer)
    pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverCodec         = MSAPI_AUD_DVB_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverCodec         = MSAPI_AUD_DVB_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType    = MSAPI_AUD_DVB_INVALID;

    //Play Cmd (Upper layer)
    pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay       = API_AUDIO_CUSTOMER_UPPER_PLAYCMD_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay       = API_AUDIO_CUSTOMER_UPPER_PLAYCMD_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay    = API_AUDIO_CUSTOMER_UPPER_PLAYCMD_INVALID;

    //Play Cmd (Driver layer)
    pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverPlay      = AU_DVB_DECCMD_STOP;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverPlay      = AU_DVB_DECCMD_STOP;
    pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverPlay   = AU_DVB_DECCMD_STOP;

    //---Play/pause Cmd Delay---
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay = 10;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_PauseDecoding_Delay = 10;

    //bMM mode (ADEC is used by MM)
    pstAudioCustomerShmData->g_audio_customer_ADEC0_bMM = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_bMM = FALSE;

    //Sync mode
    pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode = FALSE;

    //DRC mode
    pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode = API_AUDIO_CUSTOMER_DOLBY_DRC_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode = API_AUDIO_CUSTOMER_DOLBY_DRC_MODE_INVALID;

    //Downmix mode
    pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode = API_AUDIO_CUSTOMER_DOWNMIX_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode = API_AUDIO_CUSTOMER_DOWNMIX_MODE_INVALID;

    //DualMono mode
    pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode = API_AUDIO_CUSTOMER_DUALMONO_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode = API_AUDIO_CUSTOMER_DUALMONO_MODE_INVALID;

    //Trick mode
    pstAudioCustomerShmData->g_audio_customer_ADEC0_TrickMode = API_AUDIO_CUSTOMER_TRICK_MODE_INVALID;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_TrickMode = API_AUDIO_CUSTOMER_TRICK_MODE_INVALID;

    //AD bMain
    pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_bMain = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_bMain = FALSE;

    //AD Gain
    pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_Gain = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_Gain = 0;

    //ES Exist
    pstAudioCustomerShmData->g_audio_customer_ADEC0_bESExist = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_bESExist = FALSE;

    //ES_Info
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC0_HEAAC_EsInfo,   0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC0_HEAAC_EsInfo));
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC0_MPEG_EsInfo,    0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC0_MPEG_EsInfo));
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3_EsInfo,     0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3_EsInfo));
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC1_HEAAC_EsInfo,   0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC1_HEAAC_EsInfo));
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC1_MPEG_EsInfo,    0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC1_MPEG_EsInfo));
    memset(&pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3_EsInfo,     0, sizeof(pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3_EsInfo));

    //ADEC PCM output path
    pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath = API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath = API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC;

    //dump adec pcm (MCU path)
    pstAudioCustomerShmData->g_audio_customer_bEnableAdecPcmDump = FALSE;

    //ADEC End of stream
    pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt = 10;

    //ADEC Underrun
    pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_bRegister       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Threshold_in_ms = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Debounce_Cnt    = 10;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_bRegister       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Threshold_in_ms = 0;
    pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Debounce_Cnt    = 10;

    //Monitor
    pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff = TRUE;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Common */
    //-------------------------------------------------------------------------------------------------------------------------------------
    #if (UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
    pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd = 0;
    #endif //#if (UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Customized patch */
    //-------------------------------------------------------------------------------------------------------------------------------------
    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_ByPass_bEnable = FALSE;
    #endif

    #if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)
    pstAudioCustomerShmData->g_audio_customer_patch_Low_Latency_Limiter_bEnable       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_patch_Low_Latency_Limiter_ES_Threshold  = 0;
    pstAudioCustomerShmData->g_audio_customer_patch_Low_Latency_Limiter_PCM_Threshold = 0;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)

    #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
    pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable = FALSE;
    pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Option = 0;
    pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG = 0;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)

    #if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable   = FALSE;
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable  = FALSE;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)

    #if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable = FALSE;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)

    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
    pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms = 0;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)

    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI     = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI    = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM      = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM     = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType  = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_INVALID;
    #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Customized Internal patch */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //---MS12 HDMI TX PCM ouput Auto Delay (for sync with NPCM)---
    //input: MS12 DD/DDP/DP
    pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DD_in_Auto_Audio_Delay   = CUSTOMIZED_INTERNAL_PATCH_MS12_HDMI_TX_PCM_DD_IN_AUTO_AUDIO_DELAY;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DDP_in_Auto_Audio_Delay  = CUSTOMIZED_INTERNAL_PATCH_MS12_HDMI_TX_PCM_DDP_IN_AUTO_AUDIO_DELAY;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DP_in_Auto_Audio_Delay   = CUSTOMIZED_INTERNAL_PATCH_MS12_HDMI_TX_PCM_DP_IN_AUTO_AUDIO_DELAY;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay   = 0;

    //---General Buffer Dump---
    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MM_ES1_bEnable         = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable           = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable       = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable       = FALSE;

    //---MS12 SNDR2 PCMR METADATA SELECT---
    pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select            = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_INVALID;

    //---HW SRC Output Gain Compensate---
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out     = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_I2S_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out  = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_LINE_0_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out  = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_LINE_1_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out  = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_LINE_2_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out  = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_LINE_3_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out   = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_SPDIF_OUT;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out    = CUSTOMIZED_INTERNAL_PATCH_HW_SRC_GAIN_COMPENSATE_HDMI_OUT;

    //---DDP_71 Auto Bypass check---
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex       = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_bEnable = FALSE;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt    = 1000;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt        = 0;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream  = FALSE;

    //---Avoid ADEC Pop Noise---
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time    = 10;
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time   = 10;

    //---ADEC mute delay---
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_SetMute_Delay = 10;  //ms

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Clip Play for ES */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Clip Play for PCM */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Gain, Mute & Delay */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AENC */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //Dynamic dump file for debug
    pstAudioCustomerShmData->g_audio_customer_AENC_bDumpEncData = FALSE;

    //AENC Enable
    pstAudioCustomerShmData->g_audio_customer_AENC0_bEnable = FALSE;
    pstAudioCustomerShmData->g_audio_customer_AENC1_bEnable = FALSE;

    //AENC Type
    pstAudioCustomerShmData->g_audio_customer_AENC0_Type = API_AUDIO_CUSTOMER_AENC_ENCODE_MP3;
    pstAudioCustomerShmData->g_audio_customer_AENC1_Type = API_AUDIO_CUSTOMER_AENC_ENCODE_MP3;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* PCM Capture */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //PCM capture Dump to file for debug
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable = FALSE;

    //PCM capture request data in byte
    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte = 50*48*2*2; /* 50ms in 48KHz, 16bits, stereo PCM */

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* PCM IO Control */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* MM New Mode */
    //-------------------------------------------------------------------------------------------------------------------------------------

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Mstar Sound Effect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //API_AUDIO_CUSTOMER_MSTAR_SE_Enable
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable));
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt));

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ));
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt));

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef));
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt));

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef
    memset(&pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef));
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE = API_AUDIO_CUSTOMER_AVC_LINEAR;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Slope
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_L = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_R = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold = 0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_MSTAR_SE_GET_NR_Status
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold = 0;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Advanced Sound Effect */
    //-------------------------------------------------------------------------------------------------------------------------------------
    //API_AUDIO_CUSTOMER_DTS_SE_Enable
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable));
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt));

    //API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable));
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt));

    //API_AUDIO_CUSTOMER_DTS_SE_SetParam
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam,             0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam));
    memset(&pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt));

    //API_AUDIO_CUSTOMER_Dolby_DAP_Enable
    pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable             = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable
    pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable             = FALSE;
    pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable_UpperSetCnt = 0;

    //API_AUDIO_CUSTOMER_Dolby_DAP_SetParam
    memset(&pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam, 0, sizeof(pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam));
    pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam_UpperSetCnt = 0;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Thread monitor Enable */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_ClipDecoderMonitor_bEnable                         = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_MP3EncodeMonitor_bEnable                           = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_MonitorService_bEnable                             = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_AACEncodeMonitor_bEnable                           = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_MuteDuringLimitedTime_Monitor_bEnable              = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_AdecPcmOutMonitor_bEnable                          = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_PCMCaptureMonitor_bEnable                          = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_EndOfStreamMonitor_bEnable                         = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_Underrun_Monitor_bEnable                      = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_PATCH_Dump_R2_Log_Monitor_bEnable                  = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor_bEnable    = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor_bEnable = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor_bEnable  = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_R2_Active_Monitor_bEnable           = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor_bEnable           = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_Play_Monitor_bEnable              = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_PCMIO_Play_Monitor_bEnable                    = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_AV_Sync_Info_Monitor_bEnable                       = TRUE;
    pstAudioCustomerShmData->g_audio_customer_AU_CUS_ThreadPrintMsg_Monitor_bEnable                     = TRUE;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* Thread monitor interval */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_AU_ClipDecoderMonitor_Interval                        = 10;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval                          = 5;   //ms
    pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval                            = 30;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_AACEncodeMonitor_Interval                          = 5;   //ms
    pstAudioCustomerShmData->g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval             = 50;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_AdecPcmOut_Interval                                = 50;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_PCMCapture_Interval                                = 20;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_EndOfStreamMonitor_Interval                        = 10;  //ms
    pstAudioCustomerShmData->g_audio_customer_AU_AdecUnderrun_Interval                              = 10;  //ms
    pstAudioCustomerShmData->g_audio_customer_patch_Dump_R2_Log_Monitor_Interval                    = 40;  //ms
    pstAudioCustomerShmData->g_audio_customer_internal_patch_Auto_Audio_Delay_Monitor_Interval      = 20;  //ms
    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_Monitor_Interval   = 20;  //ms
    pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_Interval    = 10;  //ms
    pstAudioCustomerShmData->g_audio_customer_internal_patch_R2_Active_Monitor_Interval             = 30;  //ms

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AU Demo PCMIO play */
    //-------------------------------------------------------------------------------------------------------------------------------------
    memset((void *)&pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam, 0x00, sizeof(API_AUDIO_CUSTOMER_PCMIO_PARAM));
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay                   = API_AUDIO_CUSTOMER_UPPER_PLAYCMD_INVALID;
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_repeatNum                   = 1;
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_Monitor_Interval            = 1000;
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length           = 0;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AU Demo MM New Mode */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_StartTime        = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_AD_Play_StartTime     = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval = 10;

    //-------------------------------------------------------------------------------------------------------------------------------------
    /* AV Sync Info */
    //-------------------------------------------------------------------------------------------------------------------------------------
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex             = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable               = FALSE;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Monitor_Interval      = 10;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel              = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel_in_ms        = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_es_size         = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_ptsExist        = FALSE;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_pts             = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_R2_pts                = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_DMX_stc               = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt  = 0;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_ret  = FALSE;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset            = 0;
    memset(&pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info,       0, sizeof(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info));
}

static MS_BOOL AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect)
{
    MS_U16 path = 4;
    MS_U32 reg = 0;
    MS_U16 mask = 0;

    switch(inputConnect)
    {
        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_FWM0:
            path = 4;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_DLY0:
            path = 5;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_AUDIO_DELAY:
            path = 5;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_DSPSE:
            path = 6;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_CH7:
            path = 7;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_NULL:
            path = 0;
        break;

        default:
            path = 4;
        break;
    }

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_SOUNDOUT_I2S:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL2;
            mask = 0x000F;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT0:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL1;
            mask = 0x000F;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT1:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL1;
            path = path<<4;
            mask = 0x00F0;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT2:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL1;
            path = path<<8;
            mask = 0x0F00;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT3:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL1;
            path = path<<12;
            mask = 0xF000;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_SPDIF:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL3;
            path = path<<8;
            mask = 0x0F00;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_ARC:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL3;
            path = path<<4;
            mask = 0x00F0;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX:
            reg = REG_BANK_SNDOUT_INPUT_PATH_SEL3;
            mask = 0x000F;
        break;

        default:
            break;
    }

    if(reg > 0)
    {
        AU_CUS_WriteAbsMaskReg(reg, mask, path);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

static void AU_CUS_Initial_Register_Bank_By_ChipType(void)
{
#if 0
    MS_U32 adecR2reg  = 0x1603B2;
    MS_U32 asndR2reg  = 0x112EB2;
    MS_U32 adecDspreg = 0x112DB8;
    MS_U32 asndDspreg = 0x112DF8;

    if(AU_CUS_ReadAbsReg(adecR2reg) != 0 && AU_CUS_ReadAbsReg(asndR2reg) != 0)
    {
        //---2R1D---
    }
    else if(AU_CUS_ReadAbsReg(asndR2reg) != 0 && AU_CUS_ReadAbsReg(asndDspreg) != 0)
    {
        //---1R1D---
    }
    else if(AU_CUS_ReadAbsReg(asndR2reg) != 0 && AU_CUS_ReadAbsReg(adecDspreg) != 0 && AU_CUS_ReadAbsReg(asndDspreg) != 0)
    {
        //---2D1R---
    }
    else if(AU_CUS_ReadAbsReg(adecDspreg) != 0 && AU_CUS_ReadAbsReg(asndDspreg) != 0)
    {
        //---2D---
    }
    else if(AU_CUS_ReadAbsReg(asndDspreg) != 0)
    {
        //---1D---
    }
    else
    {
        //---UNKNOWN (Default is 1D)---
    }
    return;
#endif

    if(UTPA_AUDIO_CHIP_TYPE_2R1D)
    {
        //---2R1D---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_2R1D;
        REG_BANK_ADEC1_PLAY             = 0x160398;
        REG_BANK_ADEC1_CODEC            = 0x160398;
        REG_BANK_ADEC2_PLAY             = 0x16039A;
        REG_BANK_ADEC2_CODEC            = 0x16039A;
        REG_BANK_R2_UART                = 0x101EA6;
        REG_BANK_R2_DEC_UART_ENABLE     = 0x0;
        REG_BANK_R2_SND_UART_ENABLE     = 0xCCCC;
        REG_BANK_R2_WFI                 = 0x16038A;
        REG_BANK_R2_WFI_ENABLE          = 0x0800;
        REG_BANK_R2_LOG_DBG             = MBOX_BYTE_STATUS_SELECT;
        REG_BANK_R2_SYSTEM_DBG          = 0x16038A;
        REG_BANK_ADEC_DSP_DBG           = 0x112DDC;
        REG_BANK_ADEC_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ADEC_DSP_RESULT2       = 0x112DFE;
        REG_BANK_ASND_DSP_DBG           = 0x112DDC;
        REG_BANK_ASND_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ASND_DSP_RESULT2       = 0x112DFE;
        REG_BANK_DEC_R2_VERSION         = 0x1603AA;
        REG_BANK_SND_R2_VERSION         = 0x112EAA;
        REG_BANK_SND_R2_SRS             = 0x112E94;
        REG_BANK_SNDOUT_INPUT_PATH_SEL1 = 0x112D50;
        REG_BANK_SNDOUT_INPUT_PATH_SEL2 = 0x112D52;
        REG_BANK_SNDOUT_INPUT_PATH_SEL3 = 0x112D54;
        REG_BANK_ADEC_DSP_IDMA          = 0x112A80;
        REG_BANK_ASND_DSP_IDMA          = 0x112A80;
        AU_nDBG("[AUDIO].....ChipType......||[2R1D  ]        ||]\n");
    }
    else if(UTPA_AUDIO_CHIP_TYPE_1R1D)
    {
        //---1R1D---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_1R1D;
        REG_BANK_ADEC1_PLAY             = 0x112E98;
        REG_BANK_ADEC1_CODEC            = 0x112E98;
        REG_BANK_ADEC2_PLAY             = 0x112E9A;
        REG_BANK_ADEC2_CODEC            = 0x112E9A;
        REG_BANK_R2_UART                = 0x101EA6;
        REG_BANK_R2_DEC_UART_ENABLE     = 0xCCCC;
        REG_BANK_R2_SND_UART_ENABLE     = 0xCCCC;
        REG_BANK_R2_WFI                 = 0x112E8A;
        REG_BANK_R2_WFI_ENABLE          = 0x0800;
        REG_BANK_R2_LOG_DBG             = MBOX_BYTE_STATUS_SELECT;
        REG_BANK_R2_SYSTEM_DBG          = 0x112E8A;
        REG_BANK_ADEC_DSP_DBG           = 0x112DDC;
        REG_BANK_ADEC_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ADEC_DSP_RESULT2       = 0x112DFE;
        REG_BANK_ASND_DSP_DBG           = 0x112DDC;
        REG_BANK_ASND_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ASND_DSP_RESULT2       = 0x112DFE;
        REG_BANK_DEC_R2_VERSION         = 0x112EAA;
        REG_BANK_SND_R2_VERSION         = 0x112EAA;
        REG_BANK_SND_R2_SRS             = 0x112E94;
        REG_BANK_SNDOUT_INPUT_PATH_SEL1 = 0x112D50;
        REG_BANK_SNDOUT_INPUT_PATH_SEL2 = 0x112D52;
        REG_BANK_SNDOUT_INPUT_PATH_SEL3 = 0x112D54;
        REG_BANK_ADEC_DSP_IDMA          = 0x112A80;
        REG_BANK_ASND_DSP_IDMA          = 0x112A80;
        AU_nDBG("[AUDIO].....ChipType......||[1R1D  ]        ||]\n");
    }
    else if(UTPA_AUDIO_CHIP_TYPE_2D1R)
    {
        //---2D1R---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_2D1R;
        REG_BANK_ADEC1_PLAY             = 0x112A2C;
        REG_BANK_ADEC1_CODEC            = 0x112DBA;
        REG_BANK_ADEC2_PLAY             = 0x112AAC;
        REG_BANK_ADEC2_CODEC            = 0x112DFA;
        REG_BANK_R2_UART                = 0xFFFFFF;
        REG_BANK_R2_DEC_UART_ENABLE     = 0xFFFFFF;
        REG_BANK_R2_SND_UART_ENABLE     = 0xFFFFFF;
        REG_BANK_R2_WFI                 = 0xFFFFFF;
        REG_BANK_R2_WFI_ENABLE          = 0xFFFFFF;
        REG_BANK_R2_LOG_DBG             = 0xFFFFFF;
        REG_BANK_R2_SYSTEM_DBG          = 0xFFFFFF;
        REG_BANK_ADEC_DSP_DBG           = 0x112D9C;
        REG_BANK_ADEC_DSP_RESULT1       = 0x112DBC;
        REG_BANK_ADEC_DSP_RESULT2       = 0x112DBE;
        REG_BANK_ASND_DSP_DBG           = 0x112DDC;
        REG_BANK_ASND_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ASND_DSP_RESULT2       = 0x112DFE;
        REG_BANK_DEC_R2_VERSION         = 0x112EAA;
        REG_BANK_SND_R2_VERSION         = 0x112EAA;
        REG_BANK_SND_R2_SRS             = 0x112E94;
        REG_BANK_SNDOUT_INPUT_PATH_SEL1 = 0x112D50;
        REG_BANK_SNDOUT_INPUT_PATH_SEL2 = 0x112D52;
        REG_BANK_SNDOUT_INPUT_PATH_SEL3 = 0x112D54;
        REG_BANK_ADEC_DSP_IDMA          = 0x112A00;
        REG_BANK_ASND_DSP_IDMA          = 0x112A80;
        AU_nDBG("[AUDIO].....ChipType......||[2D1R  ]        ||]\n");
    }
    else if(UTPA_AUDIO_CHIP_TYPE_2D)
    {
        //---2D---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_2D;
        AU_nDBG("[AUDIO].....ChipType......||[2D    ]        ||]\n");
    }
    else if(UTPA_AUDIO_CHIP_TYPE_1D)
    {
        //---1D---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_1D;
        REG_BANK_ADEC1_PLAY             = 0x112AAC;
        REG_BANK_ADEC1_CODEC            = 0x112DFA;
        REG_BANK_ADEC2_PLAY             = 0x112AAC;
        REG_BANK_ADEC2_CODEC            = 0x112DFA;
        REG_BANK_ADEC_DSP_DBG           = 0x112DDC;
        REG_BANK_ADEC_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ADEC_DSP_RESULT2       = 0x112DFE;
        REG_BANK_ASND_DSP_DBG           = 0x112DDC;
        REG_BANK_ASND_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ASND_DSP_RESULT2       = 0x112DFE;
        REG_BANK_SNDOUT_INPUT_PATH_SEL1 = 0x112D50;
        REG_BANK_SNDOUT_INPUT_PATH_SEL2 = 0x112D52;
        REG_BANK_SNDOUT_INPUT_PATH_SEL3 = 0x112D54;
        REG_BANK_ADEC_DSP_IDMA          = 0x112A80;
        REG_BANK_ASND_DSP_IDMA          = 0x112A80;
        AU_nDBG("[AUDIO].....ChipType......||[1D    ]        ||]\n");
    }
    else
    {
        //---UNKNOWN (Default is 1D)---
        AUDIO_CHIP_TYPE                 = API_AUDIO_CUSTOMER_CHIP_TYPE_1D;
        REG_BANK_ADEC1_PLAY             = 0x112AAC;
        REG_BANK_ADEC1_CODEC            = 0x112DFA;
        REG_BANK_ADEC2_PLAY             = 0x112AAC;
        REG_BANK_ADEC2_CODEC            = 0x112DFA;
        REG_BANK_ADEC_DSP_DBG           = 0x112DDC;
        REG_BANK_ADEC_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ADEC_DSP_RESULT2       = 0x112DFE;
        REG_BANK_ASND_DSP_DBG           = 0x112DDC;
        REG_BANK_ASND_DSP_RESULT1       = 0x112DFC;
        REG_BANK_ASND_DSP_RESULT2       = 0x112DFE;
        REG_BANK_SNDOUT_INPUT_PATH_SEL1 = 0x112D50;
        REG_BANK_SNDOUT_INPUT_PATH_SEL2 = 0x112D52;
        REG_BANK_SNDOUT_INPUT_PATH_SEL3 = 0x112D54;
        REG_BANK_ADEC_DSP_IDMA          = 0x112A80;
        REG_BANK_ASND_DSP_IDMA          = 0x112A80;
        AU_nDBG("[AUDIO].....ChipType......||[unKnown - default 1D]    ||]\n");
    }
    return;
}

void AU_CUS_Dump_RegBank(int bank)
{
    int intOffset, i;
    intOffset = (int)bank & 0xFFFF00;
    for(i = 0; i <= 15; i++)
    {
        #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
        for(j = 0; j<= 7; j++)
        {
            unsigned int temp_reg = intOffset + 16*i + 2*j;
            AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
        }
        AU_nPRINT(" @@ \n");
        #endif
        AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                    (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                    (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                    (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                    (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                    (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                    (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                    (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                    (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );
    }

    return;
}

static AUDIO_CAPTURE_SOURCE_TYPE AU_CUS_ConvertCustomerCaptureInputToDriverInput(API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT captureCustomerSourceType)
{
    AUDIO_CAPTURE_SOURCE_TYPE captureDriverSourceType = E_CAPTURE_NULL;

    switch(captureCustomerSourceType)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH5:
        {
            captureDriverSourceType = E_CAPTURE_CH5;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH6:
        {
            captureDriverSourceType = E_CAPTURE_CH6;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH7:
        {
            captureDriverSourceType = E_CAPTURE_CH7;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH8:
        {
            captureDriverSourceType = E_CAPTURE_CH8;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM:
        {
            captureDriverSourceType = E_CAPTURE_PCM;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM_DELAY:
        {
            captureDriverSourceType = E_CAPTURE_PCM_DELAY;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM_SE:
        {
            captureDriverSourceType = E_CAPTURE_PCM_SE;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_MIXER:
        {
            captureDriverSourceType = E_CAPTURE_MIXER;
        }
        break;

        default:
        {
            captureDriverSourceType = E_CAPTURE_CH5;
        }
        break;
    }

    return captureDriverSourceType;
}

static AUDIO_DEC_ID AU_CUS_ConvertCustomerAdecIndexToDriverDecID(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            DecID = pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID;

            if(DecID == AU_DEC_INVALID)
            {
                DecID = AU_DEC_ID1;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            DecID = pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID;

            if(DecID == AU_DEC_INVALID)
            {
                DecID = AU_DEC_ID3;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            DecID = pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID;

            if(DecID == AU_DEC_INVALID)
            {
                DecID = AU_DEC_ID2;
            }
        }
        break;

        default:
        {
            AU_nPRINT("[Error] [%s] [Invalid adecIndex: %d] \n", __FUNCTION__, adecIndex);
            DecID = pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID;
        }
        break;
    }
    return DecID;
}

static En_DVB_decSystemType AU_CUS_ConvertCustomerCodecTypeToDriverDVBdecSystemType(API_AUDIO_CUSTOMER_CODEC_TYPE audioType)
{
    En_DVB_decSystemType eAudioDSPSystem = MSAPI_AUD_DVB_INVALID;

    switch(audioType)
    {
        case API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_INVALID;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_AC3:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_AC3;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_MPEG;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_AAC:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_HEAAC:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_AAC;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_DRA:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_DRA;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_MP3:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_MP3;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_DTS:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_HD_MA:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_EXPRESS:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_CD:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_DTS;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_WMA:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_WMA_PRO:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_WMA_PRO;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_XPCM:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_XPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_RA8LBR:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_RA8LBR;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_FLAC:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_FLAC;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_VORBIS:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_VORBIS;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_AMR_NB:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_AMR_NB;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_AMR_WB:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_AMR_WB;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_DolbyTrueHDBypass:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_DolbyTrueHDBypass;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_SIF:
        case API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_A2:
        {
            eAudioDSPSystem = MSAPI_AUD_ATV_PAL;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_BTSC:
        {
            eAudioDSPSystem = MSAPI_AUD_ATV_BTSC;
        }
        break;

        case API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass:
        {
            #if(CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH)
            {
                eAudioDSPSystem = MSAPI_AUD_DVB_ES_Bypass;
            }
            #endif //#if(CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH)
        }
        break;

        default:
        {
            eAudioDSPSystem = MSAPI_AUD_DVB_INVALID;
        }
        break;
    }

    return eAudioDSPSystem;
}

static AUDIO_SOURCE_INFO_TYPE AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(API_AUDIO_CUSTOMER_ADEC_INPUT enInputSourceType)
{
    AUDIO_SOURCE_INFO_TYPE  eAudioSource = E_AUDIO_INFO_SPDIF_IN;
    switch(enInputSourceType)
    {
        case API_AUDIO_CUSTOMER_ADEC_INPUT_DTV:
        {
            eAudioSource = E_AUDIO_INFO_DTV_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI:
        {
            eAudioSource = E_AUDIO_INFO_HDMI_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_MM:
        {
            eAudioSource = E_AUDIO_INFO_MM_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP:
        {
            eAudioSource = E_AUDIO_INFO_GAME_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_ATV:
        {
            eAudioSource = E_AUDIO_INFO_ATV_IN;
        }
        break;

        default:
            break;
    }

    return eAudioSource;
}

static AUDIO_INPUT_TYPE AU_CUS_ConvertCustomerADECSourceToDriverSourceType(API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect)
{
    AUDIO_SOURCE_INFO_TYPE sourceType = E_AUDIO_INFO_DTV_IN;

    switch(inputConnect)
    {
        case API_AUDIO_CUSTOMER_ADEC_INPUT_DTV:
        {
            sourceType = E_AUDIO_INFO_DTV_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI:
        {
            sourceType = E_AUDIO_INFO_HDMI_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_MM:
        case API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP:
        {
            sourceType = E_AUDIO_INFO_MM_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_ATV:
        {
            sourceType = E_AUDIO_INFO_ATV_IN;
        }
        break;

        default:
            break;
    }

    return sourceType;
}

static AUDIO_INPUT_TYPE AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT ChInput)
{
    AUDIO_INPUT_TYPE eAudioSource = AUDIO_NULL_INPUT;

    switch(ChInput)
    {
        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect)
            {
                case API_AUDIO_CUSTOMER_ADEC_INPUT_DTV:
                case API_AUDIO_CUSTOMER_ADEC_INPUT_MM:
                case API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP:
                {
                    eAudioSource = AUDIO_DSP1_DVB_INPUT;
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI:
                {
                    eAudioSource = AUDIO_DSP1_HDMI_INPUT;
                }
                break;

                default:
                {
                    eAudioSource = AUDIO_NULL_INPUT;
                }
                break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect)
            {
                case API_AUDIO_CUSTOMER_ADEC_INPUT_DTV:
                case API_AUDIO_CUSTOMER_ADEC_INPUT_MM:
                case API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP:
                {
                    #if(R2_SUPPORT_R2DMA_READER2 == 1)
                    {
                        eAudioSource = AUDIO_DSP3_DVB_INPUT;
                    }
                    #elif(R2_SUPPORT_R2_DEC_ISR2_EN == 1)
                    {
                        //  _____ ___________ _______________
                        // |     | R2 DMA    |  DSP Dec out  |
                        // |_____|___________|_______________|
                        // |ADEC0| R2_DMA_1  |R2_DEC_ISR1_EN |
                        // |     | (0x80)    |    (0x80)     |
                        // |_____|___________|_______________|
                        // |ADEC1| R2_DMA_2  |R2_DEC_ISR2_EN |
                        // |     | (0x82)    |    (0x83)     |
                        // |     | 1R1D not  |               |
                        // |_____|_Support___|_______________|

                        // note: R2_DEC_ISR2_EN sholud be 1 in Sys_def.h
                        eAudioSource = AUDIO_DSP4_SIF_INPUT;
                    }
                    #else
                    {
                        eAudioSource = AUDIO_DSP3_DVB_INPUT;
                    }
                    #endif
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI:
                {
                    eAudioSource = AUDIO_DSP3_HDMI_INPUT;
                }
                break;

                default:
                {
                    eAudioSource = AUDIO_NULL_INPUT;
                }
                break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV:
        {
            eAudioSource = AUDIO_DSP4_SIF_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_HDMI:
        {
            eAudioSource = AUDIO_HDMI_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADC0:
        {
            eAudioSource = pstAudioCustomerShmData->g_audio_customer_ADC0_Connect;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADC1:
        {
            eAudioSource = pstAudioCustomerShmData->g_audio_customer_ADC1_Connect;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_SCART:
        {
            eAudioSource = pstAudioCustomerShmData->g_audio_customer_ADC0_Connect;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_R2DMA_DSP1:
        {
            eAudioSource = AUDIO_DSP1_DVB_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_R2DMA_DSP3:
        {
            eAudioSource = AUDIO_DSP3_DVB_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_SWDMA_DSP3:
        {
            eAudioSource = AUDIO_DSP3_DVB_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_HWDMA:
        {
            eAudioSource = AUDIO_DMA_READER_INPUT;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_NONE:
        {
            eAudioSource = AUDIO_NULL_INPUT;
        }
        break;

        default:
        {
            eAudioSource = AUDIO_NULL_INPUT;
        }
        break;
    }

    return eAudioSource;
}

static AUDIO_SOURCE_INFO_TYPE AU_CUS_ConvertCustomerChInputToDriverSourceInfoType(API_AUDIO_CUSTOMER_CH_INPUT chInput)
{
    AUDIO_SOURCE_INFO_TYPE  eAudioSource = E_AUDIO_INFO_ADC_IN;

    switch(chInput)
    {
        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
        {
            eAudioSource = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
        {
            eAudioSource = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect);
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV:
        {
            eAudioSource = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect);
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_ADC0:
        case API_AUDIO_CUSTOMER_CH_INPUT_ADC1:
        {
            eAudioSource = E_AUDIO_INFO_ADC_IN;
        }
        break;

        case API_AUDIO_CUSTOMER_CH_INPUT_HDMI:
        {
            eAudioSource = E_AUDIO_INFO_HDMI_IN;
        }
        break;

        default:
            break;
    }

    return eAudioSource;
}

static Sound_ENABLE_Type AU_CUS_ConvertCustomerMstarSndTypeToDriverMstarSndType(API_AUDIO_CUSTOMER_MSTAR_SE_TYPE seType)
{
    Sound_ENABLE_Type retType = -1;
    switch(seType)
    {
        case API_AUDIO_CUSTOMER_GEQ:
        {
            retType = Sound_ENABL_Type_EQ;
        }
        break;

        case API_AUDIO_CUSTOMER_PEQ:
        {
            retType = Sound_ENABL_Type_PEQ;
        }
        break;

        case API_AUDIO_CUSTOMER_HPF:
        {
            retType = Sound_ENABL_Type_Hpf;
        }
        break;

        case API_AUDIO_CUSTOMER_DRC:
        {
            retType = Sound_ENABL_Type_DRC;
        }
        break;

        case API_AUDIO_CUSTOMER_AVC:
        {
            retType = Sound_ENABL_Type_AutoVolume;
        }
        break;

        case API_AUDIO_CUSTOMER_BALANCE:
        {
            retType = Sound_ENABL_Type_Balance;
        }


        default:
            break;

    }
    return retType;
}

static ADVSND_TYPE AU_CUS_ConvertCustomerDtsSndTypeToDriverDtsSndType(API_AUDIO_CUSTOMER_DTS_SE_TYPE seType)
{
    ADVSND_TYPE retType  = ADV_NONE;
    switch(seType)
    {
        case API_AUDIO_CUSTOMER_DTS_SE_TSXT:
        {
            retType = SRS_TSXT;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_TSHD:
        {
            retType = SRS_TSHD;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_THEATERSOUND:
        {
            retType = SRS_THEATERSOUND;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PURESND:
        {
            retType = SRS_PURESND;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_STUDIOSOUND_3D:
        {
            retType = DTS_STUDIOSOUND_3D;
        }
        break;

        default:
            break;

    }
    return retType;
}

static ADVFUNC AU_CUS_ConvertCustomerDtsSndUnitToDriverDtsSndUnitType(API_AUDIO_CUSTOMER_DTS_SE_UNIT_TYPE seUnit)
{
    ADVFUNC retType  = SRS_THEATERSOUND_TOTAL;

    switch(seUnit)
    {
        //---------------------------------------------------------------------------------
        // TSHD
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TOTAL:
        {
            retType = SRS_THEATERSOUND_TOTAL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD:
        {
            retType = SRS_THEATERSOUND_TSHD;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DEFINITION:
        {
            retType = SRS_THEATERSOUND_DEFINITION;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DC:
        {
            retType = SRS_THEATERSOUND_DC;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_SURR:
        {
            retType = SRS_THEATERSOUND_TSHD_SURR;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS:
        {
            retType = SRS_THEATERSOUND_TRUBASS;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS_LVL_INDPT:
        {
            retType = SRS_THEATERSOUND_TSHD_LEVEL_INDPT;
        }
        break;

        //---------------------------------------------------------------------------------
        // CC3D Controls (CC3D must enable)
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D:
        {
            retType = SRS_THEATERSOUND_CC3D_EN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_DEPTH_PROCESS:
        {
            retType = SRS_THEATERSOUND_CC3D_DEPTH_PROCESS_EN;
        }
        break;

        //---------------------------------------------------------------------------------
        // TRUVOLUME HD
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME_NORMALIZER:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME_NORMALIZER;
        }
        break;

        //---------------------------------------------------------------------------------
        // TRUDIALOG
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUDIALOG:
        {
            retType = SRS_THEATERSOUND_TRUDIALOG;
        }
        break;

        //---------------------------------------------------------------------------------
        // TBHDX
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_TBHDX:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_EN;
        }
        break;

        //---------------------------------------------------------------------------------
        // GEQ
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_GEQ:
        {
            retType = SRS_THEATERSOUND_GEQ_EN;
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND HRADLIMITER
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HL:
        {
            retType = SRS_PURESOUND_HL;
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND AEQ
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_AEQ:
        {
            retType = SRS_PURESOUND_AEQ;
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND HPF
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HPF:
        {
            retType = SRS_PURESOUND_HPF;
        }
        break;

        default:
            break;

    }
    return retType;
}

static ADVSND_PARAM AU_CUS_ConvertCustomerDtsSndParamToDriverDtsSndParam(API_AUDIO_CUSTOMER_DTS_SE_PARAM_TYPE seParam, MS_U32 u32value)
{
    ADVSND_PARAM retType  = 0;

    switch(seParam)
    {
        //---------------------------------------------------------------------------------
        // TSHD
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DEFINITION_CTRL_FXP24:
        {
            retType = SRS_THEATERSOUND_DEFINITION_CONTROL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DC_LEVEL_CTRL_FXP24:
        {
            retType = SRS_THEATERSOUND_DC_CONTROL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_SURR_LEVEL_CTRL_FXP24:
        {
            retType = SRS_THEATERSOUND_SURR_LEVEL_CONTROL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CTRL_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUBASS_CONTROL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_COMPR_CTRL_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUBASS_COMPRESSOR_CONTROL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE:
        {
            if(u32value < 2)
            {
                retType = SRS_THEATERSOUND_TRUBASS_PROCESS_MODE;
            }
            else
            {
                AU_nPRINT("Error: API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE value is out of range \n");
            }
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_SPKSIZE:
        {
            if(u32value < 9)
            {
                retType = SRS_THEATERSOUND_SPEAKERSIZE;
            }
            else
            {
                AU_nPRINT("Error: API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_SPKSIZE value is out of range \n");
            }
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE:
        {
            if(u32value < 39)
            {
                retType = SRS_THEATERSOUND_TRUBASS_SPEAKER_AUDIO;
            }
            else
            {
                AU_nPRINT("Error: API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE value is out of range \n");
            }
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS:
        {
            if(u32value < 39)
            {
                retType = SRS_THEATERSOUND_TRUBASS_SPEAKER_ANALYSIS;
            }
            else
            {
                AU_nPRINT("Error: API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS value is out of range \n");
            }
        }
        break;

        //---------------------------------------------------------------------------------
        // Main Controls
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_HEADROOM_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_HEADROOM_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_BYPASS_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_BYPASS_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_CC3D_PROCESS_PATH:
        {
            retType = SRS_THEATERSOUND_CC3D_PROCESS_PATH;
        }
        break;

        //---------------------------------------------------------------------------------
        // CC3D Controls
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CC3D_INPUT_GAIN;
        }
        break;

        //---------------------------------------------------------------------------------
        // TRUVOLUME HD
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MODE:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME_MODE;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_REF_LEVEL_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME_REF_LEVEL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MAX_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME_MAX_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH;
        }
        break;

        //---------------------------------------------------------------------------------
        // TRUDIALOG
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUDIALOG_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_CLARITY_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUDIALOG_CLARITY_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_PROCESS_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_TRUDIALOG_PROCESS_GAIN;
        }
        break;

        //---------------------------------------------------------------------------------
        // TBHDX
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_BASSLEVEL_FXP24:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_BASSLEVEL;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_HP_ORDER:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_HP_ORDER;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_DYNAMICS_FXP24:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_DYNAMICS;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_MODE:
        {
            retType = SRS_THEATERSOUND_CC3D_TBHDX_MODE;
        }
        break;

        //---------------------------------------------------------------------------------
        // CS DECODER
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CS_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_PROCESS_MODE:
        {
            retType = SRS_THEATERSOUND_CS_PROCESS_MODE;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LR_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CS_LR_OUTPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LsRs_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CS_LsRs_OUTPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_Center_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_CS_Center_OUTPUT_GAIN;
        }
        break;

        //---------------------------------------------------------------------------------
        // GEQ
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_INPUT_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND0_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_BAND0_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND1_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_BAND1_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND2_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_BAND2_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND3_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_BAND3_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND4_GAIN_FXP24:
        {
            retType = SRS_THEATERSOUND_GEQ_BAND4_GAIN;
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND HRADLIMITER
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_INPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_HL_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_HL_OUTPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_BYPASS_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_HL_BYPASS_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_LIMITERBOOST_FXP24:
        {
            retType = SRS_PURESOUND_HL_LIMITERBOOST;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_HARDLIMIT_CTRL_FXP24:
        {
            retType = SRS_PURESOUND_HL_HARDLIMIT;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_DELAY:
        {
            if( (u32value > 6) && (u32value < 48))
            {
                retType = SRS_PURESOUND_HL_DELAYLEN;
            }
            else
            {
                AU_nPRINT("Error: PURESOUND_HL_DELAY value is out of range \n");
            }
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND AEQ
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_INPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_AEQ_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_AEQ_OUTPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_BYPASS_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_AEQ_BYPASS_GAIN;
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND HPF
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HPF_FREQUENCY:
        {
            if(u32value < 4)
            {
                retType = SRS_PURESOUND_HPF_FREQUENCY;
            }
            else
            {
                AU_nPRINT("Error: API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HPF_FREQUENCY value is out of range \n");
            }
        }
        break;

        //---------------------------------------------------------------------------------
        // PURESOUND hash only
        //---------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_INPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_INPUT_GAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_OUTPUT_GAIN_FXP24:
        {
            retType = SRS_PURESOUND_OUTPUT_GAIN;
        }
        break;

        default:
            break;
    }

    return retType;
}

static MS_BOOL AU_CUS_SetPlayCmdByAdecSource(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    API_AUDIO_CUSTOMER_ADEC_INPUT adecSrc = API_AUDIO_CUSTOMER_ADEC_INPUT_INVALID;
    MMA_AUDIO_CONTROL cmd = MMA_STOP;
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            adecSrc = pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            adecSrc = pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            adecSrc = pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect;
        }
        break;

        default:
        break;
    }

    switch(adecSrc)
    {
        case API_AUDIO_CUSTOMER_ADEC_INPUT_DTV:
        case API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI:
        {
            cmd = MMA_PLAY;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INPUT_MM:
        case API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP:
        {

            if(((adecIndex == API_AUDIO_CUSTOMER_ADEC0) && (pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU))||
               ((adecIndex == API_AUDIO_CUSTOMER_ADEC1) && (pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)))
            {
                cmd = MMA_PLAY_FRAME_GS;
            }
            else
            {
                cmd = MMA_PLAY_FILE;
            }
        }
        break;

        default:
        break;
    }

    if( AUDIO_CHIP_TYPE >= API_AUDIO_CUSTOMER_CHIP_TYPE_2D1R &&  cmd == MMA_PLAY_FILE)
    {
        MApi_AUDIO_SetCommand(MSAPI_AUD_DVB_DECCMD_PLAYMM_FILE2);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID , Audio_ParamType_playControl, (MS_U32)cmd);
    }

    #if(CUSTOMIZED_INTERNAL_PATCH_SET_PLAY_CMD_BY_ADEC_SOURCE_DELAY)
    {
        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay);
    }
    #endif

    return TRUE;
}

static MS_BOOL AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM_INDEX fwm_index, API_AUDIO_CUSTOMER_FWM_INPUT fwm_input)
{
    AUDIO_MIX_VOL_TYPE VolType = PCM_VOL;
    MS_BOOL bATV_Mute = FALSE;

    AU_nDBG("[fwm_index = %d] [input_channel = 0x%x] \n", (unsigned int)fwm_index, (unsigned int)fwm_input);

    switch(fwm_index)
    {
        case API_AUDIO_CUSTOMER_FWM0:
        {
            switch(fwm_input)
            {
                case API_AUDIO_CUSTOMER_FWM_INPUT_CH5:
                {
                    VolType = GAME1_VOL;
                    if(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV)
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect != API_AUDIO_CUSTOMER_ADEC_INPUT_ATV||
                           pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay != API_AUDIO_CUSTOMER_UPPER_PLAY)
                        {
                            bATV_Mute = TRUE;
                        }
                    }
                }
                break;

                case API_AUDIO_CUSTOMER_FWM_INPUT_CH6:
                {
                    VolType = GAME2_VOL;
                    if(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV)
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect != API_AUDIO_CUSTOMER_ADEC_INPUT_ATV||
                           pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay != API_AUDIO_CUSTOMER_UPPER_PLAY)
                        {
                            bATV_Mute = TRUE;
                        }
                    }
                }
                break;

                case API_AUDIO_CUSTOMER_FWM_INPUT_CH8:
                {
                    VolType = PCM_VOL;
                }
                break;

                default:
                    break;
            }

            pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input] =
                                                                           (!pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[fwm_input])      |
                                                                           (pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[fwm_input]) |
                                                                           (pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[fwm_input])|
                                                                           (bATV_Mute);

            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[%-4d]           = 0x%x] \n",(unsigned int)fwm_input,  (unsigned int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]          );
            AU_nDBG("[!pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[%-4d]              = 0x%x] \n",(unsigned int)fwm_input,  (unsigned int)(!pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[fwm_input])           );
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[%-4d]         = 0x%x] \n",(unsigned int)fwm_input,  (unsigned int)(pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[fwm_input])      );
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[%-4d] = 0x%x] \n",(unsigned int)fwm_input,  (unsigned int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[fwm_input]);
            AU_nDBG("[bATV_Mute                                                                       = 0x%x] \n",(unsigned int)bATV_Mute);

            MApi_AUDIO_SetMixModeMute(E_AUDIO_INFO_GAME_IN, VolType, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM1:
        {
            //not support yet
        }
        break;

        case API_AUDIO_CUSTOMER_FWM2:
        {
            //not support yet
        }
        break;

        default:
            break;
    }

    //for MS12, can't mute input channel for Dolby content.
    switch(fwm_input)
    {
        case API_AUDIO_CUSTOMER_FWM_INPUT_CH5:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect)
            {
                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE, &pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]);
                }
                break;

                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE, &pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]);
                }
                break;

                default:
                    break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_FWM_INPUT_CH6:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect)
            {
                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE, &pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]);
                }
                break;

                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE, &pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_final_bMute[fwm_input]);
                }
                break;

                default:
                    break;
            }
        }
        break;

        default:
            break;
    }

    return TRUE;
}

static void AU_CUS_ESBufInit(AUDIO_DEC_ID DecID)
{
    St_Audio_Buf_Info *pESBufInfo;

    switch(DecID)
    {
        case AU_DEC_ID1:
        {
            pESBufInfo = &ES1BufInfo;
        }
        break;

        case AU_DEC_ID3:
        {
            pESBufInfo = &ES3BufInfo;
        }
        break;

        case AU_DEC_ID2:
        default:
        {
            AU_nPRINT("[Error] [%s] [Invalid DecID: %d] \n", __FUNCTION__, DecID);
            pESBufInfo = &ES1BufInfo;
        }
        break;
    }

    MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_UNI_ES_Base, &(pESBufInfo->u32BufStartAddr_P));
    MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_UNI_ES_Size, &(pESBufInfo->u32BufSize));
    pESBufInfo->u32BufEndAddr_P = pESBufInfo->u32BufStartAddr_P + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    pESBufInfo->u32BufRptr_P = pESBufInfo->u32BufStartAddr_P;

    pESBufInfo->u32BufStartAddr_V = MsOS_MPool_PA2KSEG1(pESBufInfo->u32BufStartAddr_P);
    pESBufInfo->u32BufEndAddr_V = pESBufInfo->u32BufStartAddr_V + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
    pESBufInfo->u32BufRptr_V = pESBufInfo->u32BufStartAddr_V;
}

static void AU_CUS_ExternalBufInit(void )
{
    //Eric.C: need to request one clip memory from system
    #if 0
    {
        if(!(MAdp_MPool_GetBlockVa( E_SYS_MMAP_AUDIO_CLIP_MEM, &(ExternalBufInfo.u32BufStartAddr_V) , &(ExternalBufInfo.u32BufSize) )))
        {
            AU_nPRINT("[Error] [%s] [Fail to get external buffer] \n", __FUNCTION__);
            return;
        }
    }
    #else
    {
        ExternalBufInfo.u32BufStartAddr_P = 0x8C600000;
        ExternalBufInfo.u32BufSize = 0x200000;
    }
    #endif
    ExternalBufInfo.u32BufEndAddr_P = ExternalBufInfo.u32BufStartAddr_P + ExternalBufInfo.u32BufSize;
    ExternalBufInfo.u32BufWptr_P = ExternalBufInfo.u32BufStartAddr_P;
    ExternalBufInfo.u32BufRptr_P = ExternalBufInfo.u32BufStartAddr_P;

    ExternalBufInfo.u32BufStartAddr_V = MsOS_MPool_PA2KSEG1(ExternalBufInfo.u32BufStartAddr_P);
    ExternalBufInfo.u32BufEndAddr_V = ExternalBufInfo.u32BufStartAddr_V + ExternalBufInfo.u32BufSize;
    ExternalBufInfo.u32BufWptr_V = ExternalBufInfo.u32BufStartAddr_V;
    ExternalBufInfo.u32BufRptr_V = ExternalBufInfo.u32BufStartAddr_V;
}

void AU_CUS_FeedingES(void* pAddr, MS_U32 u32Size, AUDIO_DEC_ID DecID, St_Audio_Buf_Info *pESBufInfo)
{
    //AU_nPRINT("[AUDIO][%s] [%d] [ES_Wptr_V = 0x%X] [ES_Wptr_P = 0x%X]\n", __FUNCTION__, __LINE__, (unsigned int)pESBufInfo->u32BufWptr_V, (unsigned int)pESBufInfo->u32BufWptr_P);
    memcpy((void *)(pESBufInfo->u32BufWptr_V), pAddr, u32Size);
    pESBufInfo->u32BufWptr_V += u32Size;
    pESBufInfo->u32BufWptr_P += u32Size;
    MsOS_FlushMemory();
    MsOS_Sync();
    MApi_AUDIO_MM2_inputAesFinished(DecID, u32Size, FALSE, 0);

    if( (pESBufInfo->u32BufWptr_V == pESBufInfo->u32BufEndAddr_V) && (pESBufInfo->u32BufWptr_P == pESBufInfo->u32BufEndAddr_P) )
    {
        pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
        pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    }
}

static void AU_CUS_ClipDecoderBufInit(AUDIO_DEC_ID DecID)
{
    MApi_AUDIO_MM2_initAesInfo(DecID);

    AU_CUS_ESBufInit(DecID);

    AU_CUS_ExternalBufInit();

    switch(DecID)
    {
        case AU_DEC_ID1:
        {
            pClipDecESBufInfo = &ES1BufInfo;
        }
        break;

        case AU_DEC_ID3:
        {
            pClipDecESBufInfo = &ES3BufInfo;
        }
        break;

        case AU_DEC_ID2:
        default:
            break;
    }

    pClipDecExtBufInfo = &ExternalBufInfo;
}

static void AU_CUS_ClipDecoderPlay(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo)
{
    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            /* Variable setting */
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec = clipInfo.clipType;
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;

            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
            {
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID, Audio_ParamType_playControl, MMA_PLAY_FRAME_GS);
            }
            else
            {
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID, Audio_ParamType_playControl, MMA_FREERUN);
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID, Audio_ParamType_playControl, MMA_PLAY_FILE);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            /* Variable setting */
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec = clipInfo.clipType;
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;

            if(pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
            {
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID, Audio_ParamType_playControl, MMA_PLAY_FRAME_GS);
            }
            else
            {
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID, Audio_ParamType_playControl, MMA_FREERUN);
                MApi_AUDIO_SetAudioParam2(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID, Audio_ParamType_playControl, MMA_PLAY_FILE);
            }
        }
        break;

        default:
            break;
    }
}

static void AU_CUS_ClipDecoderMonitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_ClipDecoderMonitor_bEnable)
    {
        if( (clipDecoderInfo.bIsStart == TRUE) && (clipDecoderInfo.bIsPause == FALSE) && (clipDecoderInfo.u32RepeatNum > 0) )
        {
            MS_U32 u32RemainingSize;
            u32RemainingSize = pClipDecExtBufInfo->u32BufWptr_V - pClipDecExtBufInfo->u32BufRptr_V;

            if(u32RemainingSize > 0)
            {
                AES_INFO clipDecESInfo = {0,};
                MApi_AUDIO_MM2_checkAesInfo(clipDecoderInfo.decID, &clipDecESInfo);
                //AU_nPRINT("[AUDIO][%s] [%d] [DecID: %u] [u32RemainingSize = 0x%X] [u32FreeSpace = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)clipDecoderInfo.decID, (unsigned int)u32RemainingSize, (unsigned int)clipDecESInfo.aes_freeSpace);

                if(u32RemainingSize <= clipDecESInfo.aes_freeSpace)
                {
                    AU_CUS_FeedingES((void*)(pClipDecExtBufInfo->u32BufRptr_V), u32RemainingSize, clipDecoderInfo.decID, pClipDecESBufInfo);
                    pClipDecExtBufInfo->u32BufRptr_V += u32RemainingSize;
                    //AU_nPRINT("[AUDIO][%s] [%d] [No remaining ES data] [Remaining repeat time: %u] \n", __FUNCTION__, __LINE__, (unsigned int)clipDecoderInfo.u32RepeatNum);
                }
                else
                {
                    if(clipDecESInfo.aes_freeSpace > 0)
                    {
                        //AU_nPRINT("[AUDIO][%s] [%d] [Feeding data] [u32BufWptr_V = 0x%X] [u32BufRptr_V = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)pClipDecExtBufInfo->u32BufWptr_V, (unsigned int)pClipDecExtBufInfo->u32BufRptr_V);
                        AU_CUS_FeedingES((void*)(pClipDecExtBufInfo->u32BufRptr_V), clipDecESInfo.aes_freeSpace, clipDecoderInfo.decID, pClipDecESBufInfo);
                        pClipDecExtBufInfo->u32BufRptr_V += clipDecESInfo.aes_freeSpace;
                    }
                }
            }
            else
            {
                MS_U32 u32PCMlevel = 0;
                static MS_U32 u32TimeOutCnt = 0;
                MApi_AUDIO_GetAudioInfo2(clipDecoderInfo.decID, Audio_infoType_pcmBuf_currLevel, &u32PCMlevel);
                //AU_nPRINT("[AUDIO][%s] [%d] [Wait PCM buffer(0x%X) empty] [Time-Out count: %u]\n", __FUNCTION__, __LINE__, (unsigned int)u32PCMlevel, (unsigned int)u32TimeOutCnt);

                //Wait all PCM data output from PCM buffer until time out
                if(u32PCMlevel == 0 && u32TimeOutCnt > 100)
                {
                    u32TimeOutCnt = 0;
                    clipDecoderInfo.u32RepeatNum --;
                    if(clipDecoderInfo.u32RepeatNum > 0)
                    {
                        // Reset ADEC
                        MApi_AUDIO_SetAudioParam2(clipDecoderInfo.decID, Audio_ParamType_playControl, MMA_STOP);
                        // Make sure R2 receives stop command
                        AU_CUS_Delay1MS(2);

                        // Init Buffer
                        AU_CUS_ClipDecoderBufInit(clipDecoderInfo.decID);
                        memset((void *)(pClipDecESBufInfo->u32BufStartAddr_V), 0, pClipDecESBufInfo->u32BufSize);

                        pClipDecExtBufInfo->u32BufWptr_V += clipDecoderInfo.u32Size;

                        //When AP call stop or pause, there is timing issue if AU_CUS_ClipDecoderMonitor already execute here.
                        //So check here again.
                        if( (clipDecoderInfo.bIsStart == TRUE) && (clipDecoderInfo.bIsPause == FALSE) )
                        {
                            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
                            {
                                MApi_AUDIO_SetAudioParam2(clipDecoderInfo.decID, Audio_ParamType_playControl, MMA_PLAY_FRAME_GS);
                            }
                            else
                            {
                                MApi_AUDIO_SetAudioParam2(clipDecoderInfo.decID, Audio_ParamType_playControl, MMA_PLAY_FILE);
                            }
                            //AU_nPRINT("[AUDIO][%s] [%d] [Play next clip with DecID(%d)] [Remaining repeat time: %u] \n", __FUNCTION__, __LINE__, (int)clipDecoderInfo.decID, (unsigned int)clipDecoderInfo.u32RepeatNum);
                        }
                        else
                        {
                            AU_nPRINT("[AUDIO][%s] [%d] [Can't play next clip] [bIsStart: %u] [bIsPause: %u]\n", __FUNCTION__, __LINE__, (unsigned int)clipDecoderInfo.bIsStart, (unsigned int)clipDecoderInfo.bIsPause);
                        }
                    }
                    else
                    {
                        MApi_AUDIO_SetAudioParam2(clipDecoderInfo.decID, Audio_ParamType_playControl, MMA_STOP);
                        clipDecoderInfo.bIsStart = FALSE;
                        pClipDecExtBufInfo->u32BufRptr_V = pClipDecExtBufInfo->u32BufStartAddr_V;
                        pClipDecExtBufInfo->u32BufWptr_V = pClipDecExtBufInfo->u32BufStartAddr_V;
                        if(madCallBack.pFunc_ClipDec != NULL)
                        {
                            madCallBack.pFunc_ClipDec(clipDecoderInfo.u8Sink);
                        }
                        //AU_nPRINT("[AUDIO][%s] [%d] [Clip decoder finish !!] \n", __FUNCTION__, __LINE__);
                    }
                }
                else
                {
                     u32TimeOutCnt ++;
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_ClipDecoderMonitor_Interval);
    }
}

/* MP3 Encoder Function */
static void AU_CUS_MP3EncCallBack(MS_U8 *pCopyBuffer, MS_U16 copyLenth)
{
    API_AUDIO_CUSTOMER_AENC_DATA mp3EncInfo;

    if(pAU_MP3EncDumpFile != NULL)
    {
        AU_CUS_FileWrite((void*)pCopyBuffer, sizeof(MS_U8) , copyLenth, pAU_MP3EncDumpFile);
    }
    else
    {
        AU_nPRINT("[Error] [%s] [please open MP3EncDump.mp3 at first] \n", __FUNCTION__);
    }

    if(firstGetEncodeTimeFlag == TRUE)
    {
        mp3EncInfo.pts = 0;
        encStartTime = MsOS_GetSystemTime();
        firstGetEncodeTimeFlag = FALSE;
    }
    else
    {
        mp3EncInfo.pts = (MS_U64)(((MS_U64)MsOS_GetSystemTime() - encStartTime + 90)*90);
    }

    mp3EncInfo.encFormat = API_AUDIO_CUSTOMER_AENC_ENCODE_MP3;
    mp3EncInfo.pData     = (MS_U8 *)pCopyBuffer;
    mp3EncInfo.dataLen   = copyLenth;
    mp3EncInfo.pRStart   = (MS_U8 *)pCopyBuffer;
    mp3EncInfo.pREnd     = mp3EncInfo.pRStart + copyLenth;
    #if 0
    AU_nPRINT("[AUDIO][mp3EncInfo.index   = 0x%x] \n", (unsigned int)mp3EncInfo.index);
    AU_nPRINT("[AUDIO][mp3EncInfo.pts     = %llu] \n", mp3EncInfo.pts);
    AU_nPRINT("[AUDIO][mp3EncInfo.pData   = 0x%x] \n", mp3EncInfo.pData);
    AU_nPRINT("[AUDIO][mp3EncInfo.dataLen = 0x%x] \n", (unsigned int)mp3EncInfo.dataLen);
    AU_nPRINT("[AUDIO][mp3EncInfo.pRStart = 0x%x] \n", mp3EncInfo.pRStart);
    AU_nPRINT("[AUDIO][mp3EncInfo.pREnd   = 0x%x] \n", mp3EncInfo.pREnd);
    #endif

    if(madCallBack.pFunc_AencMP3 != NULL)
    {
        madCallBack.pFunc_AencMP3(&mp3EncInfo);
    }

}

static void AU_CUS_MP3EncodeMonitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_MP3EncodeMonitor_bEnable)
    {
        if(pstAudioCustomerShmData->g_audio_customer_MP3_ENC_bEnable == TRUE)
        {
            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_lock(&AU_Customer_MP3Encode_mutex_lock);
            }
            #else //User Space
            {
                OS_OBTAIN_MUTEX(AU_Customer_MP3Encode_mutex_lock, MSOS_WAIT_FOREVER);
            }
            #endif

            memset((void *)pMP3EncBuffer, 0x00, MP3_REQUEST_BYTES);
            if(MApi_AUDIO_PCMCapture_Read(E_DEVICE2, (void *)pMP3EncBuffer, MP3_REQUEST_BYTES) == TRUE)
            {
                retryCounterMP3Encode = 0;

                if(madCallBack.pFunc_MP3Encode != NULL)
                {
                    madCallBack.pFunc_MP3Encode(pMP3EncBuffer, MP3_REQUEST_BYTES);
                }
            }
            else
            {
                retryCounterMP3Encode++;
                if (retryCounterMP3Encode > 10)
                {
                    AU_nPRINT("Warning: MP3 encode capture retry too much (0x%x) !!!!!\n", (unsigned int)retryCounterMP3Encode);
                }
            }

            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_unlock(&AU_Customer_MP3Encode_mutex_lock);
            }
            #else //User Space
            {
                OS_RELEASE_MUTEX(AU_Customer_MP3Encode_mutex_lock);
            }
            #endif
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval);
    }
}

static MS_BOOL AU_CUS_MP3EncodeInit(void *pCallBackFunc, AUDIO_CAPTURE_SOURCE_TYPE sourceType)
{
    madCallBack.pFunc_MP3Encode = pCallBackFunc;

    if(pCallBackFunc != NULL)
    {
        //alloc memory for MP3 encoded buffer
        pMP3EncBuffer = AU_CUS_MemoryAlloc(MP3_REQUEST_BYTES);

        if(pMP3EncBuffer == NULL)
        {
            AU_nPRINT("[pMP3EncBuffer cannot malloc]\n");
            return FALSE;
        }
    }
    else
    {
        AU_nPRINT("[pCallBackFunc is NULL] \n");
        return FALSE;
    }

    //Init PCM capture driver
    MApi_AUDIO_PCMCapture_Init(E_DEVICE2, sourceType);
    MApi_AUDIO_PCMCapture_Start(E_DEVICE2);

    return TRUE;
}

/* Initialize, STR */

/* Connect & Disconnect */
MS_BOOL AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect)
{
    AUDIO_INPUT_TYPE enSource = AUDIO_NULL_INPUT;
    AUDIO_SWITCH_GROUP enGroup = E_AUDIO_GROUP_INVALID;
    MS_BOOL bNeed_Set_CH_input = FALSE;

    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect = inputConnect;

            if(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC0)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC0);
                enGroup = E_AUDIO_GROUP_MAIN;
                bNeed_Set_CH_input = TRUE;
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC0)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC0);
                enGroup = E_AUDIO_GROUP_SUB;
                bNeed_Set_CH_input = TRUE;
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC0)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC0);
                enGroup = E_AUDIO_GROUP_SCART;
                bNeed_Set_CH_input = TRUE;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect = inputConnect;

            if(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC1)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC1);
                enGroup = E_AUDIO_GROUP_MAIN;
                bNeed_Set_CH_input = TRUE;
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC1)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC1);
                enGroup = E_AUDIO_GROUP_SUB;
                bNeed_Set_CH_input = TRUE;
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC1)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC1);
                enGroup = E_AUDIO_GROUP_SCART;
                bNeed_Set_CH_input = TRUE;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect = inputConnect;

            if(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV);
                enGroup = E_AUDIO_GROUP_MAIN;
                bNeed_Set_CH_input = TRUE;
                AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV);
                enGroup = E_AUDIO_GROUP_SUB;
                bNeed_Set_CH_input = TRUE;
                AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
            }
            if(pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect == API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV)
            {
                enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV);
                enGroup = E_AUDIO_GROUP_SCART;
                bNeed_Set_CH_input = TRUE;
            }
        }
        break;
        default:
            break;
    }

    if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC0)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect));
    }
    else if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC1)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect));
    }
    else if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC_ATV)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect));
    }

    if(bNeed_Set_CH_input)
    {
        AU_CUS_InputSwitch(enSource, enGroup);
    }

    return TRUE;
}

MS_BOOL AU_CUS_ADEC_Disconnect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect)
{
    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect = API_AUDIO_CUSTOMER_ADEC_INPUT_NONE;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect = API_AUDIO_CUSTOMER_ADEC_INPUT_NONE;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect = API_AUDIO_CUSTOMER_ADEC_INPUT_NONE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
        }
        break;
        default:
            break;
    }

    //let HDMI RX monitor alive when next HDMI Connect.
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;

    return TRUE;
}

MS_BOOL AU_CUS_ADC_Connect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)
{
    AU_nDBG("[currentConnect = 0x%x][portNum = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)portNum);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_ADC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADC0_Connect = portNum;
        }
        break;
        case API_AUDIO_CUSTOMER_ADC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADC1_Connect = portNum;
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_ADC_Disconnect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)
{
    AU_nDBG("[currentConnect = 0x%x][portNum = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)portNum);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_ADC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADC0_Connect = API_AUDIO_CUSTOMER_ADC_IN_PORT_INVALID;
        }
        break;
        case API_AUDIO_CUSTOMER_ADC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADC1_Connect = API_AUDIO_CUSTOMER_ADC_IN_PORT_INVALID;
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)
{
    AUDIO_INPUT_TYPE enSource = AUDIO_NULL_INPUT;
    AUDIO_SWITCH_GROUP enGroup = E_AUDIO_GROUP_INVALID;

    AU_nDBG("[currectChannel = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_CH5_SOUND:
        {
            enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(inputConnect);
            enGroup = E_AUDIO_GROUP_MAIN;
            pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect = inputConnect;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
            AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerChInputToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect));

            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT)
            {
                switch(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect)
                {
                    case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
                    case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
                    {
                        API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC;
                        AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                    }
                    break;

                    default:
                    {
                        API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX;
                        AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                    }
                    break;
                }
            }
            #endif
        }
        break;

        case API_AUDIO_CUSTOMER_CH6_SOUND:
        {
            enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(inputConnect);
            enGroup = E_AUDIO_GROUP_SUB;
            pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect = inputConnect;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
        }
        break;

        case API_AUDIO_CUSTOMER_CH7_SOUND:
        {
            enSource = AU_CUS_ConvertCustomerChInputToDriverInputType(inputConnect);
            enGroup = E_AUDIO_GROUP_SCART;
            pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect = inputConnect;
        }
        break;
        default:
            break;
    }

    AU_CUS_InputSwitch(enSource, enGroup);

    //AU_CUS_InputSwitch will change internal path setting, need to reset to customer's setting here.
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_I2S,      pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT0, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT1, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT2, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT3, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_SPDIF,    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_ARC, pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX,  pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect);

    return TRUE;
}

MS_BOOL AU_CUS_CH_Sound_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)
{
    AUDIO_INPUT_TYPE enSource = AUDIO_NULL_INPUT;
    AUDIO_SWITCH_GROUP enGroup = E_AUDIO_GROUP_INVALID;

    AU_nDBG("[currectChannel = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_CH5_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_NONE;
            enGroup = E_AUDIO_GROUP_MAIN;
        }
        break;

        case API_AUDIO_CUSTOMER_CH6_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_NONE;
            enGroup = E_AUDIO_GROUP_SUB;
        }
        break;

        case API_AUDIO_CUSTOMER_CH7_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect = API_AUDIO_CUSTOMER_CH_INPUT_NONE;
            enGroup = E_AUDIO_GROUP_SCART;
        }
        break;
        default:
            break;
    }

    enSource = AUDIO_NULL_INPUT;

    AU_CUS_InputSwitch(enSource, enGroup);

    //AU_CUS_InputSwitch will change internal path setting, need to reset to customer's setting here.
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_I2S,      pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT0, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT1, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT2, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT3, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_SPDIF,    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_ARC, pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_Connect);
    AU_CUS_SetDspInternalPath(API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX,  pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect);

    return TRUE;
}

MS_BOOL AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_FWM0:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[inputConnect] = TRUE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM1:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[inputConnect] = TRUE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM1, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM2:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[inputConnect] = TRUE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM2, inputConnect);
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_FW_MIXER_Disconnect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_FWM0:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[inputConnect] = FALSE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM1:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[inputConnect] = FALSE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM1, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM2:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[inputConnect] = FALSE;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM2, inputConnect);
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_SNDOUT_Connect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT *pConnet = NULL;

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_SOUNDOUT_I2S:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT0:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT1:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT2:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT3:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_SPDIF:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_ARC:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect;
        break;

        default:
            break;
    }

    if(pConnet != NULL)
    {
        *pConnet = inputConnect;
        AU_CUS_SetDspInternalPath(currentConnect, inputConnect);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

MS_BOOL AU_CUS_SNDOUT_Disconnect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    API_AUDIO_CUSTOMER_SOUNDOUT_INPUT *pConnet = NULL;

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_SOUNDOUT_I2S:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT0:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT1:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT2:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_LINEOUT3:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_SPDIF:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_ARC:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_Connect;
        break;

        case API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX:
            pConnet = &pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect;
        break;

        default:
            break;
    }

    if(pConnet != NULL)
    {
        *pConnet = API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_NULL;
        AU_CUS_SetDspInternalPath(currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_NULL);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

API_AUDIO_CUSTOMER_CH_SOUND AU_CUS_Mapping_ADEC_to_FWM_INPUT(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect)
{
    API_AUDIO_CUSTOMER_FWM_INPUT Ret = API_AUDIO_CUSTOMER_FWM_INPUT_INVALID;
    API_AUDIO_CUSTOMER_CH_INPUT  ch_input = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;

    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            ch_input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            ch_input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            ch_input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV;
        }
        break;

        default:
            break;
    }

    AU_nDBG("[ch_input = 0x%x] \n", (unsigned int)ch_input);

    if(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect == ch_input)
    {
        Ret = API_AUDIO_CUSTOMER_FWM_INPUT_CH5;
    }
    else if(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect == ch_input)
    {
        Ret = API_AUDIO_CUSTOMER_FWM_INPUT_CH6;
    }
    else if(pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect == ch_input)
    {
        Ret = API_AUDIO_CUSTOMER_FWM_INPUT_CH7;
    }
    else if(pstAudioCustomerShmData->g_audio_customer_CH8_Sound_Connect == ch_input)
    {
        Ret = API_AUDIO_CUSTOMER_FWM_INPUT_CH8;
    }

    AU_nDBG("[Ret = 0x%x] \n", (unsigned int)Ret);

    return Ret;
}

void AU_CUS_SetSourceInfo(AUDIO_SOURCE_INFO_TYPE eSourceType)
{
    AU_nDBG("[eSourceType = 0x%x] \n", (unsigned int)eSourceType);

    pstAudioCustomerShmData->g_audio_customer_AU_SetSourceInfo_eSourceType = eSourceType;

    MApi_AUDIO_SetSourceInfo(eSourceType);
}

void AU_CUS_InputSwitch(AUDIO_INPUT_TYPE enSource, AUDIO_SWITCH_GROUP enGroup)
{
    AU_nDBG("[enSource = 0x%x] [enGroup = 0x%x]\n", (unsigned int)enSource, (unsigned int)enGroup);

    pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enSource = enSource;
    pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enGroup  = enGroup;

    MApi_AUDIO_InputSwitch(enSource, enGroup);
}

/* Start & Stop */
MS_BOOL AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE audioType)
{
    AudioDecStatus_t stAudioDecStatus_t;

    AU_nDBG("[adecIndex = 0x%x] [audioType = 0x%x] \n", (unsigned int)adecIndex, (unsigned int)audioType);

    memset(&stAudioDecStatus_t, 0x00, sizeof(AudioDecStatus_t));

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            MApi_AUDIO_ReleaseDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID);

            stAudioDecStatus_t.bIsAD = FALSE;
            stAudioDecStatus_t.eAudFormat  = AU_CUS_ConvertCustomerCodecTypeToDriverDVBdecSystemType(audioType);
            stAudioDecStatus_t.eSourceType = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
            stAudioDecStatus_t.eGroup = E_CONNECT_MAIN; //define ADEC0 as main, can also work well
            stAudioDecStatus_t.eAudio_Force_ID = AUDIO_FORCE_ID1;

            pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverCodec = stAudioDecStatus_t.eAudFormat;
            pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID = MApi_AUDIO_OpenDecodeSystem(&stAudioDecStatus_t);
            MApi_AUDIO_GetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID, &stAudioDecStatus_t);
            MApi_AUDIO_SetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID, &stAudioDecStatus_t);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            MApi_AUDIO_ReleaseDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID);

            stAudioDecStatus_t.bIsAD = FALSE;
            stAudioDecStatus_t.eAudFormat  = AU_CUS_ConvertCustomerCodecTypeToDriverDVBdecSystemType(audioType);
            stAudioDecStatus_t.eSourceType = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect);
            stAudioDecStatus_t.eGroup = E_CONNECT_MAIN; //define ADEC1 as main, can also work well
            stAudioDecStatus_t.eAudio_Force_ID = AUDIO_FORCE_ID3;

            pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverCodec = stAudioDecStatus_t.eAudFormat;
            pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID = MApi_AUDIO_OpenDecodeSystem(&stAudioDecStatus_t);
            MApi_AUDIO_GetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID, &stAudioDecStatus_t);
            MApi_AUDIO_SetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID, &stAudioDecStatus_t);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            MApi_AUDIO_ReleaseDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID);

            stAudioDecStatus_t.bIsAD = FALSE;
            stAudioDecStatus_t.eAudFormat  = AU_CUS_ConvertCustomerCodecTypeToDriverDVBdecSystemType(audioType);
            stAudioDecStatus_t.eSourceType = AU_CUS_ConvertCustomerADECInputSourceToDriverSourceInfoType(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect);
            stAudioDecStatus_t.eGroup = E_CONNECT_MAIN; //define ADEC_ATV as main, can also work well
            stAudioDecStatus_t.eAudio_Force_ID = AUDIO_FORCE_ID2;

            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType = stAudioDecStatus_t.eAudFormat;
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID = MApi_AUDIO_OpenDecodeSystem(&stAudioDecStatus_t);
            MApi_AUDIO_GetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID, &stAudioDecStatus_t);
            MApi_AUDIO_SetDecodeSystem(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID, &stAudioDecStatus_t);
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_StartDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;
    MS_U8 hdmi_rx_npcm_type = 0;
    MS_U8 hdmi_rx_pcm_type = 0;
    MS_BOOL check_hdmi_rx = FALSE;
    MS_BOOL bDec = FALSE;

    AU_nDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    //for SPDIF/HDMI output, need set to original mode before ES Play
    AU_CUS_SPDIF_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);
    AU_CUS_HDMI_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;

            hdmi_rx_npcm_type = AU_HDMI_MAIN_NPCM;
            hdmi_rx_pcm_type = AU_HDMI_MAIN_PCM;
            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
            {
                check_hdmi_rx = TRUE;
            }
            else
            {
                check_hdmi_rx = FALSE;
            }

            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverCodec != MSAPI_AUD_DVB_NONE &&
               pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverCodec != MSAPI_AUD_DVB_INVALID)
            {
                bDec = TRUE;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;

            hdmi_rx_npcm_type = AU_HDMI_SUB_NPCM;
            hdmi_rx_pcm_type = AU_HDMI_SUB_PCM;
            if(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
            {
                check_hdmi_rx = TRUE;
            }
            else
            {
                check_hdmi_rx = FALSE;
            }

            if(pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverCodec != MSAPI_AUD_DVB_NONE &&
               pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverCodec != MSAPI_AUD_DVB_INVALID)
            {
                bDec = TRUE;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;

            if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType == MSAPI_AUD_ATV_BTSC)
            {
                MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_SET_PLAY,0,0);
            }
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
            return TRUE;
        }
        break;

        default:
        {
            hdmi_rx_npcm_type = 0;
            hdmi_rx_pcm_type = 0;
            check_hdmi_rx = FALSE;
        }
        break;
    }

    if(check_hdmi_rx) /* Set HDMI_RX for HDMI ES input decode*/
    {
        if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff == TRUE)
        {
            if ((pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_AC3) ||
                (pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_AAC) ||
                (pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_DTS))
            {
                MApi_AUDIO_HDMI_RX_SetNonpcm(hdmi_rx_npcm_type);
            }
            else if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_PCM)
            {
                MApi_AUDIO_HDMI_RX_SetNonpcm(hdmi_rx_pcm_type);
            }
        }
    }
    else
    {
         if(bDec)
        {
            /* Start decode */
            AU_CUS_SetPlayCmdByAdecSource(adecIndex);
        }
    }

    AU_nDBG("[hdmi_rx_npcm_type = %-4d]\n", (unsigned int)hdmi_rx_npcm_type);
    AU_nDBG("[hdmi_rx_pcm_type  = %-4d]\n", (unsigned int)hdmi_rx_pcm_type);
    AU_nDBG("[check_hdmi_rx     = %-4d]\n", (unsigned int)check_hdmi_rx);
    AU_nDBG("[bDec              = %-4d]\n", (unsigned int)bDec);

    #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE)
    {
        #ifdef CONFIG_MBOOT //mboot
        {
            //do nothing in mboot.
        }
        #else
        {
            if(bDec)
            {
                if( AUDIO_CHIP_TYPE >= API_AUDIO_CUSTOMER_CHIP_TYPE_2D1R)
                {
                    MApi_AUDIO_SetCommand(MMA_BROWSE);
                }
                else
                {
                    MApi_AUDIO_SetAudioParam2(DecID , Audio_ParamType_playControl, (MS_U32)MMA_BROWSE);
                }
                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex = adecIndex;
                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_bEnable = TRUE;
            }
        }
        #endif
    }
    #endif

    return TRUE;
}

MS_BOOL AU_CUS_StopDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay = API_AUDIO_CUSTOMER_UPPER_STOP;

            #if(CUSTOMIZED_INTERNAL_PATCH_AVOID_ADEC_STOP_POP_NOISE)
            {
                AU_nDBG("\n");
                AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(adecIndex, pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time);
            }
            #endif

            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_MM ||
               pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP)
            {
                MApi_AUDIO_SetAudioParam2(DecID , Audio_ParamType_playControl, (MS_U32)MMA_STOP);
            }
            else
            {
                MApi_AUDIO_SetDecodeCmd(DecID, MSAPI_AUD_DVB_DECCMD_STOP);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay = API_AUDIO_CUSTOMER_UPPER_STOP;

            #if(CUSTOMIZED_INTERNAL_PATCH_AVOID_ADEC_STOP_POP_NOISE)
            {
                AU_nDBG("\n");
                AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(adecIndex, pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time);
            }
            #endif

            if(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_MM ||
               pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP)
            {
                MApi_AUDIO_SetAudioParam2(DecID , Audio_ParamType_playControl, (MS_U32)MMA_STOP);
            }
            else
            {
                MApi_AUDIO_SetDecodeCmd(DecID, MSAPI_AUD_DVB_DECCMD_STOP);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay = API_AUDIO_CUSTOMER_UPPER_STOP;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
            if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType == MSAPI_AUD_ATV_BTSC)
            {
                MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_SET_STOP,0,0);
            }
        }
        break;

        default:
        break;
    }

    #if(R2_SUPPORT_MS12_PCM_RENDER_ALWAYS_ENABLE && CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE)
    {
        if( pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec == API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass ||
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec == API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass )
        {
            AU_nDBG("\n");
            AU_CUS_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_PCM);
            AU_CUS_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM);
        }
        else
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_STB_HDMI_TX)
            {
                AU_nDBG("\n");

                //Recover previous HDMI output type settings
                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = FALSE;
                AU_CUS_HDMI_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType);
            }
            #endif

            #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_TV_HDMI_ARC)
            {
                AU_nDBG("\n");

                //Recover previous SPDIF output type settings
                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = FALSE;
                AU_CUS_SPDIF_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);
            }
            #endif
        }
    }
    #else
    {
        AU_nDBG("\n");

        //for SPDIF/HDMI output, need change to PCM after ES Stop decoding
        AU_CUS_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_PCM);
        AU_CUS_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM);
    }
    #endif

    return TRUE;
}

MS_BOOL AU_CUS_PauseDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PAUSE;

            #if(CUSTOMIZED_INTERNAL_PATCH_AVOID_ADEC_PAUSE_POP_NOISE)
            {
                AU_nDBG("\n");
                AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(adecIndex, pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time);
            }
            #endif

            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, (MS_U32)MMA_PAUSE);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PAUSE;

            #if(CUSTOMIZED_INTERNAL_PATCH_AVOID_ADEC_PAUSE_POP_NOISE)
            {
                AU_nDBG("\n");
                AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(adecIndex, pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time);
            }
            #endif

            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, (MS_U32)MMA_PAUSE);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PAUSE;

            if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType == MSAPI_AUD_ATV_BTSC)
            {
                MApi_AUDIO_SetCommand(MSAPI_AUD_DVB2_DECCMD_STOP);
            }
        }
        break;

        default:
        break;
    }

    #if(CUSTOMIZED_INTERNAL_PATCH_PAUSE_DECODING_DELAY)
    {
        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_CUS_PauseDecoding_Delay);
    }
    #endif

    return TRUE;
}

/* SPDIF */
MS_BOOL AU_CUS_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_MODE eSPDIFMode)
{
    MS_U8 spdif_mode = 0;
    Digital_Out_Device_Capability_t Device_Capability;

    AU_nDBG("[eSPDIFMode = 0x%x] \n", (unsigned int)eSPDIFMode);

    #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE && CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_TV_HDMI_ARC)
    {
        //Need force DDP_71 bypass, and avoid other cmd from upper.
        if(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream)
        {
            switch(eSPDIFMode)
            {
                case API_AUDIO_CUSTOMER_SPDIF_TX_PCM:
                case API_AUDIO_CUSTOMER_SPDIF_TX_BYPASS:
                {
                    AU_nDBG("\n");
                    //do nothing
                }
                break;

                case API_AUDIO_CUSTOMER_SPDIF_TX_AUTO:
                case API_AUDIO_CUSTOMER_SPDIF_TX_TRANSCODE:
                case API_AUDIO_CUSTOMER_SPDIF_TX_DD:
                {
                    AU_nDBG("\n");
                    return TRUE;
                }
                break;

                default:
                {
                    AU_nDBG("\n");
                    //do nothing
                }
                break;
            }
        }
    }
    #endif

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_DriverOutputType = eSPDIFMode;

    switch(eSPDIFMode)
    {
        case API_AUDIO_CUSTOMER_SPDIF_TX_PCM:
        {
            spdif_mode = SPDIF_OUT_PCM;
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_TX_AUTO:
        case API_AUDIO_CUSTOMER_SPDIF_TX_DD:
        {
            spdif_mode = SPDIF_OUT_AUTO;
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_TX_BYPASS:
        {
            spdif_mode = SPDIF_OUT_BYPASS;
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_TX_TRANSCODE:
        {
            spdif_mode = SPDIF_OUT_TRANSCODE;
        }
        break;

        default:
        {
            spdif_mode = SPDIF_OUT_PCM;
        }
        break;
    }

    memset((void *)&Device_Capability, 0, sizeof(Device_Capability));

    if(eSPDIFMode == API_AUDIO_CUSTOMER_SPDIF_TX_DD)
    {
        Device_Capability.support_codec = 0;
        MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DDP, &Device_Capability);
    }
    else
    {
        Device_Capability.support_codec = 1;
        MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DDP, &Device_Capability);
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_SPDIF_TX_SetOutputType_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_AUDIO_SPDIF_SetMode(spdif_mode);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #endif

    return TRUE;
}

void AU_CUS_SPDIF_TX_Monitor(void)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_SPDIF_TX_SetOutputType_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_Audio_SPDIF_Monitor();

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #endif
}

/* HDMI */
MS_BOOL AU_CUS_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE eHDMIMode)
{
#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    AU_nDBG("[eHDMIMode = 0x%x] \n", (unsigned int)eHDMIMode);

    #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE && CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_STB_HDMI_TX)
    {
        //Need force DDP_71 bypass, and avoid other cmd from upper.
        if(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream)
        {
            switch(eHDMIMode)
            {
                case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM:
                {
                    AU_nDBG("\n");
                    //do nothing
                }
                break;

                case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM:
                {
                    AU_nDBG("\n");
                    return TRUE;
                }
                break;

                case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3_BYPASS:
                {
                    AU_nDBG("\n");
                    //do nothing
                }
                break;

                case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3:
                {
                    AU_nDBG("\n");
                    return TRUE;
                }
                break;

                default:
                {
                    //do nothing
                }
                break;
            }
        }
    }
    #endif

    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_DriverOutputType = eHDMIMode;

    switch(eHDMIMode)
    {
        case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM:
        {
            AU_nDBG("\n");

            #if(UTPA_SUPPORT_M2S_MBOX_DDPE_ENCODE_CTRL && UTPA_SUPPORT_M2S_MBOX_MCU_HDMI_NONPCM_CTRL)
            {
                AU_nDBG("\n");
                AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0001, 0x0000);  //Disable Force MCU Control
            }
            #endif

            //step1: trun off AC3 bypass
            MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, FALSE, 0);
            AU_CUS_Delay1MS(10);

            //step2: trun on HDMI PCM
            MApi_AUDIO_HDMI_TX_SetMode(HDMI_OUT_PCM);
            AU_CUS_Delay1MS(10);
        }
        break;

        case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM:
        {
            AU_nDBG("\n");

            #if(UTPA_SUPPORT_M2S_MBOX_DDPE_ENCODE_CTRL && UTPA_SUPPORT_M2S_MBOX_MCU_HDMI_NONPCM_CTRL)
            {
                if( pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec == API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass ||
                    pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec == API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass )
                {
                    AU_nDBG("\n");
                    AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0001, 0x0000);  //Disable Force MCU Control
                }
                else
                {
                    AU_nDBG("\n");
                    AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0001, 0x0001);  //Enable Force MCU Control
                    AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0020, 0x0020);  //Enable Force MCU Control, NPCM Owner: SE-DSP
                }
            }
            #endif

            //step1: trun off AC3 bypass
            MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, FALSE, 0);
            AU_CUS_Delay1MS(10);

            //step2: trun on HDMI NPCM
            MApi_AUDIO_HDMI_TX_SetMode(HDMI_OUT_NONPCM);
            AU_CUS_Delay1MS(10);
        }
        break;

        case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3_BYPASS:
        {
            AU_nDBG("\n");

            #if(UTPA_SUPPORT_HDMI_TX_OUT_BYPASS)
            {
                #if(UTPA_SUPPORT_M2S_MBOX_DDPE_ENCODE_CTRL && UTPA_SUPPORT_M2S_MBOX_MCU_HDMI_NONPCM_CTRL)
                {
                    AU_nDBG("\n");
                    AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0001, 0x0000);  //Disable Force MCU Control
                }
                #endif

                //step1: trun off AC3 bypass
                MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, FALSE, 0);
                AU_CUS_Delay1MS(10);

                //step3: trun on HDMI bypass
                MApi_AUDIO_HDMI_TX_SetMode(HDMI_OUT_BYPASS);
            }
            #else //(Same flow as API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM)
            {
                //step1: trun off AC3 bypass
                MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, FALSE, 0);
                AU_CUS_Delay1MS(10);

                //step2: trun on HDMI NPCM
                MApi_AUDIO_HDMI_TX_SetMode(HDMI_OUT_NONPCM);
                AU_CUS_Delay1MS(10);
            }
            #endif
        }
        break;

        case API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3:
        {
            AU_nDBG("\n");

            #if(UTPA_SUPPORT_M2S_MBOX_DDPE_ENCODE_CTRL && UTPA_SUPPORT_M2S_MBOX_MCU_HDMI_NONPCM_CTRL)
            {
                AU_nDBG("\n");
                AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0001, 0x0001);  //Enable Force MCU Control
                AU_CUS_WriteAbsMaskReg(M2S_MBOX_MCU_HDMI_NONPCM_CTRL, 0x0020, 0x0020);  //Enable Force MCU Control, NPCM Owner: SE-DSP
            }
            #endif

            //step1: trun on HDMI NPCM
            MApi_AUDIO_HDMI_TX_SetMode(HDMI_OUT_NONPCM);
            AU_CUS_Delay1MS(10);

            //step2: trun on AC3 bypass
            MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, TRUE, 0);
            AU_CUS_Delay1MS(10);
        }
        break;

        default:
        {
            AU_nDBG("\n");

            MApi_AUDIO_HDMI_TX_SetMode((HDMI_TX_OUTPUT_TYPE)eHDMIMode);
            AU_CUS_Delay1MS(10);
        }
        break;
    }
#endif
    return TRUE;
}

MS_BOOL AU_CUS_HDMI_RX_GetAudioMode(void)
{
    AUDIO_HDMI_RX_TYPE hdmi_rx_codec_type = HDMI_RX_PCM;
    MS_BOOL bHDMI = FALSE;
    MS_BOOL bNonPCM = FALSE;

    bHDMI = MDrv_HDMI_IsHDMI_Mode();
    bNonPCM = MApi_AUDIO_HDMI_GetNonpcmFlag();

    if(bHDMI == TRUE)
    {
        #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
        {
            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_HDMI_MODE;
            if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI)
            {
                if(madCallBack.pFunc_HDMIMonitorEvent != NULL)
                {
                    madCallBack.pFunc_HDMIMonitorEvent(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_IS_HDMI, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI);
                }
                pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI;
            }
        }
        #endif

        if(bNonPCM == TRUE)
        {
            #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
            {
                pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_NONPCM;
                if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM)
                {
                    if(madCallBack.pFunc_HDMIMonitorEvent != NULL)
                    {
                        madCallBack.pFunc_HDMIMonitorEvent(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_IS_NONPCM, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM);
                    }
                    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM;
                }
            }
            #endif

            hdmi_rx_codec_type = MApi_AUDIO_HDMI_RX_GetNonPCM();
            switch (hdmi_rx_codec_type)
            {
                case HDMI_RX_DD:
                {
                     pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_AC3;

                     #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                     {
                         pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_DD;
                     }
                     #endif
                }
                break;

                case HDMI_RX_DDP:
                {
                     pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_AC3;

                     #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                     {
                         pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_DDP;
                     }
                     #endif
                }
                break;

                case HDMI_RX_DTS:
                {
                     pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_DTS;

                     #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                     {
                         pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_DTS;
                     }
                     #endif
                }
                break;

                case HDMI_RX_DP:
                {
                     pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_AAC;

                     #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                     {
                         pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_DP;
                     }
                     #endif
                }
                break;

                case HDMI_RX_PCM:
                {
                     pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_PCM;

                     #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                     {
                         pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_PCM;
                     }
                     #endif
                }
                break;

                case HDMI_RX_Other:
                default:
                {
                    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;

                    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                    {
                        pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_OTHER;
                    }
                    #endif
                }
                break;
            }

            #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
            {
                if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_CodecType)
                {
                    if(madCallBack.pFunc_HDMIMonitorEvent != NULL)
                    {
                        madCallBack.pFunc_HDMIMonitorEvent(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_CODEC_CHANGE, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType);
                    }
                    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_CodecType = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_CodecType;
                }
            }
            #endif
        }
        else
        {
            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_PCM;

            #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
            {
                pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_PCM;
                if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM)
                {
                    if(madCallBack.pFunc_HDMIMonitorEvent != NULL)
                    {
                        madCallBack.pFunc_HDMIMonitorEvent(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_IS_NONPCM, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM);
                    }
                    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsPCM = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsPCM;
                }
            }
            #endif
        }
    }
    else
    {
        pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_DVI;

        #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
        {
            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI = API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO_DVI_MODE;
            if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI)
            {
                if(madCallBack.pFunc_HDMIMonitorEvent !=NULL)
                {
                    madCallBack.pFunc_HDMIMonitorEvent(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_IS_HDMI, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI);
                }
                pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Previous_IsHDMI = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Monitr_Event_Current_IsHDMI;
            }
        }
        #endif
    }

    AU_nThreadDBG("[pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type);

    return TRUE;
}

void AU_CUS_HDMI_RX_Monitor(void)
{
    #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
    {
        API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
        API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_INVALID;
        MS_U32 tmpTime = 0;
        MS_U32 TimeDiff = 0;
        MS_U32 debounce_state = 0;

        while(1)
        {
            if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff == TRUE)
            {
                if( (pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI) ||
                    (pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI) )
                {
                    if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
                    {
                        adecIndex = API_AUDIO_CUSTOMER_ADEC0;
                    }
                    else if(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
                    {
                        adecIndex = API_AUDIO_CUSTOMER_ADEC1;
                    }

                    AU_CUS_HDMI_RX_GetAudioMode();
                    if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type != pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type)
                    {
                        #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT)
                        {
                            if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_PCM)
                            {
                                if(debounce_state == 0)
                                {
                                    tmpTime = MsOS_GetSystemTime();
                                    debounce_state = 1;
                                    TimeDiff = 0;
                                }
                                else
                                {
                                    TimeDiff = MsOS_GetSystemTime() - tmpTime;
                                }

                                if(TimeDiff >= pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms)
                                {
                                    if( API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX != (API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select)
                                    {
                                        metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX;
                                        AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                                    }
                                }
                            }
                            else
                            {
                                if( API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC != (API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select)
                                {
                                    metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC;
                                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                                }
                            }
                        }
                        #endif

                        if((pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type != API_AUDIO_CUSTOMER_CODEC_TYPE_PCM) ||
                           (TimeDiff >= pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms))
                        {
                            /* set codec type */
                            AU_CUS_SetCodecType(adecIndex, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type);

                            /* Start decode */
                            AU_CUS_StartDecoding(adecIndex);

                            debounce_state = 0;
                            TimeDiff = 0;

                            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type;
                        }
                    }
                    else
                    {
                        debounce_state = 0;
                    }
                }
                else
                {
                    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;
                }

                if(debounce_state > 0)
                {
                    if((pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms - TimeDiff) > pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval)
                    {
                        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval);
                    }
                    else
                    {
                        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms - TimeDiff);
                    }
                }
                else
                {
                    AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval);
                }
            }
            else
            {
                AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval);
            }
        }
    }
    #else
    {
        API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
        API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_INVALID;
        AU_UNUSED(metadata_Select);

        if( (pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI) ||
            (pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI) )
        {
            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
            {
                adecIndex = API_AUDIO_CUSTOMER_ADEC0;
            }
            else if(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
            {
                adecIndex = API_AUDIO_CUSTOMER_ADEC1;
            }

            AU_CUS_HDMI_RX_GetAudioMode();

            if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type)
            {
                #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT)
                {
                    if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type == API_AUDIO_CUSTOMER_CODEC_TYPE_PCM)
                    {
                        if( API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX != (API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select)
                        {
                            metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DMX;
                            AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                        }
                    }
                    else
                    {
                        if( API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC != (API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select)
                        {
                            metadata_Select = API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT_DEC;
                            AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT, &metadata_Select);
                        }
                    }
                }
                #endif

                return;
            }

            /* set codec type */
            AU_CUS_SetCodecType(adecIndex, pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type);

            /* Start decode */
            AU_CUS_StartDecoding(adecIndex);

            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type;
        }
        else
        {
            pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;
        }
    }
    #endif
}

void AU_CUS_HDMI_TX_Monitor(void)
{
#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    if(pstAudioCustomerShmData->g_audio_customer_Chip_Platform == API_AUDIO_CUSTOMER_CHIP_PLATFORM_STB)
    {
        static AUDIO_FS_TYPE _stCurSampleType = AUDIO_FS_NONE;
        static HDMI_TX_OUTPUT_TYPE _stCurHDMIType = HDMI_OUT_PCM;
        static HDMITX_HDCP_STATUS _stCurHDMITx_HDCP_Status = E_HDCP_FAIL;

        MS_BOOL hdmi_tx_en;
        AUDIO_FS_TYPE fs_type;
        HDMI_TX_OUTPUT_TYPE outType;
        HDMITX_AUDIO_FREQUENCY hreq = HDMITX_AUDIO_FREQ_NO_SIG;
        HDMITX_AUDIO_CODING_TYPE htype = HDMITX_AUDIO_PCM;
        HDMITX_HDCP_STATUS HDCP_Status = E_HDCP_FAIL;

        MApi_AUDIO_HDMI_Tx_GetStatus(&hdmi_tx_en, &fs_type, &outType);
        HDCP_Status = MApi_HDMITx_GetHDCPStatus();

        if(hdmi_tx_en)
        {
            if( (_stCurSampleType == fs_type) && (_stCurHDMIType == outType) && (_stCurHDMITx_HDCP_Status == HDCP_Status) )
            {
                return;
            }
            else
            {
                _stCurSampleType = fs_type;
                _stCurHDMIType = outType;
                _stCurHDMITx_HDCP_Status = HDCP_Status;

                AU_nPRINT("[hdmi_tx_en  = %-4d] \n", (int)hdmi_tx_en);
                AU_nPRINT("[fs_type     = %-4d] \n", (int)fs_type);
                AU_nPRINT("[outType     = %-4d] \n", (int)outType);
                AU_nPRINT("[HDCP_Status = %-4d] \n", (int)HDCP_Status);
            }

            if(outType == HDMI_OUT_NONPCM)
            {
                htype = HDMITX_AUDIO_NONPCM;
                switch(fs_type)
                {
                    case AUDIO_FS_32KHZ:
                    {
                        hreq = HDMITX_AUDIO_32K;
                    }
                    break;

                    case AUDIO_FS_44KHZ:
                    {
                        hreq = HDMITX_AUDIO_44K;
                    }
                    break;

                    case AUDIO_FS_176KHZ:
                    {
                        hreq = HDMITX_AUDIO_176K;
                    }
                    break;

                    case AUDIO_FS_192KHZ:
                    {
                        hreq = HDMITX_AUDIO_192K;
                    }
                    break;

                    default:
                    case AUDIO_FS_48KHZ:
                    {
                        hreq = HDMITX_AUDIO_48K;
                    }
                    break;
                }
            }
            else
            {
                htype = HDMITX_AUDIO_PCM;
                hreq = HDMITX_AUDIO_48K; //for PCM mode always SRC to 48K
            }
            AU_nPRINT("[Hdmx Tx:%-4d, %-4d] \n", hreq, htype);

            if(HDCP_Status != E_HDCP_FAIL)
            {
                MApi_HDMITx_SetAudioOnOff(TRUE);
            }
            else
            {
                MApi_HDMITx_SetAudioOnOff(FALSE);
            }

            #if(UTPA_SUPPORT_HDMI_TX_STATUS)
            {
                MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_HDMITx_Status, (MS_U32)outType, (MS_U32)hreq);
            }
            #endif

            MApi_HDMITx_SetAudioFrequency(hreq);
            MApi_HDMITx_SetAudioConfiguration(hreq, HDMITX_AUDIO_CH_2, htype);
            MApi_HDMITx_SetAudioSourceFormat(HDMITX_AUDIO_FORMAT_PCM);
        }
    }
#endif
}

/* ATV */
void AU_CUS_CheckATVSoundMode(void)
{
    AUDIOMODE_TYPE eDetectedAudioMode;

    if( TRUE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_MONO) )
    {
        eDetectedAudioMode = E_AUDIOMODE_MONO;
    }
    else
    {
        eDetectedAudioMode = (AUDIOMODE_TYPE)MApi_AUDIO_SIF_GetSoundMode();
    }

    if(eDetectedAudioMode == E_AUDIOMODE_INVALID)
    {
        return;
    }

    if(SIF_AudioMode == eDetectedAudioMode)
    {
        MApi_AUDIO_SIF_SetSoundMode(SIF_AudioMode);
        return;
    }

    if(((SIF_AudioMode == E_AUDIOMODE_DUAL_A) || (SIF_AudioMode == E_AUDIOMODE_DUAL_B) || (SIF_AudioMode == E_AUDIOMODE_DUAL_AB))
            && ((eDetectedAudioMode == E_AUDIOMODE_DUAL_A) || (eDetectedAudioMode == E_AUDIOMODE_DUAL_B) || (eDetectedAudioMode == E_AUDIOMODE_DUAL_AB)))
    {
        MApi_AUDIO_SIF_SetSoundMode(SIF_AudioMode);
        return;
    }

    if(((SIF_AudioMode == E_AUDIOMODE_NICAM_DUAL_A) || (SIF_AudioMode == E_AUDIOMODE_NICAM_DUAL_B) || (SIF_AudioMode == E_AUDIOMODE_NICAM_DUAL_AB))
            && ((eDetectedAudioMode == E_AUDIOMODE_NICAM_DUAL_A) || (eDetectedAudioMode == E_AUDIOMODE_NICAM_DUAL_B) || (eDetectedAudioMode == E_AUDIOMODE_NICAM_DUAL_AB)))
    {
        MApi_AUDIO_SIF_SetSoundMode(SIF_AudioMode);
        return;
    }

    if((SIF_AudioMode == E_AUDIOMODE_FORCED_MONO) && (eDetectedAudioMode != E_AUDIOMODE_DUAL_A))
    {
        MApi_AUDIO_SIF_SetSoundMode(SIF_AudioMode);
        return;
    }

    SIF_AudioMode = eDetectedAudioMode;

    MApi_AUDIO_SIF_SetSoundMode(SIF_AudioMode);
}

void AU_CUS_SIF_Monitor(void)
{
    AUDIOSTATUS eCurrentAudioStatus;

    if(TRUE != MApi_AUDIO_SIF_GetAudioStatus(&eCurrentAudioStatus))
        return;

    if(SIF_AudioStatus != eCurrentAudioStatus)
    {
        SIF_AudioStatus = eCurrentAudioStatus;
        AU_CUS_Delay1MS(5);
        if(TRUE != MApi_AUDIO_SIF_GetAudioStatus(&eCurrentAudioStatus))
            return;

        //Check twice for speed up detection
        if(SIF_AudioStatus != eCurrentAudioStatus)
        {
            SIF_AudioStatus = eCurrentAudioStatus;
            return;
        }
    }

    //need touch.
    if(SIF_AudioStandard == E_AUDIOSTANDARD_L)
    {
        if(((SIF_AudioStatus & (E_STATE_AUDIO_PRIMARY_CARRIER | E_STATE_AUDIO_NICAM)) == (E_STATE_AUDIO_PRIMARY_CARRIER | E_STATE_AUDIO_NICAM))
                || ((SIF_AudioStatus & E_STATE_AUDIO_PRIMARY_CARRIER) == E_STATE_AUDIO_PRIMARY_CARRIER))
        {
            AU_CUS_CheckATVSoundMode();
        }
        return;
    }

    if((SIF_AudioStatus & (E_STATE_AUDIO_PRIMARY_CARRIER | E_STATE_AUDIO_NICAM)) == (E_STATE_AUDIO_PRIMARY_CARRIER | E_STATE_AUDIO_NICAM))
    {
        if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_NICAM))
        {
            switch(SIF_AudioStandard)
            {
                case E_AUDIOSTANDARD_BG:
                case E_AUDIOSTANDARD_BG_A2:
                    SIF_AudioStandard = E_AUDIOSTANDARD_BG_NICAM;
                    break;
                case E_AUDIOSTANDARD_DK:
                case E_AUDIOSTANDARD_DK1_A2:
                    SIF_AudioStandard = E_AUDIOSTANDARD_DK_NICAM;
                    break;
                default:
                    break;
            }
            MApi_AUDIO_SIF_SetStandard(SIF_AudioStandard);
            MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_NICAM);
            AU_CUS_Delay1MS(50);
        }
    }
    else if((SIF_AudioStatus &(E_STATE_AUDIO_SECONDARY_CARRIER | E_STATE_AUDIO_PILOT)) ==
            (E_STATE_AUDIO_SECONDARY_CARRIER | E_STATE_AUDIO_PILOT))
    {
        //Reload A2 while Pilot detected. C.P.Chen
        if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_A2))
        {
            if((SIF_AudioStatus & E_STATE_AUDIO_DK2) == E_STATE_AUDIO_DK2)
                SIF_AudioStandard = E_AUDIOSTANDARD_DK2_A2;
            else if((SIF_AudioStatus & E_STATE_AUDIO_DK3) == E_STATE_AUDIO_DK3)
                SIF_AudioStandard = E_AUDIOSTANDARD_DK3_A2;

            MApi_AUDIO_SIF_SetStandard(SIF_AudioStandard);
            MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_A2);

            AU_CUS_Delay1MS(50);
        }
    }
    else //if((SDK_eAudioStatus & E_STATE_AUDIO_PRIMARY_CARRIER) == E_STATE_AUDIO_PRIMARY_CARRIER)
    {
        switch(SIF_AudioStandard)
        {
            case E_AUDIOSTANDARD_BG_NICAM:
                MApi_AUDIO_SIF_SetStandard(E_AUDIOSTANDARD_BG_A2);
                SIF_AudioStandard = E_AUDIOSTANDARD_BG_A2;
                break;
            case E_AUDIOSTANDARD_DK_NICAM:
            case E_AUDIOSTANDARD_DK2_A2:
            case E_AUDIOSTANDARD_DK3_A2:
                MApi_AUDIO_SIF_SetStandard(E_AUDIOSTANDARD_DK1_A2);
                SIF_AudioStandard = E_AUDIOSTANDARD_DK1_A2;
                break;
            default:
                break;
        }

        if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_MONO))
        {
            MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_MONO);
        }
    }

    AU_CUS_CheckATVSoundMode();
}

/* Decoder */
MS_BOOL AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%X] [bOnOff = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    //If in PVR case, it should be free run
    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode = bOnOff;

            //PVR Case, set free run
            if(pstAudioCustomerShmData->g_audio_customer_ADEC0_TrickMode > API_AUDIO_CUSTOMER_TRICK_NONE)
            {
                bOnOff = FALSE;
                AU_nDBG("[adecIndex = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);
            }
        }
        break;
        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode = bOnOff;

            //PVR Case, set free run
            if(pstAudioCustomerShmData->g_audio_customer_ADEC1_TrickMode > API_AUDIO_CUSTOMER_TRICK_NONE)
            {
                bOnOff = FALSE;
                AU_nDBG("[adecIndex = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);
            }
        }
        break;

        default:
            break;
    }

    if(bOnOff)
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_AVSYNC);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_FREERUN);
    }

    return TRUE;
}

/* Common Decoder */
MS_S32 AU_CUS_COMMON_DECODER_Open(void * pData)
{
    AU_nDBG("\n");

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Open(pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Close(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Close(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Start(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Start(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Stop(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Stop(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Set(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        AUDIO_DECODER_Command_t cmd_t;
        strncpy(cmd_t.CmdName, Cmd.CmdName, strlen((char*)Cmd.CmdName) + 1);
        cmd_t.CmdLen = Cmd.CmdLen;

        return MApi_AUDIO_DECODER_Set(s32DeviceID, cmd_t, pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Get(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        AUDIO_DECODER_Command_t cmd_t;
        strncpy(cmd_t.CmdName, Cmd.CmdName, strlen((char*)Cmd.CmdName) + 1);
        cmd_t.CmdLen = Cmd.CmdLen;

        return MApi_AUDIO_DECODER_Get(s32DeviceID, cmd_t, pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_U32 AU_CUS_COMMON_DECODER_Read(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)
{
    AU_nDBG("[s32DeviceID = %ld] [u32Size = 0x%x] \n", (signed long)s32DeviceID, (unsigned int)u32Size);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Read(s32DeviceID, pBuf, u32Size);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_U32 AU_CUS_COMMON_DECODER_Write(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)
{
    AU_nDBG("[s32DeviceID = %ld] [u32Size = 0x%x] \n", (signed long)s32DeviceID, (unsigned int)u32Size);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Write(s32DeviceID, pBuf, u32Size);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 AU_CUS_COMMON_DECODER_Flush(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return MApi_AUDIO_DECODER_Flush(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

/* Common */
MS_BOOL AU_CUS_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_PARAM_TYPE paramType, void *pParam)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nThreadDBG("[adecIndex = 0x%X] [paramType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)paramType);

    switch(paramType)
    {
        //--------------------------------------------------------------------------------------
        // Decoder (API_AUDIO_CUSTOMER_"ADEC"_PARAM_XXXXXXXX)
        //--------------------------------------------------------------------------------------
        //---MPEG---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_MPEG_SOUND_MODE:
        {
        }
        break;

        //---Dolby AC3P---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE:
        {
            switch(adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode = (*(API_AUDIO_CUSTOMER_DOLBY_DRC_MODE*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode);
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode = (*(API_AUDIO_CUSTOMER_DOLBY_DRC_MODE*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode);
                }
                break;

                default:
                {
                    AU_nDBG("\n");
                }
                break;
            }

            if( AUDIO_CHIP_TYPE >= API_AUDIO_CUSTOMER_CHIP_TYPE_2D1R)
            {
                MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_DrcMode, (MS_VIRT)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode, 0);
            }
            else
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_R2_SHM_PARAM_DOLBY_DRC_MODE, (*(API_AUDIO_CUSTOMER_DOLBY_DRC_MODE*)pParam));
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DOWNMIX_MODE:
        {
            switch(adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode = (*(API_AUDIO_CUSTOMER_DOWNMIX_MODE*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode);
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode = (*(API_AUDIO_CUSTOMER_DOWNMIX_MODE*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode);
                }
                break;

                default:
                {
                    AU_nDBG("\n");
                }
                break;
            }

            MApi_AUDIO_SetAudioParam2(DecID, Audio_R2_SHM_PARAM_DOLBY_DMX_MODE, (*(API_AUDIO_CUSTOMER_DOWNMIX_MODE*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DOLBY_BULLETIN11:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_HDMITX_BYPASS_ENABLE:
        {
            MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, *(MS_U32*)pParam, 0);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_HIGHCUT_SCALE:
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_R2_SHM_PARAM_DOLBY_HIGH_CUT, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_LOWBOOT_SCALE:
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_R2_SHM_PARAM_DOLBY_LOW_BOOST, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        //---AAC---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_AAC_DRC_MODE:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_AAC_DOWNMIX_MODE:
        {
        }
        break;

        //---WMA---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_VERSION:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_VERSION, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_CHANNELS:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_CHANNELS, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_SAMPLERATE:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_SAMPLERATE, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BYTERATE:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_BYTERATE, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BLOCKALIGN:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_BLOCKALIGN, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_ENCOPT:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_ENCOPT, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_PARSINGBYAPP:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_PARSINGBYAPP, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BITS_PER_SAMPLE:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_BITS_PER_SAMPLE, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_CHANNELMASK:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_CHANNELMASK, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_DRC_PARAM_EXIST:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_DRC_PARAM_EXIST, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_DRC_RMS_AMP_REF:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_DRC_RMS_AMP_REF, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_DRC_RMS_AMP_TARGET:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_DRC_RMS_AMP_TARGET, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_DRC_PEAK_AMP_REF:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_DRC_PEAK_AMP_REF, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_DRC_PEAK_AMP_TARGET:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_DRC_PEAK_AMP_TARGET, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_MAX_PACKET_SIZE:
        {
            MApi_AUDIO_SetASFParm(WMA_PARAMTYPE_MAX_PACKET_SIZE, *(MS_U32*)pParam);
            AU_nDBG("[*(MS_U32*)pParam = %d] \n", (unsigned int)(*(MS_U32*)pParam));
        }
        break;

        //---XPCM---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_XPCM:
        {
            Audio_XPCM_Param xpcm_param = {0,};
            xpcm_param.audioType      = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).audioType;
            xpcm_param.sampleRate     = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).sampleRate;
            xpcm_param.blockSize      = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).blockSize;
            xpcm_param.samplePerBlock = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).samplePerBlock;
            xpcm_param.channels       = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).channels;
            xpcm_param.bitsPerSample  = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).bitsPerSample;
            #if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
            {
                AU_nDBG("[xpcm_param.dwchannelMask = %d] \n", (unsigned int)(xpcm_param.dwchannelMask));

                if((xpcm_param.dwchannelMask == 0) || (xpcm_param.dwchannelMask >= 0x3F)) //channel mask should between 00 0000(0x0) ~ 11 1111 (0x3F)
                {
                    AU_nDBG("\n");

                    //upper layer don't set or set wrong channel mask. reset to default (0x3F)
                    xpcm_param.dwchannelMask = 0x3F;
                }
                else
                {
                    AU_nDBG("\n");

                    xpcm_param.dwchannelMask = (*(API_AUDIO_CUSTOMER_XPCM_PARAM*)pParam).dwchannelMask;
                }

                if(pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd != 0)
                {
                    AU_nDBG("\n");

                    //debug mode of XPCM channel mask
                    xpcm_param.dwchannelMask = pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd;
                }
            }
            #endif //#if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)

            AU_nDBG("[xpcm_param.audioType      = %d] \n", (unsigned int)(xpcm_param.audioType));
            AU_nDBG("[xpcm_param.sampleRate     = %d] \n", (unsigned int)(xpcm_param.sampleRate));
            AU_nDBG("[xpcm_param.blockSize      = %d] \n", (unsigned int)(xpcm_param.blockSize));
            AU_nDBG("[xpcm_param.samplePerBlock = %d] \n", (unsigned int)(xpcm_param.samplePerBlock));
            AU_nDBG("[xpcm_param.channels       = %d] \n", (unsigned int)(xpcm_param.channels));
            AU_nDBG("[xpcm_param.bitsPerSample  = %d] \n", (unsigned int)(xpcm_param.bitsPerSample));
            #if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
            AU_nDBG("[xpcm_param.dwchannelMask  = 0x%x] \n", (unsigned int)(xpcm_param.dwchannelMask));
            #endif //#if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)

            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_setXPCMDecParam, (MS_VIRT)(&xpcm_param));
        }
        break;

        //---Underrun threshold---
        case API_AUDIO_CUSTOMER_ADEC_PARAM_UNDERRUN_THRESHOLD_IN_MS:
        {
            switch(adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Threshold_in_ms = (*(MS_U32*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Threshold_in_ms = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Threshold_in_ms);
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Threshold_in_ms = (*(MS_U32*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Threshold_in_ms = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Threshold_in_ms);
                }
                break;

                default:
                {
                    AU_nDBG("\n");
                }
                break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_PARAM_UNDERRUN_DEBOUNCE_CNT:
        {
            switch(adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Debounce_Cnt = (*(MS_U32*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Debounce_Cnt = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Debounce_Cnt);
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Debounce_Cnt = (*(MS_U32*)pParam);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Debounce_Cnt = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Debounce_Cnt);
                }
                break;

                default:
                {
                    AU_nDBG("\n");
                }
                break;
            }
        }
        break;

        //--------------------------------------------------------------------------------------
        // Common (API_AUDIO_CUSTOMER_"COMMON"_PARAM_XXXXXXXX)
        //--------------------------------------------------------------------------------------
        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_Off:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_Off, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_AVSYNC:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_Avsync, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_ADEC0:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_Dec1, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_IO_INFO:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_IoInfo, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_MM_FILE_AVSYNC:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_mmFileAVsync, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_ALL:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_All, (MS_U32)0);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_AUTOTEST:
        {
            MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Dump_Dsp_Info, (MS_U32)Audio_DumpInfo_AutoTest, (MS_U32)0);
        }
        break;

        //---Common Cmd---
        case API_AUDIO_CUSTOMER_COMMON_PARAM_COMMON_CMD:
        {
            #if(UTPA_SUPPORT_COMMON_CMD_API)
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_CommonCmd, (MS_VIRT)pParam);
            }
            #endif
        }
        break;

        //---OMX---
        case API_AUDIO_CUSTOMER_COMMON_PARAM_OMX_SPDIF_MODE:
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_omx_spdif_mode, (MS_VIRT)pParam);
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_PARAM_OMX_SPDIF_PLAY:
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_omx_spdif_play, (MS_VIRT)pParam);
        }
        break;

        default:
        {
            return FALSE;
        }
    }
    return TRUE;
}

MS_BOOL AU_CUS_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_INFO_TYPE infoType, void *pInfo)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nThreadDBG("[adecIndex = 0x%X] [infoType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)infoType);

    switch(infoType)
    {
        //--------------------------------------------------------------------------------------
        // Decoder (API_AUDIO_CUSTOMER_"ADEC"_INFO_XXXXXXXX)
        //--------------------------------------------------------------------------------------
        //---MPEG---
        case API_AUDIO_CUSTOMER_ADEC_INFO_MPEG_SOUND_MODE:
        {
        }
        break;

        //---Dolby AC3P---
        case API_AUDIO_CUSTOMER_ADEC_INFO_AC3P_DRC_MODE:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_AC3P_DOWNMIX_MODE:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_AC3P_IS_ATMOS_STREAM:
        {
            #if(UTPA_SUPPORT_IS_ATMOS_STREAM)
            {
                AUDIO_AC3_TYPE Ret = AUDIO_AC3_TYPE_DDP;

                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_Decoder_Type, (void *)&Ret);

                if(Ret == AUDIO_AC3_TYPE_ATMOS)
                {
                    *(MS_U32*)pInfo = TRUE;
                }
                else
                {
                    *(MS_U32*)pInfo = FALSE;
                }

                AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
            }
            #endif //#if(UTPA_SUPPORT_IS_ATMOS_STREAM)
        }
        break;

        //---AAC---
        case API_AUDIO_CUSTOMER_ADEC_INFO_AAC_DRC_MODE:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_AAC_DOWNMIX_MODE:
        {
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_AAC_TYPE:
        {
            #if(UTPA_SUPPORT_AAC_TYPE)
            {
                AUDIO_AAC_TYPE Ret = AUDIO_AAC_TYPE_DOLBY_AAC;

                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_Decoder_Type, (void *)&Ret);

                switch(Ret)
                {
                    case AUDIO_AAC_TYPE_GENERIC_AAC:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_GENERIC_AAC;
                    }
                    break;

                    case AUDIO_AAC_TYPE_GENERIC_HEAACv1:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_GENERIC_HEAACv1;
                    }
                    break;

                    case AUDIO_AAC_TYPE_GENERIC_HEAACv2:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_GENERIC_HEAACv2;
                    }
                    break;

                    case AUDIO_AAC_TYPE_DOLBY_AAC:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_DOLBY_AAC;
                    }
                    break;

                    case AUDIO_AAC_TYPE_DOLBY_HEAACv1:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_DOLBY_HEAACv1;
                    }
                    break;

                    case AUDIO_AAC_TYPE_DOLBY_HEAACv2:
                    {
                        *(API_AUDIO_CUSTOMER_AAC_TYPE*)pInfo = API_AUDIO_CUSTOMER_AAC_TYPE_DOLBY_HEAACv2;
                    }
                    break;

                    default:
                        break;
                }

                AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
            }
            #endif //#if(UTPA_SUPPORT_AAC_TYPE)
        }
        break;

        //---Decode Info---
        case API_AUDIO_CUSTOMER_ADEC_INFO_SAMPLERATE:
        {
            int Ret = 0;

            Ret = (int)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_SampleRate);
            switch(Ret)
            {
                case AUDIO_FS_8KHZ:         *(int*)pInfo = 8000;    break;
                case AUDIO_FS_11KHZ:        *(int*)pInfo = 11025;   break;
                case AUDIO_FS_12KHZ:        *(int*)pInfo = 12000;   break;
                case AUDIO_FS_16KHZ:        *(int*)pInfo = 16000;   break;
                case AUDIO_FS_22KHZ:        *(int*)pInfo = 22050;   break;
                case AUDIO_FS_24KHZ:        *(int*)pInfo = 24000;   break;
                case AUDIO_FS_32KHZ:        *(int*)pInfo = 32000;   break;
                case AUDIO_FS_44KHZ:        *(int*)pInfo = 44100;   break;
                case AUDIO_FS_48KHZ:        *(int*)pInfo = 48000;   break;
                case AUDIO_FS_88KHZ:        *(int*)pInfo = 88200;   break;
                case AUDIO_FS_96KHZ:        *(int*)pInfo = 96000;   break;
                case AUDIO_FS_176KHZ:       *(int*)pInfo = 128000;  break;
                case AUDIO_FS_192KHZ:       *(int*)pInfo = 192000;  break;
                default :                   *(int*)pInfo = 0;       break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_ACMODE:
        {
            int Ret = 0;

            if(DecID == AU_DEC_ID3)
            {
                Ret = (int)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_ADEC2_acmod);
            }
            else
            {
                Ret = (int)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_ADEC1_acmod);
            }

            switch(Ret)
            {
                case AUD_CH_MODE_DUAL_MONO:          *(int*)pInfo = API_AUDIO_CUSTOMER_CH_MODE_DUAL_MONO;    break;
                case AUD_CH_MODE_MONO:               *(int*)pInfo = API_AUDIO_CUSTOMER_CH_MODE_MONO;         break;
                case AUD_CH_MODE_STEREO:             *(int*)pInfo = API_AUDIO_CUSTOMER_CH_MODE_STEREO;       break;
                case AUD_CH_MODE_JOINT_STEREO:       *(int*)pInfo = API_AUDIO_CUSTOMER_CH_MODE_JOINT_STEREO; break;
                default :                            *(int*)pInfo = API_AUDIO_CUSTOMER_CH_MODE_UNKNOWN;      break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_INFO_AVSYNC_STATE:
        {
            int Ret = 0;

            Ret = (int)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_ADEC1_AudioSyncStatus);
            *(int*)pInfo = Ret;
        }
        break;

        //--------------------------------------------------------------------------------------
        // Common (API_AUDIO_CUSTOMER_"COMMON"_INFO_XXXXXXXX)
        //--------------------------------------------------------------------------------------
        //---ES---
        case API_AUDIO_CUSTOMER_COMMON_INFO_ES_BUFFER_BASE:
        {
            MS_U32 Ret = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_UNI_ES_Base, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_ES_BUFFER_SIZE:
        {
            MS_U32 Ret = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_UNI_ES_Size, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        //---AD_ES (Audio description)---
        case API_AUDIO_CUSTOMER_COMMON_INFO_AD_ES_BUFFER_BASE:
        {
            MS_U32 Ret = 0;
            AUDIO_DEC_ID AD_DecID = AU_DEC_INVALID;

            AD_DecID = AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(DecID);

            MApi_AUDIO_GetAudioInfo2(AD_DecID, Audio_infoType_UNI_ES_Base, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_AD_ES_BUFFER_SIZE:
        {
            MS_U32 Ret = 0;
            AUDIO_DEC_ID AD_DecID = AU_DEC_INVALID;

            AD_DecID = AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(DecID);

            MApi_AUDIO_GetAudioInfo2(AD_DecID, Audio_infoType_UNI_ES_Size, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        //---PCM---
        case API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL:
        {
            MS_U32 Ret = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_pcmBuf_currLevel, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL_IN_MS:
        {
            MS_U32 pcmBuf_currLevel = 0;
            MS_U32 tmp1 = 0;
            MS_U32 tmp2 = 0;
            MS_U32 tmp3 = 0;
            MS_U32 sampleRate = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_pcmBuf_currLevel, (void *)&pcmBuf_currLevel);

            tmp3 = (MS_U32)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_SampleRate);
            switch(tmp3)
            {
                case AUDIO_FS_8KHZ:         sampleRate = 8000;    break;
                case AUDIO_FS_11KHZ:        sampleRate = 11025;   break;
                case AUDIO_FS_12KHZ:        sampleRate = 12000;   break;
                case AUDIO_FS_16KHZ:        sampleRate = 16000;   break;
                case AUDIO_FS_22KHZ:        sampleRate = 22050;   break;
                case AUDIO_FS_24KHZ:        sampleRate = 24000;   break;
                case AUDIO_FS_32KHZ:        sampleRate = 32000;   break;
                case AUDIO_FS_44KHZ:        sampleRate = 44100;   break;
                case AUDIO_FS_48KHZ:        sampleRate = 48000;   break;
                case AUDIO_FS_88KHZ:        sampleRate = 88200;   break;
                case AUDIO_FS_96KHZ:        sampleRate = 96000;   break;
                case AUDIO_FS_176KHZ:       sampleRate = 128000;  break;
                case AUDIO_FS_192KHZ:       sampleRate = 192000;  break;
                default :                   sampleRate = 0;       break;
            }

            // pcm bytes to ms:
            // bytes * 1000ms / 2(ch) / 2(16 bits) / Sample rate
            tmp1 = (MS_U32)AU_CUS_long_div((MS_U64)(pcmBuf_currLevel * 1000), 2);
            tmp2 = (MS_U32)AU_CUS_long_div((MS_U64)(tmp1), 2);
            tmp3 = (MS_U32)AU_CUS_long_div((MS_U64)(tmp2), sampleRate);

            *(MS_U32*)pInfo = tmp3;
            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));
        }
        break;

        //---PTS---
        case API_AUDIO_CUSTOMER_COMMON_INFO_33BIT_PTS:
        {
            MS_U64 pts = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_33bit_PTS, (void *)&pts);
            *(MS_U64*)pInfo = pts;

            AU_nThreadDBG("[*(MS_U32*)pInfo = 0x%X] \n", (unsigned int)(*(MS_U32*)pInfo));

            return TRUE;
        }
        break;

        //---OK, ERR Frame Cnt, IS_MAD_LOCK---
        case API_AUDIO_CUSTOMER_COMMON_INFO_OK_FRAME_CNT:
        {
            MS_U32 Ret = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_okFrmCnt, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_ERR_FRAME_CNT:
        {
            MS_U32 Ret = 0;

            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_errFrmCnt, (void *)&Ret);
            *(MS_U32*)pInfo = Ret;
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_IS_MAD_LOCK:
        {
            MS_BOOL Ret = 0;
            Ret = MApi_AUDIO_GetMAD_LOCK();

            *(MS_BOOL*)pInfo = Ret;
        }
        break;

        //---Delay---
        case API_AUDIO_CUSTOMER_COMMON_INFO_AUDIO_DELAY:
        {
            MS_U16 Ret = 0;

            Ret = MApi_SND_GetParam1(Sound_GET_PARAM_AudioDelay, 0);
            *(MS_U16*)pInfo = Ret;
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_SEDSP_MS12_DDE_DELAY:
        {
            *(MS_U16*)pInfo = AUDIO_COMMON_INFO_SEDSP_MS12_DDE_DELAY;
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_SNDR2_MS12_DDPE_DELAY:
        {
            *(MS_U16*)pInfo = AUDIO_COMMON_INFO_SNDR2_MS12_DDPE_DELAY;
        }
        break;

        case API_AUDIO_CUSTOMER_COMMON_INFO_SNDR2_MS12_DAP_DELAY:
        {
            *(MS_U16*)pInfo = AUDIO_COMMON_INFO_SNDR2_MS12_DAP_DELAY;
        }
        break;

        default:
        {
            return FALSE;
        }

    }

    return TRUE;
}

/* Customized patch */
MS_BOOL AU_CUS_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_PARAM_TYPE paramType, void *pParam)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AU_UNUSED(DecID);

    AU_nThreadDBG("[adecIndex = 0x%X] [paramType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)paramType);

    switch(paramType)
    {
        #if(CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_DELAY_SAMPLE:
            {
                MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_ES_PassThrough_DelaySmp, *(MS_VIRT*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_PCM_SAMPLERATE:
            {
                MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_ES_PassThrough_PcmSmpRate, *(MS_VIRT*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_HDMI_SAMPLERATE:
            {
                MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_ES_PassThrough_HdmiSmpRate, *(MS_VIRT*)pParam, 0);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH)

        #if(CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE1_RPTR)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE1_RPTR:
            {
                AU_CUS_WriteAbsReg(M2S_MBOX_PCM_CAPTURE_DDR_RdPtr, *(MS_U16*)pParam);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE1_RPTR)

        #if(CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE2_RPTR)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE2_RPTR:
            {
                AU_CUS_WriteAbsReg(M2S_MBOX_PCM_CAPTURE2_DDR_RdPtr, *(MS_U16*)pParam);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_PCM_CAPTURE2_RPTR)

        #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS_ENABLE:
            {
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_ByPass_bEnable = *(MS_BOOL*)pParam;
                if(pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_ByPass_bEnable == FALSE)
                {
                    if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_DriverOutputType == API_AUDIO_CUSTOMER_SPDIF_TX_PCM)
                    {
                        AU_CUS_WriteAbsMaskReg(REG_AUDIO_SPDIF_OUT_CFG, 0x07,  0x00);  //Spdif HDMI bypass disable
                        AU_CUS_WriteAbsMaskReg(REG_AUDIO_SPDIF2_OUT_CFG, 0x07,  0x00); //ARC HDMI bypass disable
                    }

                    //recovery current SPDIF TX output type.
                    AU_CUS_SPDIF_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);
                }
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)

        #if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_LOW_LATENCY_LIMITER_ENABLE:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_Low_Latency_Limiter_ES_enable, *(MS_BOOL*)pParam);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_LOW_LATENCY_LIMITER_ES_THRESHOLD:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_Low_Latency_Limiter_ES_Threshold, *(MS_U16*)pParam);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_LOW_LATENCY_LIMITER_PCM_THRESHOLD:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_Low_Latency_Limiter_PCM_Threshold, *(MS_U16*)pParam);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_LOW_LATENCY_LIMITER_PCM_SKIP_TARGET:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_Low_Latency_Limiter_PCM_Skip_Target, *(MS_U16*)pParam);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_LOW_LATENCY)

        #if(CUSTOMIZED_PATCH_PARAM_DNSE)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_ENABLE:
            {
                MApi_AUDIO_ADVSOUND_ProcessEnable(SEC_SOUND);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_AUTO_VOLUME_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_AUTO_VOLUME_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_WIDE_STEREO_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_WIDE_STEREO_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_WALL_FILTER_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_WALL_FILTER_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_HEADROOM_GAIN_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_HEADROOM_GAIN_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_GAIN_ADJUSTMENT_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_GAIN_ADJUSTMENT_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_HARD_LIMITER_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_HARD_LIMITER_CTRL, *(MS_U32*)pParam, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DNSE_MODE_IDENTIFICATION_CTRL:
            {
                MApi_AUDIO_ADVSND_SetParam(SEC_MODE_IDENTIFICATION_CTRL, *(MS_U32*)pParam, 0);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_DNSE)

        #if(CUSTOMIZED_PATCH_PARAM_DOLBY_ATMOS_CTRL)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DOLBY_ATMOS_ENABLE:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_ddp_disable_atmos, 0);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_DOLBY_ATMOS_DISABLE:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_ddp_disable_atmos, 1);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_DOLBY_ATMOS_CTRL)

        #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG_ENABLE:
            {
                //R2 WFI, bit11
                AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_R2_WFI, REG_BANK_R2_WFI_ENABLE, REG_BANK_R2_WFI_ENABLE);

                if(pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable == FALSE)
                {
                    //Recover
                    AU_nDBG("Recover Orignal_REG_BANK_R2_LOG_DBG = 0x%-4X,\n", pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG);

                    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_LOG_DBG, (MS_U16)pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG);
                }
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG_OPTION:
            {
                pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Option = *(MS_U16*)pParam;
                pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_LOG_DBG);

                AU_nDBG("Option                      = 0x%-4X,\n", pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Option);
                AU_nDBG("Orignal_REG_BANK_R2_LOG_DBG = 0x%-4X,\n", pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Orignal_REG_BANK_R2_LOG_DBG);

                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_LOG_DBG, (MS_U16)pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Option); // R2 print msg
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)

        #if(CUSTOMIZED_PATCH_PARAM_ES_REPEAT_PLAY)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_REPLAY_PLAY_ENABLE:
            {
                MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_Decoder_RepeatPlay, *(MS_BOOL*)pParam);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_ES_REPEAT_PLAY)

        #if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
        {
            /*
            1R1D:
                [7:5] SPDIF      / HDMI owner (MCU inform R2 to decide who is encode owner)
                000:  DEC-R2
                001:  SND-R2
                010:  SE-DSP-DD  / SE-DSP-DD
                011:  SE-DSP-PCM / SE-DSP-DDP

                [4:0] raw decoder selct

            2R1D:
                [7:5] SPDIF      / HDMI owner (MCU inform R2 to decide who is encode owner)
                000:  DEC-R2
                001:  SND-R2
                010:  SE-DSP-DD  / SE-DSP-DD
                011:  SE-DSP-DD  / SND-R2-DDP

                [4:0] raw decoder selct
            */

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_ENABLE:
            {
                AU_nDBG("\n");

                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable = TRUE;

                AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0040);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_ENABLE:
            {
                AU_nDBG("\n");

                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable = TRUE;

                AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0060);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_ENABLE:
            {
                AU_nDBG("\n");

                pstAudioCustomerShmData->g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable = TRUE;

                AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0040);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND_DISABLE:
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable  = FALSE;
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable = FALSE;
                pstAudioCustomerShmData->g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable = FALSE;
                AU_CUS_PATCH_SeDSP_MS12_Enc_wo_Main_Snd_disable();
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)

        #if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
        {
            /*
            1R1D:
                [7:5] SPDIF      / HDMI owner (MCU inform R2 to decide who is encode owner)
                000:  DEC-R2
                001:  SND-R2
                010:  SE-DSP-DD  / SE-DSP-DD
                011:  SE-DSP-PCM / SE-DSP-DDP

                [4:0] raw decoder selct

            2R1D:
                [7:5] SPDIF      / HDMI owner (MCU inform R2 to decide who is encode owner)
                000:  DEC-R2
                001:  SND-R2
                010:  SE-DSP-DD  / SE-DSP-DD
                011:  SE-DSP-DD  / SND-R2-DDP

                [4:0] raw decoder selct
            */

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_ENABLE:
            {
                AU_nDBG("\n");

                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_bEnable = TRUE;

                AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0040);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_ENABLE:
            {
                AU_nDBG("\n");

                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable = TRUE;

                AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0060);
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND_DISABLE:
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_bEnable  = FALSE;
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable = FALSE;
                AU_CUS_PATCH_SndR2_MS12_Enc_wo_Main_Snd_disable();
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)

        #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE:
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_switch_to_pcm_debounce_in_ms = *(MS_U32*)pParam;
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)

        #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK_REGISTER:
            {
                if(pParam)
                {
                    AU_nDBG("\n");
                    madCallBack.pFunc_HDMIMonitorEvent = (pfnAudioCustomerHDMIMonitorEvent)pParam;
                }
                else
                {
                    AU_nDBG("\n");
                    madCallBack.pFunc_HDMIMonitorEvent = NULL;
                }
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)

        default:
        {
            return FALSE;
        }
    }
    return TRUE;
}

MS_BOOL AU_CUS_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_INFO_TYPE infoType, void *pInfo)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nThreadDBG("[adecIndex = 0x%X] [infoType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)infoType);

    switch(infoType)
    {
        #if(CUSTOMIZED_PATCH_INFO_SPDIF_NPCM_WPTR)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_SPDIF_NONPCM_WPTR:
            {
                MS_U32 *pU32data = (MS_U32*) pInfo;
                *pU32data = (MS_U32)AU_CUS_ReadDM(AU_DEC_ID1, DSP2DmAddr_nonpcm_capture_wptr, FALSE);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_SPDIF_NPCM_WPTR)

        #if(CUSTOMIZED_PATCH_INFO_PCM_CAPTURE1_WPTR)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_PCM_CAPTURE1_WPTR:
            {
                MS_U32 *pU32data = (MS_U32*) pInfo;
                *pU32data = (MS_U32)AU_CUS_ReadAbsReg(S2M_MBOX_PCM_CAPTURE_DDR_WrPtr);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_PCM_CAPTURE1_WPTR)

        #if(CUSTOMIZED_PATCH_INFO_PCM_CAPTURE2_WPTR)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_PCM_CAPTURE2_WPTR:
            {
                MS_U32 *pU32data = (MS_U32*) pInfo;
                *pU32data = (MS_U32)AU_CUS_ReadAbsReg(S2M_MBOX_PCM_CAPTURE2_DDR_WrPtr);
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_PCM_CAPTURE2_WPTR)

        #if(CUSTOMIZED_PATCH_INFO_MCU_DUMP_R2_LOG)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_BASE:
            {
                MS_U32 Ret = 0;

                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_R2_uart_buf_base, (void *)&Ret);
                *(MS_U32*)pInfo = ( Ret + MApi_AUDIO_GetDspMadBaseAddr(2) );
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_SIZE:
            {
                MS_U32 Ret = 0;

                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_R2_uart_buf_size, (void *)&Ret);
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_WPTR:
            {
                MS_U32 Buf_Base = 0;
                MS_U32 Buf_Wptr = 0;

                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_R2_uart_buf_base, (void *)&Buf_Base);
                MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_R2_uart_buf_wptr, (void *)&Buf_Wptr);
                *(MS_U32*)pInfo = ( Buf_Base + Buf_Wptr + MApi_AUDIO_GetDspMadBaseAddr(2) );
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_MCU_DUMP_R2_LOG)

        #if(CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUFFER)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_BASE:
            {
                MS_U32 Ret = (MS_U32)OFFSET_PCM1_DRAM_ADDR + MApi_AUDIO_GetDspMadBaseAddr(1) + (MS_U32)ASND_DSP_DDR_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_SIZE:
            {
                MS_U32 Ret = (MS_U32)PCM1_DRAM_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_WPTR:
            {
                MS_U32 Ret = (MS_U32)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_ADEC1_UNI_pcm_wptr);
                *(MS_U32*)pInfo = Ret;
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUFFER)

        #if(CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUFFER)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_BASE:
            {
                MS_U32 Ret = 0;

                #if(UTPA_AUDIO_CHIP_TYPE_1R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1);
                }
                #elif(UTPA_AUDIO_CHIP_TYPE_2R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1) + ASND_DSP_DDR_SIZE;
                }
                #endif

                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_SIZE:
            {
                MS_U32 Ret = (MS_U32)HDMI_NONPCM_DRAM_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_RPTR:
            {
                MS_U32 Ret = 0;

                #if(UTPA_AUDIO_CHIP_TYPE_1R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1) + (MS_U32)( AU_CUS_ReadAbsReg(S2M_MBOX_HDMI_NPCM_RPTR)<<4 );
                }
                #elif(UTPA_AUDIO_CHIP_TYPE_2R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1) + ASND_DSP_DDR_SIZE + (MS_U32)( AU_CUS_ReadAbsReg(S2M_MBOX_HDMI_NPCM_RPTR)<<4 );
                }
                #endif

                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_WPTR:
            {
                MS_U32 Ret = 0;

                #if(UTPA_AUDIO_CHIP_TYPE_1R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1) + (MS_U32)( AU_CUS_ReadAbsReg(S2M_MBOX_HDMI_NPCM_WPTR)<<4 );
                }
                #elif(UTPA_AUDIO_CHIP_TYPE_2R1D)
                {
                    Ret = (MS_U32)OFFSET_HDMI_NONPCM_DRAM_BASE + MApi_AUDIO_GetDspMadBaseAddr(1) + ASND_DSP_DDR_SIZE + (MS_U32)( AU_CUS_ReadAbsReg(S2M_MBOX_HDMI_NPCM_WPTR)<<4 );
                }
                #endif

                *(MS_U32*)pInfo = Ret;
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUFFER)

        #if(CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUFFER)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_BASE:
            {
                MS_U32 Ret = (MS_U32)OFFSET_DDPENC_METADATA_DRAM_ADDR + MApi_AUDIO_GetDspMadBaseAddr(1) + (MS_U32)ASND_DSP_DDR_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_SIZE:
            {
                MS_U32 Ret = (MS_U32)DDPENC_METADATA_DRAM_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_WPTR:
            {
                MS_U32 Ret = (MS_U32)OFFSET_DDPENC_METADATA_DRAM_ADDR + MApi_AUDIO_GetDspMadBaseAddr(1) + (MS_U32)( AU_CUS_ReadAbsReg(S2M_MBOX_DDPE_METADATA_WPTR)<<4 );
                *(MS_U32*)pInfo = Ret;
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUFFER)

        #if(CUSTOMIZED_PATCH_INFO_DEC_ES1_BUFFER)
        {
            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_BASE:
            {
                MS_U32 u32ES1BufStartAddr_P = 0;
                MApi_AUDIO_GetAudioInfo2(AU_DEC_ID1, Audio_infoType_UNI_ES_Base, &u32ES1BufStartAddr_P);

                *(MS_U32*)pInfo = u32ES1BufStartAddr_P;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_SIZE:
            {
                MS_U32 Ret = (MS_U32)ES1_DRAM_SIZE;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_RPTR:
            {
                AES_INFO currentAESInfo = {0,};
                MApi_AUDIO_MM2_checkAesInfo(DecID, &currentAESInfo);

                MS_U32 Ret = MApi_AUDIO_GetDspMadBaseAddr(1) + currentAESInfo.aes_read_addr;
                *(MS_U32*)pInfo = Ret;
            }
            break;

            case API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_WPTR:
            {
                AES_INFO currentAESInfo = {0,};
                MApi_AUDIO_MM2_checkAesInfo(DecID, &currentAESInfo);

                MS_U32 Ret = MApi_AUDIO_GetDspMadBaseAddr(1) + currentAESInfo.aes_write_addr;
                *(MS_U32*)pInfo = Ret;
            }
            break;
        }
        #endif //#if(CUSTOMIZED_PATCH_INFO_DEC_ES1_BUFFER)

        default:
        {
            return FALSE;
        }

    }
    return TRUE;
}

void AU_CUS_PATCH_SeDSP_MS12_Enc_wo_Main_Snd_disable(void)
{
    #if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
    {
        AU_nDBG("\n");
        AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0000);
    }
    #endif
}

void AU_CUS_PATCH_SndR2_MS12_Enc_wo_Main_Snd_disable(void)
{
    #if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
    {
        AU_nDBG("\n");
        AU_CUS_WriteAbsMaskReg(MBOX_BYTE_DEC_SPDIF_SEL, 0x00E0, 0x0000);
    }
    #endif
}

/* Customized Internal patch */
MS_BOOL AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, AU_CUS_INTERNAL_PATCH_PARAM_TYPE paramType, void *pParam)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AU_UNUSED(DecID);

    AU_nThreadDBG("[adecIndex = 0x%X] [paramType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)paramType);

    switch(paramType)
    {
        case AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN)
            {
                AU_nDBG("\n");
                /**
                 * AU_CUS_ADEC_SetGain
                 * gain Scale     : 0.125dB
                 * gain Range     : -114.875dB ~ 0dB
                 * ex.  gain 0 = -114.875dB; gain 919 = 0dB
                 */
                AU_CUS_ADEC_SetGain(adecIndex, *(int*) pParam);
            }
            #endif //#if(CUSTOMIZED_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN)
        }
        break;

        case AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE)
            {
                AU_nDBG("\n");
                AU_CUS_ADEC_SetMute(adecIndex, *(MS_BOOL*) pParam);
            }
            #endif //#if(CUSTOMIZED_INTERNAL_PATCH_PARAM_ADEC_SET_MUTE)
        }
        break;

        case AU_CUS_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUDIO_DELAY:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUTO_AUDIO_DELAY_ENABLE)
            {
                AU_nDBG("\n");
                AU_CUS_SetAudioDelay(*(MS_U32*) pParam);
            }
            #endif //#if(CUSTOMIZED_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUTO_AUDIO_DELAY_ENABLE)
        }
        break;

        case AU_CUS_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP_ENABLE:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP)
            {
                pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = *(MS_BOOL*) pParam;
            }
            #endif //#if(CUSTOMIZED_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP)
        }
        break;

        case AU_CUS_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT)
            {
                pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select = *(API_AUDIO_CUSTOMER_SNDR2_MS12_PCMR_METADATA_SELECT*) pParam;

                AU_nDBG("SndR2_MS12_Pcmr_Metadata_Select: %d\n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select );

                // 0x112E92[10:9] = 00: R2 decoder is activated
                // 0x112E92[10:9] = 01: Mch
                // 0x112E92[10:9] = 10: Dmx
                AU_CUS_WriteAbsMaskReg(SNDR2_MS12_MBOX_PCMR_METADATA_SELECT, 0x0600, (pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select << 9) );
            }
            #endif //#if(CUSTOMIZED_INTERNAL_PATCH_PARAM_SNDR2_MS12_PCMR_METADATA_SELECT)
        }
        break;

        default:
        {
            return FALSE;
        }
    }
    return TRUE;
}

MS_BOOL AU_CUS_INTERNAL_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, AU_CUS_INTERNAL_PATCH_INFO_TYPE infoType, void *pInfo)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AU_UNUSED(DecID);

    AU_nThreadDBG("[adecIndex = 0x%X] [infoType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)infoType);

    switch(infoType)
    {
        //---RESERVE---
        case AU_CUS_INTERNAL_PATCH_INFO_RESERVE0:
        {
        }
        break;

        default:
        {
            return FALSE;
        }

    }
    return TRUE;
}

MS_BOOL AU_CUS_ADEC_SetGain(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, int gain)
{
    MS_U32 mainVol, fineVol;

    AU_nDBG("[adecIndex = 0x%x] [gain = %d] \n", (unsigned int)adecIndex, (unsigned int)gain);

    mainVol = (1015 - (int)gain)/8;
    fineVol = (1015 - (int)gain) - mainVol*8;

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_Gain = gain;
            MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_MIXER_MCH_IN, (MS_U8)mainVol, (MS_U8)fineVol);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_Gain = gain;
            MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_MIXER_MCH_IN, (MS_U8)mainVol, (MS_U8)fineVol);
        }
        break;

        default:
        {
            return FALSE;
        }
        break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_ADEC_SetMute(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x] [bOnOff = %d] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_bMute = bOnOff;
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_mute, pstAudioCustomerShmData->g_audio_customer_ADEC0_bMute);
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_bMute = bOnOff;
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_mute, pstAudioCustomerShmData->g_audio_customer_ADEC1_bMute);
        }
        break;

        default:
        {
            return FALSE;
        }
        break;
    }

    AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_SetMute_Delay);

    return TRUE;
}

/* Clip Play for ES */

/* Clip Play for PCM */

/* Gain, Mute & Delay */
//---Gain---
MS_BOOL AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_U32 gain)
{
    AUDIO_MIX_VOL_TYPE VolType = PCM_VOL;
    int vol1, vol2;

    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] [gain = %d] \n", (unsigned int)currentConnect, (unsigned int)inputConnect, (unsigned int)gain);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_FWM0:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[inputConnect] = gain;

            switch(inputConnect)
            {
                case API_AUDIO_CUSTOMER_FWM_INPUT_CH5:
                {
                    VolType = GAME1_VOL;
                }
                break;

                case API_AUDIO_CUSTOMER_FWM_INPUT_CH6:
                {
                    VolType = GAME2_VOL;
                }
                break;

                case API_AUDIO_CUSTOMER_FWM_INPUT_CH8:
                {
                    VolType = PCM_VOL;
                }
                break;

                default:
                    break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_FWM1:
        {
             pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain[inputConnect] = gain;
             return TRUE;
        }
        break;

        case API_AUDIO_CUSTOMER_FWM2:
        {
             pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain[inputConnect] = gain;
             return TRUE;
        }
        break;

        default:
            break;
    }

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;
    MApi_AUDIO_SetMixModeVolume(E_AUDIO_INFO_GAME_IN, VolType, vol1, vol2);

    //for MS12, CH5/CH6 gain control can't set input gain for Dolby content.
    switch(inputConnect)
    {
        case API_AUDIO_CUSTOMER_FWM_INPUT_CH5:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect)
            {
                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN, &gain);
                }
                break;

                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN, &gain);
                }
                break;

                default:
                    break;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_FWM_INPUT_CH6:
        {
            switch(pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect)
            {
                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC0:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN, &gain);
                }
                break;

                case API_AUDIO_CUSTOMER_CH_INPUT_ADEC1:
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, AU_CUS_INTERNAL_PATCH_PARAM_ADEC_SET_GAIN, &gain);
                }
                break;

                default:
                    break;
            }
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_SetI2SOutGain(MS_U32 gain)
{
    int vol1, vol2;

    AU_nDBG("[gain = %d] \n", (unsigned int)gain);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Gain = gain;
    gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out;

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;
    MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_I2S, vol1, vol2);

    return TRUE;
}

MS_BOOL AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_U32 gain)
{
    int vol1, vol2;
    AUDIO_PATH_TYPE path = AUDIO_PATH_NULL;

    AU_nDBG("[lineIndex = %d] [gain = %d] \n", (unsigned int)lineIndex, (unsigned int)gain);

    switch(lineIndex)
    {
        case API_AUDIO_CUSTOMER_LINE_OUT_0:
        {
            path = AUDIO_T3_PATH_AUOUT0;
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Gain = gain;
            gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_1:
        {
            path = AUDIO_T3_PATH_AUOUT1;
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Gain = gain;
            gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_2:
        {
            path = AUDIO_T3_PATH_AUOUT2;
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Gain = gain;
            gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_3:
        {
            path = AUDIO_T3_PATH_AUOUT3;
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Gain = gain;
            gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out;
        }
        break;

        default:
            break;
    }

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;
    MApi_AUDIO_SetAbsoluteVolume(path, vol1, vol2);

    return TRUE;
}

MS_BOOL AU_CUS_SetSPDIFOutGain(MS_U32 gain)
{
    int vol1, vol2;

    AU_nDBG("[gain = %d] \n", (unsigned int)gain);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Gain = gain;
    gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out;

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;
    MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_SPDIF, vol1, vol2);

    return TRUE;
}

//---Mute---
MS_BOOL AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_BOOL bOnOff)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect, (unsigned int)bOnOff);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_FWM0:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[inputConnect] = bOnOff;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM1:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute[inputConnect] = bOnOff;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM1, inputConnect);
        }
        break;

        case API_AUDIO_CUSTOMER_FWM2:
        {
            pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute[inputConnect] = bOnOff;
            AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM2, inputConnect);
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_SetI2SOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute = bOnOff;

    AU_CUS_SetI2SOutMuteStatus();

    return TRUE;
}

MS_BOOL AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL bOnOff)
{
    AU_nDBG("[lineIndex = %d] [bOnOff = 0x%x] \n", lineIndex, bOnOff);

    switch(lineIndex)
    {
        case API_AUDIO_CUSTOMER_LINE_OUT_0:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute = bOnOff;
            AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_0);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_1:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute = bOnOff;
            AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_1);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_2:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute = bOnOff;
            AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_2);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_3:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute = bOnOff;
            AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_3);
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL AU_CUS_SetSPDIFOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute = bOnOff;

    AU_CUS_SetSPDIFOutMuteStatus();

    return TRUE;
}

MS_BOOL AU_CUS_SetHDMIOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute = bOnOff;

    AU_CUS_SetHDMIOutMuteStatus();

    return TRUE;
}

MS_BOOL AU_CUS_MuteDuringLimitedTime_Input(MS_U32 per_50ms, API_AUDIO_CUSTOMER_FWM_INDEX eFWM, API_AUDIO_CUSTOMER_FWM_INPUT eCh)
{
    AU_nDBG("[per_50ms = %d] [eFWM = 0x%x] [eCh = 0x%x]\n", (unsigned int)per_50ms, (unsigned int)eFWM, (unsigned int)eCh);

    if(per_50ms > MuteLimitedTimeOfFWM0In[eCh])
    {
        MuteLimitedTimeOfFWM0In[eCh] = per_50ms;
        pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[eCh] = TRUE;
        AU_CUS_DspMixerMuteStatus(eFWM, eCh);
    }

    return TRUE;
}

MS_BOOL AU_CUS_MuteDuringLimitedTime_Output(MS_U32 per_50ms, API_AUDIO_CUSTOMER_OUTPUT_TYPE ePort)
{
    AU_nDBG("[per_50ms = %d] [ePort = 0x%x] \n", (unsigned int)per_50ms, (unsigned int)ePort);

    if(per_50ms > MuteLimitedTimeOfSoundOut[ePort])
    {
        MuteLimitedTimeOfSoundOut[ePort] = per_50ms;
        pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[ePort] = TRUE;
    }

    switch(ePort)
    {
        case API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT1_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT2_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT:
        {
            AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_0);
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_OUTPUT:
        {
            AU_CUS_SetSPDIFOutMuteStatus();
        }
        break;

        case API_AUDIO_CUSTOMER_I2S_OUTPUT:
        {
            AU_CUS_SetI2SOutMuteStatus();
        }
        break;

        case API_AUDIO_CUSTOMER_HDMI_OUTPUT:
        {
            AU_CUS_SetHDMIOutMuteStatus();
        }
        break;

        default:
            break;
    }

    return TRUE;
}

//---Delay---
MS_BOOL AU_CUS_SetChannelDelay(API_AUDIO_CUSTOMER_CH_SOUND ch, MS_U32 delay)
{
    #if(UTPA_SUPPORT_SND_INTERNAL_DELAY)
    {
        Sound_SET_PARAM_Type Type;

        AU_nDBG("[delay = 0x%x] \n", (unsigned int)delay);

        switch(ch)
        {
            case API_AUDIO_CUSTOMER_CH5_SOUND:
            {
                Type = Sound_SET_PARAM_InternalDelay_Ch5;
            }
            break;

            case API_AUDIO_CUSTOMER_CH6_SOUND:
            {
                Type = Sound_SET_PARAM_InternalDelay_Ch6;
            }
            break;

            case API_AUDIO_CUSTOMER_CH7_SOUND:
            {
                Type = Sound_SET_PARAM_InternalDelay_Ch7;
            }
            break;

            case API_AUDIO_CUSTOMER_CH8_SOUND:
            {
                Type = Sound_SET_PARAM_InternalDelay_Ch8;
            }
            break;

            default:
            {
                return FALSE;
            }
            break;
        }

        MApi_SND_SetParam1(Type, (MS_U16)delay, 0);

        #if(UTPA_ASND_DSP_DDR_SIZE_SYNC_WITH_ALSA)
        {
            MApi_SND_SetParam1(Sound_SET_PARAM_InternalDelay_Ch1, (MS_U16)delay, 0);
        }
        #endif

        return TRUE;
    }
    #else
    {
        return TRUE;
    }
    #endif
}

MS_BOOL AU_CUS_SetAudioDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delay = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_SE_DriverDelay = delay;

    #if(CUSTOMIZED_INTERNAL_PATCH_LIMITED_AUDIO_DELAY_ENABLE)
    {
        if(delay < AUDIO_DELAY_LOWER_BOUND)
        {
            delay = AUDIO_DELAY_LOWER_BOUND;
            AU_nThreadDBG("[delay = 0x%x] \n", (unsigned int)delay);
        }
    }
    #endif

    return MApi_SND_SetParam1(Sound_SET_PARAM_AudioDelay, (MS_U16)delay, 0);
}

MS_BOOL AU_CUS_SetSpdifDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delayTime = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_DriverDelay = delay;

    return MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_setSpdifDelay, delay, 0);
}

MS_BOOL AU_CUS_SetHdmiDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delayTime = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_DriverDelay = delay;

#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    return MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_setHdmiDelay, delay, 0);
#else
    return FALSE;
#endif
}

/* AENC */

/* PCM Capture */

/* PCM IO Control */

/* MM New Mode */
AUDIO_DEC_ID AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(AUDIO_DEC_ID DecID)
{
    AUDIO_DEC_ID AD_DecID = AU_DEC_INVALID;

    AU_nDBG("[DecID = 0x%x] \n", (unsigned int)DecID);

    switch(DecID)
    {
        case AU_DEC_ID1:
        {
            AD_DecID = AU_DEC_ID2;
        }
        break;

        default:
            break;
    }

    AU_nDBG("[AD_DecID = 0x%x] \n", (unsigned int)AD_DecID);

    return AD_DecID;
}

/* Mstar Sound Effect */

/* Advanced Sound Effect */

static void AU_CUS_MonitorService(void)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;
    int DDPEnc_bEnable = 0;
    static int Current_SRS_Status  = -1;
    static int Previous_SRS_Status = -1;
    static int Current_DAP_Status  = -1;
    static int Previous_DAP_Status = -1;

    AU_UNUSED(DecID);
    AU_UNUSED(DDPEnc_bEnable);
    AU_UNUSED(Current_SRS_Status);
    AU_UNUSED(Previous_SRS_Status);
    AU_UNUSED(Current_DAP_Status);
    AU_UNUSED(Previous_DAP_Status);

    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_MonitorService_bEnable)
    {
        if(pstAudioCustomerShmData->g_audio_customer_Init_Done == TRUE)
        {
            #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_BYPASS)
            if(pstAudioCustomerShmData->g_audio_customer_patch_HDMI_RX_ByPass_bEnable == TRUE)
            {
                AU_CUS_WriteAbsMaskReg(REG_AUDIO_SPDIF_OUT_CFG, 0x07,  0x03);  //Spdif HDMI bypass
                AU_CUS_WriteAbsMaskReg(REG_AUDIO_SPDIF2_OUT_CFG, 0x07,  0x03); //ARC HDMI bypass
            }
            else
            #endif
            {
                if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff)
                {
                    AU_CUS_SPDIF_TX_Monitor();

                    #if(CUSTOMIZED_INTERNAL_PATCH_DDPE_SRS_AUTO_BYPASS_ENABLE)
                    {
                        DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput);
                        MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_Get_DDPEnc_Status, (void *)&DDPEnc_bEnable);

                        if(DDPEnc_bEnable)
                        {
                            Current_SRS_Status = 0;
                            if(Current_SRS_Status != Previous_SRS_Status)
                            {
                                AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_SND_R2_SRS, 0x02, 0x02);
                                Previous_SRS_Status = Current_SRS_Status;
                            }
                        }
                        else
                        {
                            Current_SRS_Status = 1;
                            if(Current_SRS_Status != Previous_SRS_Status)
                            {
                                AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_SND_R2_SRS, 0x02, 0x00);
                                Previous_SRS_Status = Current_SRS_Status;
                            }
                        }
                    }
                    #endif

                    #if(CUSTOMIZED_INTERNAL_PATCH_DDPE_DAP_AUTO_BYPASS_ENABLE)
                    {
                        DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput);
                        MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_Get_DDPEnc_Status, (void *)&DDPEnc_bEnable);

                        if(DDPEnc_bEnable)
                        {
                            #if(UTPA_SUPPORT_DOLBY_DAP)
                            {
                                Current_DAP_Status = 0;
                                if(Current_DAP_Status != Previous_DAP_Status)
                                {
                                    MApi_AUDIO_ADVSOUND_SubProcessEnable(DOLBY_DAP_EN, FALSE);
                                    Previous_DAP_Status = Current_DAP_Status;
                                }
                            }
                            #endif
                        }
                        else
                        {
                            #if(UTPA_SUPPORT_DOLBY_DAP)
                            {
                                Current_DAP_Status = 1;
                                if(Current_DAP_Status != Previous_DAP_Status)
                                {
                                    MApi_AUDIO_ADVSOUND_SubProcessEnable(DOLBY_DAP_EN, pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable);
                                    Previous_DAP_Status = Current_DAP_Status;
                                }
                            }
                            #endif
                        }
                    }
                    #endif
                }

                #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
                {
                    //do nothing
                }
                #else
                {
                    if(pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff)
                    {
                        AU_CUS_HDMI_RX_Monitor();
                    }
                }
                #endif
            }

            if(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff)
            {
                AU_CUS_HDMI_TX_Monitor();
            }

            if(pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff)
            {
                if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
                {
                    AU_CUS_SIF_Monitor();
                }
            }

            if(pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff)
            {
                MApi_Audio_Monitor();
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval);
    }
}

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
/* AAC Encode Function */
static void AU_CUS_AACEncOutput(MS_U8 *pPcmBuffer, MS_U16 pcmLenth)
{
    MS_S32 retAACEnc = -1;
    API_AUDIO_CUSTOMER_AENC_DATA aacEncInfo;
    tEmzInt32 aacEncodedLenth = AAC_ENCODED_LENTH;
    MS_U32 aacEnocdeTime = 0;

    aacEnocdeTime = MsOS_GetSystemTime();

    /* encode */
    retAACEnc = (MS_S32)Mpeg4AacEnc_Encode(aacEncodeHandler, (tEmzInt16 *)pPcmBuffer, pcmLenth, aacEncodedBuffer, &aacEncodedLenth);

    if (retAACEnc < 0)
    {
        AU_nPRINT("[Error] [retAACEnc(0x%X), pcmLenth(0x%X), aacEncodedLenth(0x%X), time(0x%X)] \n", (int)retAACEnc, (unsigned int)pcmLenth, (unsigned int)aacEncodedLenth, (unsigned int)aacEnocdeTime);
        return;
    }

    /* output AAC to debug file */
    if(pAU_AACEncDumpFile != NULL)
    {
        AU_CUS_FileWrite((void*)aacEncodedBuffer, sizeof(MS_U8), aacEncodedLenth, pAU_AACEncDumpFile);
    }

    /* update PTS */
    if(firstGetEncodeTimeFlag == TRUE)
    {
        aacEncInfo.pts = 0;
        encStartTime = aacEnocdeTime;
        firstGetEncodeTimeFlag = FALSE;
    }
    else
    {
        #if 0//need to refine
        if(g_bVencEnable == TRUE) //APVR case, else is Music Catch case(no VENC)
        {
            encStartTime = g_u32AVPtsBase;
        }
        aacEncInfo.pts = 1 + g_u32StartPTS + (AACEnocdeTime - u32EncStartTime)*90;
        #endif
        aacEncInfo.pts = (aacEnocdeTime - encStartTime)*90;
    }

    aacEncInfo.encFormat = API_AUDIO_CUSTOMER_AENC_ENCODE_AAC;
    aacEncInfo.pData     = (MS_U8 *)aacEncodedBuffer;
    aacEncInfo.dataLen   = aacEncodedLenth;
    aacEncInfo.pRStart   = (MS_U8 *)aacEncodedBuffer;
    aacEncInfo.pREnd     = aacEncInfo.pRStart + aacEncodedLenth;

    #if 0
    AU_nPRINT("[AUDIO][aacEncInfo.pts     = %llu] \n", aacEncInfo.pts);
    AU_nPRINT("[AUDIO][aacEncInfo.index   = 0x%x] \n", (unsigned int)aacEncInfo.index);
    AU_nPRINT("[AUDIO][aacEncInfo.pData   = 0x%x] \n", aacEncInfo.pData);
    AU_nPRINT("[AUDIO][aacEncInfo.dataLen = 0x%x] \n", (unsigned int)aacEncInfo.dataLen);
    AU_nPRINT("[AUDIO][aacEncInfo.pRStart = 0x%x] \n", aacEncInfo.pRStart);
    AU_nPRINT("[AUDIO][aacEncInfo.pREnd   = 0x%x] \n", aacEncInfo.pREnd);
    #endif

    if(madCallBack.pFunc_AencAAC != NULL)
    {
        madCallBack.pFunc_AencAAC(&aacEncInfo);
    }
}

static void AU_CUS_AACEncodeMonitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_AACEncodeMonitor_bEnable)
    {
        if(pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable == TRUE)
        {
            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_lock(&AU_Customer_AACEncode_mutex_lock);
            }
            #else //User Space
            {
                OS_OBTAIN_MUTEX(AU_Customer_AACEncode_mutex_lock, MSOS_WAIT_FOREVER);
            }
            #endif

            memset((void *)pAACEncPCMBuffer, 0x00, AAC_REQUEST_BYTES);
            if(MApi_AUDIO_PCMCapture_Read(AACEncPCMCaptureDevice, (void *)pAACEncPCMBuffer, AAC_REQUEST_BYTES) == TRUE)
            {
                //AU_nPRINT("[A][%s] [%s] [%d] [Time(%d)] [] \n", __FILE__, __FUNCTION__, __LINE__, (int)MsOS_GetSystemTime());

                if(pAU_AACEncPCMCaptureDumpFile != NULL)
                {
                    AU_CUS_FileWrite((void*)pAACEncPCMBuffer, sizeof(MS_U8), AAC_REQUEST_BYTES, pAU_AACEncPCMCaptureDumpFile);
                }
                else
                {
                    AU_nPRINT("[A] [Error] [%s] [please open AACEncPCMDump.pcm at first] \n", __FUNCTION__);
                }

                retryCounterAACEncode = 0;

                AU_CUS_AACEncOutput(pAACEncPCMBuffer, AAC_REQUEST_BYTES);
            }
            else
            {
                retryCounterAACEncode++;
                if (retryCounterAACEncode > 10)
                {
                    AU_nPRINT("[A] [Error] [%s] [Too many retry count(%u) for AAC encode] \n", __FUNCTION__, (unsigned int)retryCounterAACEncode);
                }
            }

            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_unlock(&AU_Customer_AACEncode_mutex_lock);
            }
            #else //User Space
            {
                OS_RELEASE_MUTEX(AU_Customer_AACEncode_mutex_lock);
            }
            #endif
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_AACEncodeMonitor_Interval);
    }
}

static MS_BOOL AU_CUS_AACEncodeInit(AUDIO_CAPTURE_SOURCE_TYPE sourceType)
{
    //alloc memory for AAC encoded buffer
    pAACEncPCMBuffer = AU_CUS_MemoryAlloc(AAC_REQUEST_BYTES);

    if(pAACEncPCMBuffer == NULL)
    {
        AU_nPRINT("[pAACEncPCMBuffer cannot malloc] \n");
        return FALSE;
    }

    MApi_AUDIO_PCMCapture_Init(AACEncPCMCaptureDevice, sourceType);
    MApi_AUDIO_PCMCapture_Start(AACEncPCMCaptureDevice);

    return TRUE;
}
#endif

void AU_CUS_SetI2SOutMuteStatus(void)
{
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute |
                                                                          pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_I2S_OUTPUT];

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_final_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_I2S_OUTPUT]);

    MApi_AUDIO_SetMute(AUDIO_T3_PATH_I2S, pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_final_bMute);
}

void AU_CUS_SetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex)
{
    switch(lineIndex)
    {
        case API_AUDIO_CUSTOMER_LINE_OUT_0:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute |
                                                                                    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT];

            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_final_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT]);

            MApi_AUDIO_SetMute(AUDIO_T3_PATH_AUOUT0, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_final_bMute);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_1:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute |
                                                                                    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT1_OUTPUT];

            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_final_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT1_OUTPUT]);

            MApi_AUDIO_SetMute(AUDIO_T3_PATH_AUOUT1, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_final_bMute);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_2:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute |
                                                                                    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT2_OUTPUT];

            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_final_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT2_OUTPUT]);

            MApi_AUDIO_SetMute(AUDIO_T3_PATH_AUOUT2, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_final_bMute);
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_3:
        {
            pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute |
                                                                                    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT];

            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_final_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute);
            AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT]);

            MApi_AUDIO_SetMute(AUDIO_T3_PATH_AUOUT3, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_final_bMute);
        }
        break;

        default:
            break;
    }
}

void AU_CUS_SetSPDIFOutMuteStatus(void)
{
    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute  |
                                                                            pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_SPDIF_OUTPUT];

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_SPDIF_OUTPUT]);

    // note:
    // this API will not update UTPA shm g_AudioVars2->g_SPDIF_MuteStatus
    // it will cause SPDIF un-mute after SPDIF setmode.
    // MApi_AUDIO_SetMute(AUDIO_T3_PATH_SPDIF, pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute);
    MApi_AUDIO_SPDIF_SetMute(pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_final_bMute);
}

void AU_CUS_SetHDMIOutMuteStatus(void)
{

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_final_bMute = pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute  |
                                                                           pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_HDMI_OUTPUT];

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_final_bMute           = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_final_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute                 = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_DuringLimitTime_bMute = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[API_AUDIO_CUSTOMER_HDMI_OUTPUT]);

    MApi_AUDIO_SetMute(AUDIO_T3_PATH_HDMI, pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_final_bMute);
}

void AU_CUS_SetSoundOutMuteStatus(API_AUDIO_CUSTOMER_OUTPUT_TYPE port)
{
    AU_nDBG("[port = 0x%x] \n", (unsigned int)port);

    switch(port)
    {
        case API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT1_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT2_OUTPUT:
        case API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT:
            AU_CUS_SetLineOutMuteStatus(port);
            break;

        case API_AUDIO_CUSTOMER_SPDIF_OUTPUT:
            AU_CUS_SetSPDIFOutMuteStatus();
            break;

        case API_AUDIO_CUSTOMER_I2S_OUTPUT:
            AU_CUS_SetI2SOutMuteStatus();
            break;
        case API_AUDIO_CUSTOMER_HDMI_OUTPUT:
            AU_CUS_SetHDMIOutMuteStatus();
            break;

        default:
            break;
    }
}

void AU_CUS_Mute_LimitedTime_Input_Avoid_ADEC_Pop_Noise(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 per_50ms)
{
    API_AUDIO_CUSTOMER_FWM_INPUT fwm_input = API_AUDIO_CUSTOMER_FWM_INPUT_INVALID;

    AU_nDBG("[adecIndex = 0x%x][per_50ms = %d] \n", (unsigned int)adecIndex, (unsigned int)per_50ms);

    fwm_input = AU_CUS_Mapping_ADEC_to_FWM_INPUT(adecIndex);
    AU_nDBG("[fwm_input = %d] \n", (unsigned int)fwm_input);

    if(fwm_input > API_AUDIO_CUSTOMER_FWM_INPUT_INVALID)
    {
        if(pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[fwm_input] == TRUE)
        {
            AU_nDBG("\n");
            AU_CUS_MuteDuringLimitedTime_Input(per_50ms, API_AUDIO_CUSTOMER_FWM0, fwm_input);
        }

        if(pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[fwm_input] == TRUE)
        {
            AU_nDBG("\n");
            AU_CUS_MuteDuringLimitedTime_Input(per_50ms, API_AUDIO_CUSTOMER_FWM1, fwm_input);
        }

        if(pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[fwm_input] == TRUE)
        {
            AU_nDBG("\n");
            AU_CUS_MuteDuringLimitedTime_Input(per_50ms, API_AUDIO_CUSTOMER_FWM2, fwm_input);
        }
    }

    return;
}

void AU_CUS_MuteDuringLimitedTime_Monitor(void)
{
    int port = 0;
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_MuteDuringLimitedTime_Monitor_bEnable)
    {
        //------------------------------------------------------
        // Output Mute
        //------------------------------------------------------
        for(port = API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT;  port < API_AUDIO_CUSTOMER_OUTPUT_MAX; port++)
        {
            if(MuteLimitedTimeOfSoundOut[port] > 0)
            {
                MuteLimitedTimeOfSoundOut[port]--;
                if (MuteLimitedTimeOfSoundOut[port] == 0)
                {
                    pstAudioCustomerShmData->g_audio_customer_Sound_Out_DuringLimitTime_bMute[port] = FALSE;
                    AU_CUS_SetSoundOutMuteStatus(port);
                }
            }
        }

        //------------------------------------------------------
        // Input Mute of FM Mixer0
        //------------------------------------------------------
        for(port = API_AUDIO_CUSTOMER_FWM_INPUT_CH5;  port < API_AUDIO_CUSTOMER_FWM_INPUT_MAX; port++)
        {
            if(MuteLimitedTimeOfFWM0In[port] > 0)
            {
                MuteLimitedTimeOfFWM0In[port]--;
                if (MuteLimitedTimeOfFWM0In[port] == 0)
                {
                    pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_DuringLimitTime_bMute[port] = FALSE;
                    AU_CUS_DspMixerMuteStatus(API_AUDIO_CUSTOMER_FWM0, port);
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval);
    }
}

static void AU_CUS_AdecPcmOutMonitor(void)
{
    int cnt = 0;

    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_AdecPcmOutMonitor_bEnable)
    {
        if( pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY && pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
        {
            if(API_AUDIO_CUSTOMER_AdecPcmReady(API_AUDIO_CUSTOMER_ADEC0))
            {
                if( madCallBack.pFunc_AdecDecDone !=NULL)
                {
                    madCallBack.pFunc_AdecDecDone(API_AUDIO_CUSTOMER_ADEC0, pAdecPcmHandle->PcmInfo.U32WrtBytes);
                }
                else
                {
                    AU_nPRINT("Warning: [ADEC0 PCM] call back fucntion is null !!!!\n");
                }
                cnt = 0;
            }
            else
            {
                cnt++;
                if(cnt > 3000)
                {
                    AU_nPRINT("Warning: [ADEC0 PCM] waiting for PCM is time out !!!!\n");
                    cnt = 0;
                }

            }

        }
        else if( pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY && pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
        {
            if(API_AUDIO_CUSTOMER_AdecPcmReady(API_AUDIO_CUSTOMER_ADEC1))
            {
                if( madCallBack.pFunc_AdecDecDone !=NULL)
                {
                    madCallBack.pFunc_AdecDecDone(API_AUDIO_CUSTOMER_ADEC1, pAdecPcmHandle->PcmInfo.U32WrtBytes);
                }
                else
                {
                    AU_nPRINT("Warning: [ADEC1 PCM] call back fucntion is null !!!!\n");
                }
                cnt = 0;
            }
            else
            {
                cnt++;
                if(cnt > 3000)
                {
                    AU_nPRINT("Warning: [ADEC1 PCM] waiting for PCM is time out !!!!\n");
                    cnt = 0;
                }
            }

        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_AdecPcmOut_Interval);
    }
}

MS_BOOL AU_CUS_AdecPcmInit(AUDIO_DEC_ID decID, MS_BOOL bIsMultiCh)
{
    MS_U32  Base = 0;
    MS_U32  Size = 0;
    MS_U32  MadBase = 0;

    if (bIsMultiCh)
    {
        MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Multi_Channel, 1, 0);
    }
    else
    {
        MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Multi_Channel, 0, 0);
    }

    MApi_AUDIO_GetAudioInfo2(decID, Audio_infoType_MadBaseAddr,  (void *) &MadBase);
    MApi_AUDIO_GetAudioInfo2(decID, Audio_infoType_UNI_PCM_Base, (void *) &Base );
    MApi_AUDIO_GetAudioInfo2(decID, Audio_infoType_UNI_PCM_Size, (void *) &Size );

    /* PCM Control Init */
    pAdecPcmHandle->PcmBuf.u32BufStartAddr = Base;
    pAdecPcmHandle->PcmBuf.u32BufTotalSize = Size;
    pAdecPcmHandle->PcmBuf.u32BufWrPtr     = pAdecPcmHandle->PcmBuf.u32BufStartAddr;
    pAdecPcmHandle->PcmBuf.u32BufEndAddr   = pAdecPcmHandle->PcmBuf.u32BufStartAddr + pAdecPcmHandle->PcmBuf.u32BufTotalSize;
    pAdecPcmHandle->PcmBuf.u32BufOffset    = Base - MadBase;

    pAdecPcmHandle->u32LastDecodeFrame = 0;

    // open pcm dump
    if(pstAudioCustomerShmData->g_audio_customer_bEnableAdecPcmDump == TRUE)
    {
        pAU_AdecPcmDumpFile = AU_CUS_FileOpen(AU_ADEC_PCM_DUMP_PATH, "wb");
    }

    return TRUE;
}

static void AU_CUS_PCMCaptureMonitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_PCMCaptureMonitor_bEnable)
    {
        AUDIO_DEVICE_TYPE deviceType = E_DEVICE0;
        MS_BOOL pcmCaptureFlag = FALSE;
        if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bEnable == TRUE)
        {
            deviceType = E_DEVICE0;
            pcmCaptureFlag = TRUE;
        }
        else if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bEnable == TRUE)
        {
            deviceType = E_DEVICE1;
            pcmCaptureFlag = TRUE;
        }
        else if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bEnable == TRUE)
        {
            deviceType = E_DEVICE2;
            pcmCaptureFlag = TRUE;
        }

        if(pcmCaptureFlag == TRUE)
        {
            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_lock(&AU_Customer_PCMCapture_mutex_lock);
            }
            #else //User Space
            {
                OS_OBTAIN_MUTEX(AU_Customer_PCMCapture_mutex_lock, MSOS_WAIT_FOREVER);
            }
            #endif

            memset((void *)pPCMCaptureBuffer, 0x00, pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte);

            if(MApi_AUDIO_PCMCapture_Read(deviceType, (void *)pPCMCaptureBuffer, pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte) == TRUE)
            {
                if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable)
                {
                    AU_CUS_FileWrite((void*)pPCMCaptureBuffer, sizeof(MS_U8), pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte, pAU_PcmCaptureSourceDumpFile);
                }

                retryCounterPCMCapture = 0;

                if(madCallBack.pFunc_PCMCaptureDone != NULL)
                {
                    madCallBack.pFunc_PCMCaptureDone(pPCMCaptureBuffer, pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte);
                }
            }
            else
            {
                retryCounterPCMCapture++;
                if (retryCounterPCMCapture > 10)
                {
                    AU_nPRINT("Warning: PCM capture retry too much (0x%x) !!!!!\n", (unsigned int)retryCounterPCMCapture);
                }
            }

            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                mutex_unlock(&AU_Customer_PCMCapture_mutex_lock);
            }
            #else //User Space
            {
                OS_RELEASE_MUTEX(AU_Customer_PCMCapture_mutex_lock);
            }
            #endif
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_PCMCapture_Interval);
    }
}

static MS_BOOL AU_CUS_PCMCaptureInit(AUDIO_DEVICE_TYPE deviceType, AUDIO_CAPTURE_SOURCE_TYPE sourceType)
{
    //alloc memory for pcm capture buffer
    pPCMCaptureBuffer = AU_CUS_MemoryAlloc(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte);

    if(pPCMCaptureBuffer == NULL)
    {
        AU_nPRINT("[pPCMCaptureBuffer cannot malloc] \n");
        return FALSE;
    }

    MApi_AUDIO_PCMCapture_Init(deviceType, sourceType);
    MApi_AUDIO_PCMCapture_Start(deviceType);

    return TRUE;
}

static void AU_CUS_EndOfStreamMonitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_EndOfStreamMonitor_bEnable)
    {
        AUDIO_DEC_ID DecID = AU_DEC_INVALID;

        if( (pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister) && (pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) )
        {
            DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(API_AUDIO_CUSTOMER_ADEC0);

            MS_U32 u32Adec0PCMlevel = 0;
            static MS_U32 u32Adec0TimeOutCnt = 0;
            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_pcmBuf_currLevel, &u32Adec0PCMlevel);
            //AU_nPRINT("[AUDIO] [%s] [%d] [DecID = %d][Wait PCM buffer(0x%X) empty] [Time-Out count: %u]\n", __FUNCTION__, __LINE__, DecID, (unsigned int)u32Adec0PCMlevel, (unsigned int)u32Adec0TimeOutCnt);

            //Wait all PCM data output from PCM buffer until time out
            if( (u32Adec0PCMlevel == 0) && (u32Adec0TimeOutCnt > pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt) )
            {
                u32Adec0TimeOutCnt = 0;

                if(madCallBack.pFunc_Adec0_EndOfStream != NULL)
                {
                    //AU_nPRINT("[AUDIO] [%s] [%d] [End of Stream finish !!] \n", __FUNCTION__, __LINE__);
                    madCallBack.pFunc_Adec0_EndOfStream(API_AUDIO_CUSTOMER_ADEC0);
                }
            }
            else
            {
                //The timeout count should only be incremented if
                //there is no audio, otherwise reset the timeout
                if (u32Adec0PCMlevel == 0)
                {
                    u32Adec0TimeOutCnt ++;
                }
                else
                {
                    u32Adec0TimeOutCnt = 0;
                }
            }
        }

        if( (pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister) && (pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) )
        {
            DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(API_AUDIO_CUSTOMER_ADEC1);

            MS_U32 u32Adec1PCMlevel = 0;
            static MS_U32 u32Adec1TimeOutCnt = 0;
            MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_pcmBuf_currLevel, &u32Adec1PCMlevel);
            //AU_nPRINT("[AUDIO] [%s] [%d] [DecID = %d][Wait PCM buffer(0x%X) empty] [Time-Out count: %u]\n", __FUNCTION__, __LINE__, DecID, (unsigned int)u32Adec1PCMlevel, (unsigned int)u32Adec1TimeOutCnt);

            //Wait all PCM data output from PCM buffer until time out
            if( (u32Adec1PCMlevel == 0) && (u32Adec1TimeOutCnt > pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt) )
            {
                u32Adec1TimeOutCnt = 0;

                if(madCallBack.pFunc_Adec1_EndOfStream != NULL)
                {
                    //AU_nPRINT("[AUDIO] [%s] [%d] [End of Stream finish !!] \n", __FUNCTION__, __LINE__);
                    madCallBack.pFunc_Adec1_EndOfStream(API_AUDIO_CUSTOMER_ADEC1);
                }
            }
            else
            {
                //The timeout count should only be incremented if
                //there is no audio, otherwise reset the timeout
                if (u32Adec1PCMlevel == 0)
                {
                    u32Adec1TimeOutCnt ++;
                }
                else
                {
                    u32Adec1TimeOutCnt = 0;
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_EndOfStreamMonitor_Interval);
    }
}

//----------------------------------------------------------
// AU_Demo (PCM capture call back function)
//----------------------------------------------------------
static MS_BOOL AU_CUS_Demo_PCM_Capture_CallBackFun(MS_U8 *pBuf, MS_U16 length)
{
    //Just for Demo

    return TRUE;
}

//----------------------------------------------------------
// AU_Demo (PCM I/O function)
//----------------------------------------------------------
static void AU_CUS_Demo_PCMIO_Play_Monitor(void)
{
    int i = 0;

    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_PCMIO_Play_Monitor_bEnable)
    {
        if (pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
        {
            for(i = 0; (  (i<pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_repeatNum) && (pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) ); i++)
            {
                MS_S32 s32DeviceId = 0;
                char   *u8WtAdr = (char *)AU_Demo_MM_File_read_in_buffer2;
                MS_U32 u32EndAdr = (MS_U32)u8WtAdr + pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length;
                MS_U32 u32size = 0;
                MS_U32 u32level = 0;
                MS_U32 u32availSize = 0;

                AU_nPRINT("Start to play PCM wirte demo, Remaining time: %d \n", (unsigned int)(pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_repeatNum - (i+1)) );

                s32DeviceId = API_AUDIO_CUSTOMER_PCM_Open(&pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam);
                if(s32DeviceId >= 0)
                {
                    API_AUDIO_CUSTOMER_PCM_Start(s32DeviceId);
                    do
                    {
                        API_AUDIO_CUSTOMER_PCM_Get(s32DeviceId,  API_AUDIO_CUSTOMER_PCM_CMD_BUFFERSIZE, &u32size);

                        API_AUDIO_CUSTOMER_PCM_Get(s32DeviceId,  API_AUDIO_CUSTOMER_PCM_CMD_BUFFERLEVEL, &u32level);

                        if(u32size > u32level)
                        {
                            u32availSize = u32size - u32level;
                        }

                        if(pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
                        {
                            u32size = API_AUDIO_CUSTOMER_PCM_Write(s32DeviceId, u8WtAdr, u32availSize);
                        }

                        u8WtAdr = u8WtAdr + u32size;

                        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32BufferDuration/4);

                    } while( ((MS_U32)(u8WtAdr + u32size) < u32EndAdr) && (pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) );

                    API_AUDIO_CUSTOMER_PCM_Stop(s32DeviceId);
                    API_AUDIO_CUSTOMER_PCM_Flush(s32DeviceId);
                    API_AUDIO_CUSTOMER_PCM_Close(s32DeviceId);
                    AU_nPRINT("Play PCM wirte demo Finished!! \n");
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_Monitor_Interval);
    }
}

//----------------------------------------------------------
// AU_Demo (MM New Mode) (PCM Path: DSP_SRC)
//----------------------------------------------------------
static void AU_CUS_Demo_MM_New_Mode_ESBufInit(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    St_Audio_Buf_Info *pESBufInfo;

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pESBufInfo = &ES1BufInfo;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pESBufInfo = &ES3BufInfo;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        default:
        {
            AU_nPRINT("[Error] [%s] [Invalid adecIndex: %d] \n", __FUNCTION__, adecIndex);
            pESBufInfo = &ES1BufInfo;
        }
        break;
    }

    API_AUDIO_CUSTOMER_GetAudioInfo(adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_ES_BUFFER_BASE, &(pESBufInfo->u32BufStartAddr_P));
    API_AUDIO_CUSTOMER_GetAudioInfo(adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_ES_BUFFER_SIZE, &(pESBufInfo->u32BufSize));

    pESBufInfo->u32BufEndAddr_P = pESBufInfo->u32BufStartAddr_P + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    pESBufInfo->u32BufRptr_P = pESBufInfo->u32BufStartAddr_P;

    pESBufInfo->u32BufStartAddr_V = MsOS_MPool_PA2KSEG1(pESBufInfo->u32BufStartAddr_P);
    pESBufInfo->u32BufEndAddr_V = pESBufInfo->u32BufStartAddr_V + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
    pESBufInfo->u32BufRptr_V = pESBufInfo->u32BufStartAddr_V;
}

static void AU_CUS_Demo_MM_New_Mode_ExternalBufInit(void)
{
    ExternalBufInfo.u32BufStartAddr_V = (MS_U32)AU_Demo_MM_New_Mode_DecInfo.extBufaddr_V;
    ExternalBufInfo.u32BufEndAddr_V = ExternalBufInfo.u32BufStartAddr_V + AU_Demo_MM_New_Mode_DecInfo.u32Size;
    ExternalBufInfo.u32BufWptr_V    = ExternalBufInfo.u32BufStartAddr_V;
    ExternalBufInfo.u32BufRptr_V    = ExternalBufInfo.u32BufStartAddr_V;
    ExternalBufInfo.u32BufSize      = AU_Demo_MM_New_Mode_DecInfo.u32Size;

    AU_nDBG("[AUDIO][%s] [%d] [ExternalBufInfo.u32BufStartAddr_V = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)ExternalBufInfo.u32BufStartAddr_V);
    AU_nDBG("[AUDIO][%s] [%d] [ExternalBufInfo.u32BufEndAddr_V   = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)ExternalBufInfo.u32BufEndAddr_V);
    AU_nDBG("[AUDIO][%s] [%d] [ExternalBufInfo.u32BufWptr_V      = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)ExternalBufInfo.u32BufWptr_V);
    AU_nDBG("[AUDIO][%s] [%d] [ExternalBufInfo.u32BufRptr_V      = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)ExternalBufInfo.u32BufRptr_V);
    AU_nDBG("[AUDIO][%s] [%d] [ExternalBufInfo.u32BufSize        = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)ExternalBufInfo.u32BufSize);
}

void AU_CUS_Demo_MM_New_Mode_FeedingES(void* ExtBufRptr_V, MS_U32 u32Size, API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, St_Audio_Buf_Info *pESBufInfo)
{
    //TRUE: Set PTS; FALSE: Not set PTS (MM New mode support this feature)
    MS_BOOL bSetPTS = TRUE;
    MS_U64  u64PTS = 0;

    //set start time
    if( ((MS_U32)ExtBufRptr_V) == (pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufStartAddr_V) )
    {
        pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_StartTime = MsOS_GetSystemTime();
        //AU_nPRINT("[AUDIO][%s] [%d] [set start time = %d] \n", __FUNCTION__, __LINE__, (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_StartTime);
    }

    //AU_nPRINT("[AUDIO][%s] [%d] [ES_Wptr_V = 0x%X] [ES_Wptr_P = 0x%X]\n", __FUNCTION__, __LINE__, (unsigned int)pESBufInfo->u32BufWptr_V, (unsigned int)pESBufInfo->u32BufWptr_P);
    memcpy((void *)(pESBufInfo->u32BufWptr_V), ExtBufRptr_V, u32Size);
    pESBufInfo->u32BufWptr_V += u32Size;
    pESBufInfo->u32BufWptr_P += u32Size;
    MsOS_FlushMemory();
    MsOS_Sync();

    //example of setting system time difference (ticks) as PTS
    u64PTS = (MS_U64)((MS_U64)(MsOS_GetSystemTime()+pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset) * 90);

    API_AUDIO_CUSTOMER_MM2_inputAesFinished(adecIndex, u32Size, bSetPTS, u64PTS);

    if( (pESBufInfo->u32BufWptr_V == pESBufInfo->u32BufEndAddr_V) && (pESBufInfo->u32BufWptr_P == pESBufInfo->u32BufEndAddr_P) )
    {
        pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
        pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    }
}

static void AU_CUS_Demo_MM_New_Mode_AllBufInit(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    API_AUDIO_CUSTOMER_MM2_initAesInfo(adecIndex);

    AU_CUS_Demo_MM_New_Mode_ESBufInit(adecIndex);

    AU_CUS_Demo_MM_New_Mode_ExternalBufInit();

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pAU_Demo_MM_New_Mode_DecESBufInfo = &ES1BufInfo;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pAU_Demo_MM_New_Mode_DecESBufInfo = &ES3BufInfo;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        default:
            break;
    }

    pAU_Demo_MM_New_Mode_DecExtBufInfo = &ExternalBufInfo;
}

static void AU_CUS_Demo_MM_New_Mode_Play_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_Play_Monitor_bEnable)
    {
        if( (AU_Demo_MM_New_Mode_DecInfo.bIsStart == TRUE) && (AU_Demo_MM_New_Mode_DecInfo.bIsPause == FALSE) && (AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum > 0) )
        {
            int u32RemainingSize;
            u32RemainingSize = pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufWptr_V - pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V;

            if(u32RemainingSize > 0)
            {
                API_AUDIO_CUSTOMER_AES_INFO currentAESInfo;
                API_AUDIO_CUSTOMER_MM2_checkAesInfo(AU_Demo_MM_New_Mode_DecInfo.adecIndex, &currentAESInfo);
                //AU_nPRINT("[AUDIO][%s] [%d] [adecIndex: %u] [u32RemainingSize = 0x%X] [u32FreeSpace = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AU_Demo_MM_New_Mode_DecInfo.adecIndex, (unsigned int)u32RemainingSize, (unsigned int)currentAESInfo.aes_freeSpace);

                if(u32RemainingSize <= currentAESInfo.aes_freeSpace)
                {
                    AU_CUS_Demo_MM_New_Mode_FeedingES((void*)(pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V), u32RemainingSize, AU_Demo_MM_New_Mode_DecInfo.adecIndex, pAU_Demo_MM_New_Mode_DecESBufInfo);
                    pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V += u32RemainingSize;
                    //AU_nPRINT("[AUDIO][%s] [%d] [No remaining ES data] [Remaining repeat time: %u] \n", __FUNCTION__, __LINE__, (unsigned int)AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum);
                }
                else
                {
                    if(currentAESInfo.aes_freeSpace > 0)
                    {
                        //AU_nPRINT("[AUDIO][%s] [%d] [Feeding data] [u32BufWptr_V = 0x%X] [u32BufRptr_V = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufWptr_V, (unsigned int)pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V);
                        AU_CUS_Demo_MM_New_Mode_FeedingES((void*)(pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V), currentAESInfo.aes_freeSpace, AU_Demo_MM_New_Mode_DecInfo.adecIndex, pAU_Demo_MM_New_Mode_DecESBufInfo);
                        pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V += currentAESInfo.aes_freeSpace;
                    }
                }
            }
            else
            {
                MS_U32 u32PCMlevel = 0;
                static MS_U32 u32TimeOutCnt = 0;

                API_AUDIO_CUSTOMER_GetAudioInfo(AU_Demo_MM_New_Mode_DecInfo.adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL, &u32PCMlevel);
                //AU_nPRINT("[AUDIO][%s] [%d] [Wait PCM buffer(0x%X) empty] [Time-Out count: %u]\n", __FUNCTION__, __LINE__, (unsigned int)u32PCMlevel, (unsigned int)u32TimeOutCnt);

                //Wait all PCM data output from PCM buffer until time out
                if(u32PCMlevel == 0 && u32TimeOutCnt > 100)
                {
                    u32TimeOutCnt = 0;
                    AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum --;
                    if(AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum > 0)
                    {
                        // Reset ADEC
                        API_AUDIO_CUSTOMER_StopDecoding(AU_Demo_MM_New_Mode_DecInfo.adecIndex);

                        // Init Buffer
                        AU_CUS_Demo_MM_New_Mode_AllBufInit(AU_Demo_MM_New_Mode_DecInfo.adecIndex);
                        memset((void *)(pAU_Demo_MM_New_Mode_DecESBufInfo->u32BufStartAddr_V), 0, pAU_Demo_MM_New_Mode_DecESBufInfo->u32BufSize);

                        pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufWptr_V += AU_Demo_MM_New_Mode_DecInfo.u32Size;

                        //When AP call stop or pause, there is timing issue if AU_CUS_Demo_MM_New_Mode_Play_Monitor already execute here.
                        //So check here again.
                        if( (AU_Demo_MM_New_Mode_DecInfo.bIsStart == TRUE) && (AU_Demo_MM_New_Mode_DecInfo.bIsPause == FALSE) )
                        {
                            API_AUDIO_CUSTOMER_StartDecoding(AU_Demo_MM_New_Mode_DecInfo.adecIndex);
                            //AU_nPRINT("[AUDIO][%s] [%d] [Play next clip with adecIndex(%d)] [Remaining repeat time: %u] \n", __FUNCTION__, __LINE__, (int)AU_Demo_MM_New_Mode_DecInfo.adecIndex, (unsigned int)AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum);
                        }
                        else
                        {
                            AU_nPRINT("[AUDIO][%s] [%d] [Can't play next clip] [bIsStart: %u] [bIsPause: %u]\n", __FUNCTION__, __LINE__, (unsigned int)AU_Demo_MM_New_Mode_DecInfo.bIsStart, (unsigned int)AU_Demo_MM_New_Mode_DecInfo.bIsPause);
                        }
                    }
                    else
                    {
                        switch(AU_Demo_MM_New_Mode_DecInfo.adecIndex)
                        {
                            case API_AUDIO_CUSTOMER_ADEC0:
                            {
                                if(pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister)
                                {
                                    //if register EOS, then do stop decoding in call back function
                                }
                                else
                                {
                                    API_AUDIO_CUSTOMER_StopDecoding(AU_Demo_MM_New_Mode_DecInfo.adecIndex);
                                }
                            }
                            break;

                            case API_AUDIO_CUSTOMER_ADEC1:
                            {
                                if(pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister)
                                {
                                    //if register EOS, then do stop decoding in call back function
                                }
                                else
                                {
                                    API_AUDIO_CUSTOMER_StopDecoding(AU_Demo_MM_New_Mode_DecInfo.adecIndex);
                                }
                            }
                            break;

                            default:
                            {
                                API_AUDIO_CUSTOMER_StopDecoding(AU_Demo_MM_New_Mode_DecInfo.adecIndex);
                            }
                            break;
                        }

                        AU_Demo_MM_New_Mode_DecInfo.bIsStart = FALSE;
                        pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufRptr_V = pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufStartAddr_V;
                        pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufWptr_V = pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufStartAddr_V;

                        AU_nPRINT("[AUDIO][%s] [%d] [Play Clip decoder finish !!] \n", __FUNCTION__, __LINE__);
                    }
                }
                else
                {
                     u32TimeOutCnt ++;
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval);
    }
}

//----------------------------------------------------------
// AU_Demo (MM AD New Mode) (PCM Path: DSP_SRC)
//----------------------------------------------------------
static void AU_CUS_Demo_MM_New_Mode_AD_ESBufInit(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    St_Audio_Buf_Info *pESBufInfo;

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pESBufInfo = &AD_ES2BufInfo;
        }
        break;

        default:
        {
            AU_nPRINT("[Error] [%s] [Invalid adecIndex: %d] \n", __FUNCTION__, adecIndex);
            pESBufInfo = &AD_ES2BufInfo;
        }
        break;
    }

    API_AUDIO_CUSTOMER_GetAudioInfo(adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_AD_ES_BUFFER_BASE, &(pESBufInfo->u32BufStartAddr_P));
    API_AUDIO_CUSTOMER_GetAudioInfo(adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_AD_ES_BUFFER_SIZE, &(pESBufInfo->u32BufSize));

    pESBufInfo->u32BufEndAddr_P = pESBufInfo->u32BufStartAddr_P + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    pESBufInfo->u32BufRptr_P = pESBufInfo->u32BufStartAddr_P;

    pESBufInfo->u32BufStartAddr_V = MsOS_MPool_PA2KSEG1(pESBufInfo->u32BufStartAddr_P);
    pESBufInfo->u32BufEndAddr_V = pESBufInfo->u32BufStartAddr_V + pESBufInfo->u32BufSize;
    pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
    pESBufInfo->u32BufRptr_V = pESBufInfo->u32BufStartAddr_V;
}

static void AU_CUS_Demo_MM_New_Mode_AD_ExternalBufInit(void)
{
    AD_ExternalBufInfo.u32BufStartAddr_V = (MS_U32)AU_Demo_MM_New_Mode_AD_DecInfo.extBufaddr_V;
    AD_ExternalBufInfo.u32BufEndAddr_V = AD_ExternalBufInfo.u32BufStartAddr_V + AU_Demo_MM_New_Mode_AD_DecInfo.u32Size;
    AD_ExternalBufInfo.u32BufWptr_V    = AD_ExternalBufInfo.u32BufStartAddr_V;
    AD_ExternalBufInfo.u32BufRptr_V    = AD_ExternalBufInfo.u32BufStartAddr_V;
    AD_ExternalBufInfo.u32BufSize      = AU_Demo_MM_New_Mode_AD_DecInfo.u32Size;

    AU_nDBG("[AUDIO][%s] [%d] [AD_ExternalBufInfo.u32BufStartAddr_V = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AD_ExternalBufInfo.u32BufStartAddr_V);
    AU_nDBG("[AUDIO][%s] [%d] [AD_ExternalBufInfo.u32BufEndAddr_V   = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AD_ExternalBufInfo.u32BufEndAddr_V);
    AU_nDBG("[AUDIO][%s] [%d] [AD_ExternalBufInfo.u32BufWptr_V      = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AD_ExternalBufInfo.u32BufWptr_V);
    AU_nDBG("[AUDIO][%s] [%d] [AD_ExternalBufInfo.u32BufRptr_V      = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AD_ExternalBufInfo.u32BufRptr_V);
    AU_nDBG("[AUDIO][%s] [%d] [AD_ExternalBufInfo.u32BufSize        = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AD_ExternalBufInfo.u32BufSize);
}

void AU_CUS_Demo_MM_New_Mode_AD_FeedingES(void* ExtBufRptr_V, MS_U32 u32Size, API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, St_Audio_Buf_Info *pESBufInfo)
{
    //TRUE: Set PTS; FALSE: Not set PTS (MM New mode support this feature)
    MS_BOOL bSetPTS = TRUE;
    MS_U64  u64PTS = 0;

    //set start time
    if( ((MS_U32)ExtBufRptr_V) == (pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufStartAddr_V) )
    {
        pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_AD_Play_StartTime = MsOS_GetSystemTime();
        //AU_nPRINT("[AUDIO][%s] [%d] [set start time = %d] \n", __FUNCTION__, __LINE__, (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_AD_Play_StartTime);
    }

    //AU_nPRINT("[AUDIO][%s] [%d] [ES_Wptr_V = 0x%X] [ES_Wptr_P = 0x%X]\n", __FUNCTION__, __LINE__, (unsigned int)pESBufInfo->u32BufWptr_V, (unsigned int)pESBufInfo->u32BufWptr_P);
    memcpy((void *)(pESBufInfo->u32BufWptr_V), ExtBufRptr_V, u32Size);
    pESBufInfo->u32BufWptr_V += u32Size;
    pESBufInfo->u32BufWptr_P += u32Size;
    MsOS_FlushMemory();
    MsOS_Sync();

    //example of setting system time difference (ticks) as PTS
    u64PTS = (MS_U64)((MS_U64)(MsOS_GetSystemTime()+pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset) * 90);

    API_AUDIO_CUSTOMER_MM2_AD_inputAesFinished(adecIndex, u32Size, bSetPTS, u64PTS);

    if( (pESBufInfo->u32BufWptr_V == pESBufInfo->u32BufEndAddr_V) && (pESBufInfo->u32BufWptr_P == pESBufInfo->u32BufEndAddr_P) )
    {
        pESBufInfo->u32BufWptr_V = pESBufInfo->u32BufStartAddr_V;
        pESBufInfo->u32BufWptr_P = pESBufInfo->u32BufStartAddr_P;
    }
}

static void AU_CUS_Demo_MM_New_Mode_AD_AllBufInit(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    API_AUDIO_CUSTOMER_MM2_AD_initAesInfo(adecIndex);

    AU_CUS_Demo_MM_New_Mode_AD_ESBufInit(adecIndex);

    AU_CUS_Demo_MM_New_Mode_AD_ExternalBufInit();

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pAU_Demo_MM_New_Mode_AD_DecESBufInfo = &AD_ES2BufInfo;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        case API_AUDIO_CUSTOMER_ADEC_ATV:
        default:
            break;
    }

    pAU_Demo_MM_New_Mode_AD_DecExtBufInfo = &AD_ExternalBufInfo;
}

static void AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor_bEnable)
    {
        if( (AU_Demo_MM_New_Mode_AD_DecInfo.bIsStart == TRUE) && (AU_Demo_MM_New_Mode_AD_DecInfo.bIsPause == FALSE) && (AU_Demo_MM_New_Mode_AD_DecInfo.u32RepeatNum > 0) )
        {
            int u32RemainingSize;
            u32RemainingSize = pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufWptr_V - pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V;

            if(u32RemainingSize > 0)
            {
                API_AUDIO_CUSTOMER_AES_INFO currentAESInfo = {0,};
                API_AUDIO_CUSTOMER_MM2_AD_checkAesInfo(AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex, &currentAESInfo);
                //AU_nPRINT("[AUDIO][%s] [%d] [adecIndex: %u] [u32RemainingSize = 0x%X] [u32FreeSpace = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex, (unsigned int)u32RemainingSize, (unsigned int)currentAESInfo.aes_freeSpace);

                if(u32RemainingSize <= currentAESInfo.aes_freeSpace)
                {
                    AU_CUS_Demo_MM_New_Mode_AD_FeedingES((void*)(pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V), u32RemainingSize, AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex, pAU_Demo_MM_New_Mode_AD_DecESBufInfo);
                    pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V += u32RemainingSize;
                    //AU_nPRINT("[AUDIO][%s] [%d] [No remaining ES data] [Remaining repeat time: %u] \n", __FUNCTION__, __LINE__, (unsigned int)AU_Demo_MM_New_Mode_AD_DecInfo.u32RepeatNum);
                }
                else
                {
                    if(currentAESInfo.aes_freeSpace > 0)
                    {
                        //AU_nPRINT("[AUDIO][%s] [%d] [Feeding data] [u32BufWptr_V = 0x%X] [u32BufRptr_V = 0x%X] \n", __FUNCTION__, __LINE__, (unsigned int)pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufWptr_V, (unsigned int)pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V);
                        AU_CUS_Demo_MM_New_Mode_AD_FeedingES((void*)(pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V), currentAESInfo.aes_freeSpace, AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex, pAU_Demo_MM_New_Mode_AD_DecESBufInfo);
                        pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V += currentAESInfo.aes_freeSpace;
                    }
                }
            }
            else
            {
                static MS_U32 u32TimeOutCnt = 0;

                //AU_nPRINT("[AUDIO][%s] [%d] [Time-Out count: %u]\n", __FUNCTION__, __LINE__, (unsigned int)u32TimeOutCnt);

                //Wait all PCM data output from PCM buffer until time out
                if(u32TimeOutCnt > 100)
                {
                    u32TimeOutCnt = 0;
                    AU_Demo_MM_New_Mode_AD_DecInfo.u32RepeatNum --;
                    if(AU_Demo_MM_New_Mode_AD_DecInfo.u32RepeatNum > 0)
                    {
                        // Init Buffer
                        AU_CUS_Demo_MM_New_Mode_AD_AllBufInit(AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex);
                        memset((void *)(pAU_Demo_MM_New_Mode_AD_DecESBufInfo->u32BufStartAddr_V), 0, pAU_Demo_MM_New_Mode_AD_DecESBufInfo->u32BufSize);

                        pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufWptr_V += AU_Demo_MM_New_Mode_AD_DecInfo.u32Size;
                    }
                    else
                    {
                        AU_Demo_MM_New_Mode_AD_DecInfo.bIsStart = FALSE;
                        pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufRptr_V = pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufStartAddr_V;
                        pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufWptr_V = pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufStartAddr_V;

                        AU_nPRINT("[AUDIO][%s] [%d] [Play AD finish !!] \n", __FUNCTION__, __LINE__);
                    }
                }
                else
                {
                     u32TimeOutCnt ++;
                }
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval);
    }
}

static long long AU_CUS_long_div(long long a, int b)
{
    long long r = 0;

    while (a >= b)
    {
        a -= b;
        r++;
    }
    return r;
}

static void AU_CUS_AV_Sync_Info_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_AV_Sync_Info_Monitor_bEnable)
    {
        if(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable)
        {
            VDEC_StreamId _stStreamId = {0,};
            VDEC_StreamId _stRealStrmId = {0,};
            VDEC_EX_User_Cmd cmd_id = E_VDEC_EX_USER_CMD_GET_MAIN_STREAM_ID;
            AUDIO_DEC_ID DecID = AU_DEC_INVALID;
            MS_U32 VPTS = 0;
            MS_U32 u32Stc32 = 0;
            MS_U32 u32Stc = 0;
            MS_U32 u32PCMlevel = 0;
            MS_U32 u32PCMlevelinMs = 0;
            AUDIO_DEC_ID CurrentDecID = AU_DEC_INVALID;
            API_AUDIO_CUSTOMER_UPPER_PLAYCMD CurrentUpperPlay = API_AUDIO_CUSTOMER_UPPER_STOP;
            API_AUDIO_CUSTOMER_AES_INFO aes_info;
            static MS_U32 current_inputAesFinished_cnt = 0;
            static MS_U32 previous_inputAesFinished_cnt = 0;
            static MS_U32 current_DMX_stc_ms = 0;
            static MS_U32 previous_DMX_stc_ms = 0;
            static long long current_Upper_pts_ms = 0;
            static long long previous_Upper_pts_ms = 0;
            static long long current_R2_pts_ms = 0;
            static long long previous_R2_pts_ms = 0;

            AU_UNUSED(DecID);

            switch(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    CurrentUpperPlay = pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay;
                    CurrentDecID     = pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID;
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    CurrentUpperPlay = pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay;
                    CurrentDecID     = pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID;
                }
                break;

                default:
                {
                    CurrentUpperPlay = pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay;
                    CurrentDecID     = pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID;
                }
                break;
            }

            //Get DMX STC
            if(CurrentUpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
            {
                MApi_DMX_Stc_Get(&u32Stc32, &u32Stc);
                pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_DMX_stc = (MS_U32)AU_CUS_long_div((MS_U64)(((u32Stc32&0x1)<<31) + (u32Stc>>1)), 45);
            }

            if( (CurrentDecID != AU_DEC_INVALID) && (pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex != API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID) )
            {
                DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex);

                //Get pcm level
                AU_CUS_GetAudioInfo(AU_Demo_MM_New_Mode_DecInfo.adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL, &u32PCMlevel);

                //Get pcm level in ms:
                AU_CUS_GetAudioInfo(AU_Demo_MM_New_Mode_DecInfo.adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL_IN_MS, &u32PCMlevelinMs);

                //Get R2 PTS
                AU_CUS_GetAudioInfo(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_33BIT_PTS, &pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_R2_pts);
            }
            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel = u32PCMlevel;
            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel_in_ms = u32PCMlevelinMs;

            //Get VPTS
            if(MApi_VDEC_EX_GetControl(&_stStreamId, cmd_id, (MS_U32 *)&_stRealStrmId) == E_VDEC_EX_OK)
            {
                VPTS = MApi_VDEC_EX_GetPTS(&_stRealStrmId);
            }

            //Check if stop, refresh aes info
            if( (CurrentUpperPlay == API_AUDIO_CUSTOMER_UPPER_STOP) && (CurrentDecID != AU_DEC_INVALID) && (pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex != API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID) )
            {
                memset((void *)(&aes_info), 0, sizeof(aes_info));
                API_AUDIO_CUSTOMER_MM2_checkAesInfo(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex, &aes_info);
            }
            current_inputAesFinished_cnt = pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt;
            current_DMX_stc_ms = (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_DMX_stc;
            current_Upper_pts_ms = AU_CUS_long_div(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_pts, 90);
            current_R2_pts_ms = AU_CUS_long_div(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_R2_pts, 90);
#if 0
            AU_nPRINT("|%-7ld|(c-p)AesFinished_cnt:%-2d,ret:%-1d|play=%-2d|aes_freeSpace:%-6d|es_size:%-4d|PCMLevel:%-6d,ms:%-4d|\n",
                        (long int)MsOS_GetSystemTime(),
                        (unsigned int)current_inputAesFinished_cnt-previous_inputAesFinished_cnt,
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_ret,
                        (unsigned int)CurrentUpperPlay,
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_freeSpace,
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_es_size,
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel,
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_PCMlevel_in_ms);
#endif

            AU_nPRINT("|STC:%-7d|VPTS:%-7d|(c-p)fin_cnt:%-2d|ptsExist=%d|APTS(Up):%-7lld|APTS(R2):%-7lld|APTS(Up-R2):%-7lld|(c-p)STC=%-4d|(c-p)Up_pts=%-5d|(c-p)R2_pts=%-4d|STC-UpPTS=%-6d|STC-R2_PTS(R2)=%-4d|STC-VPTS=%-4d|\n",
                        (unsigned int)current_DMX_stc_ms,
                        (unsigned int)VPTS,
                        (unsigned int)(current_inputAesFinished_cnt-previous_inputAesFinished_cnt),
                        (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_ptsExist,
                        current_Upper_pts_ms,
                        current_R2_pts_ms,
                        current_Upper_pts_ms-current_R2_pts_ms,
                        (int)(current_DMX_stc_ms-previous_DMX_stc_ms),
                        (int)(current_Upper_pts_ms-previous_Upper_pts_ms),
                        (int)(current_R2_pts_ms-previous_R2_pts_ms),
                        (int)(current_DMX_stc_ms-current_Upper_pts_ms),
                        (int)(current_DMX_stc_ms-current_R2_pts_ms),
                        (int)(current_DMX_stc_ms-VPTS) );

            previous_inputAesFinished_cnt = current_inputAesFinished_cnt;
            previous_DMX_stc_ms = current_DMX_stc_ms;
            previous_Upper_pts_ms = current_Upper_pts_ms;
            previous_R2_pts_ms = current_R2_pts_ms;
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Monitor_Interval);
    }
}

static void AU_CUS_ADEC_Underrun_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_Underrun_Monitor_bEnable)
    {
        if( (pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_bRegister == TRUE) && (pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) )
        {
            static MS_U32 u32Adec0DebounceCnt = 0;
            MS_U32 u32PCMlevelinMs = 0;
            AU_CUS_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL_IN_MS, &u32PCMlevelinMs);

            if(u32PCMlevelinMs < pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Threshold_in_ms)
            {
                u32Adec0DebounceCnt++;
                if((madCallBack.pFunc_Adec0_Underrun != NULL) && (u32Adec0DebounceCnt > pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_Debounce_Cnt) )
                {
                    madCallBack.pFunc_Adec0_Underrun(API_AUDIO_CUSTOMER_ADEC0);
                }
            }
            else
            {
                u32Adec0DebounceCnt = 0;
            }
        }

        if( (pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_bRegister == TRUE) && (pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) )
        {
            static MS_U32 u32Adec1DebounceCnt = 0;
            MS_U32 u32PCMlevelinMs = 0;
            AU_CUS_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC1, API_AUDIO_CUSTOMER_COMMON_INFO_PCM_BUFFER_CURRENT_LEVEL_IN_MS, &u32PCMlevelinMs);

            if(u32PCMlevelinMs < pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Threshold_in_ms)
            {
                u32Adec1DebounceCnt++;
                if((madCallBack.pFunc_Adec1_Underrun != NULL) && (u32Adec1DebounceCnt > pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_Debounce_Cnt) )
                {
                    madCallBack.pFunc_Adec1_Underrun(API_AUDIO_CUSTOMER_ADEC1);
                }
            }
            else
            {
                u32Adec1DebounceCnt = 0;
            }
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_AU_AdecUnderrun_Interval);
    }
}

static void AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor_bEnable)
    {
        if(CUSTOMIZED_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUTO_AUDIO_DELAY_ENABLE)
        {
            static API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
            static API_AUDIO_CUSTOMER_CODEC_TYPE current_audioType  = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
            static API_AUDIO_CUSTOMER_CODEC_TYPE previous_audioType = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
            static API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE current_hdmi_tx_output_type  = API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_INVALID;
            static API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE previous_hdmi_tx_output_type = API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_INVALID;

            adecIndex = pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput;

            switch(adecIndex)
            {
                case API_AUDIO_CUSTOMER_ADEC0:
                {
                    current_audioType = pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec;
                }
                break;

                case API_AUDIO_CUSTOMER_ADEC1:
                {
                    current_audioType = pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec;
                }
                break;

                default:
                    break;
            }

            current_hdmi_tx_output_type = pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType;

            //case1: code type change, reset delay.
            if(current_audioType != previous_audioType)
            {
                switch(current_audioType)
                {
                    case API_AUDIO_CUSTOMER_CODEC_TYPE_AC3:
                    {
                        if(current_hdmi_tx_output_type == API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DD_in_Auto_Audio_Delay;
                        }
                        else
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                        }
                    }
                    break;

                    case API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3:
                    {
                        if(current_hdmi_tx_output_type == API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DDP_in_Auto_Audio_Delay;
                        }
                        else
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                        }
                    }
                    break;

                    case API_AUDIO_CUSTOMER_CODEC_TYPE_AAC:
                    {
                        if(current_hdmi_tx_output_type == API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DP_in_Auto_Audio_Delay;
                        }
                        else
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                        }
                    }
                    break;

                    default:
                    {
                        pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                    }
                    break;
                }
            }

            //case2: hdmi tx type change, reset delay.
            if(current_hdmi_tx_output_type != previous_hdmi_tx_output_type)
            {
                if(current_hdmi_tx_output_type == API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM)
                {
                    switch(current_audioType)
                    {
                        case API_AUDIO_CUSTOMER_CODEC_TYPE_AC3:
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DD_in_Auto_Audio_Delay;
                        }
                        break;

                        case API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3:
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DDP_in_Auto_Audio_Delay;
                        }
                        break;

                        case API_AUDIO_CUSTOMER_CODEC_TYPE_AAC:
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_DP_in_Auto_Audio_Delay;
                        }
                        break;

                        default:
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                        }
                        break;
                    }
                }
                else
                {
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay;
                }
            }

            //check pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay is same as pstAudioCustomerShmData->g_audio_customer_SE_DriverDelay
            if(pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay != pstAudioCustomerShmData->g_audio_customer_SE_DriverDelay)
            {
                AU_CUS_INTERNAL_PATCH_SetAudioParam(adecIndex, AU_CUS_INTERNAL_PATCH_PARAM_MS12_HDMI_TX_PCM_AUDIO_DELAY, &pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay);
            }

            //set previous to current
            previous_audioType = current_audioType;
            previous_hdmi_tx_output_type = current_hdmi_tx_output_type;
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_internal_patch_Auto_Audio_Delay_Monitor_Interval);
    }
}

static void AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor(void)
{
    #if(CUSTOMIZED_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP)
    {
        //==================================================================================================================================
        // [Debug] Dump DEC PCM1 buffer
        //==================================================================================================================================
        static MS_U32 Base_Addr_Physical        = 0;
        static MS_U32 Bffer_Length              = 0;
        static MS_U32 End_Addr_Physical         = 0;
        static MS_U32 Current_Wptr_Physical     = 0;
        static MS_U32 Previous_Wptr_Physical    = 0;
        static MS_U32 copy_size                 = 0;

        //==================================================================================================================================
        // [Debug] Dump HDMI NonPCM buffer
        //==================================================================================================================================
        static MS_U32 Base_Addr_Physical2        = 0;
        static MS_U32 Bffer_Length2              = 0;
        static MS_U32 End_Addr_Physical2         = 0;
        static MS_U32 Current_Wptr_Physical2     = 0;
        static MS_U32 Previous_Wptr_Physical2    = 0;
        static MS_U32 copy_size2                 = 0;

        //==================================================================================================================================
        // [Debug] Dump MS12 Meta data buffer
        //==================================================================================================================================
        static MS_U32 Base_Addr_Physical3        = 0;
        static MS_U32 Bffer_Length3              = 0;
        static MS_U32 End_Addr_Physical3         = 0;
        static MS_U32 Current_Wptr_Physical3     = 0;
        static MS_U32 Previous_Wptr_Physical3    = 0;
        static MS_U32 copy_size3                 = 0;

        //==================================================================================================================================
        // [Debug] Dump DEC ES1 buffer (For HDMI RX NPCM, using Rdptr to dump ES1)
        //==================================================================================================================================
        static MS_U32 Base_Addr_Physical4        = 0;
        static MS_U32 Bffer_Length4              = 0;
        static MS_U32 End_Addr_Physical4         = 0;
        static MS_U32 Current_Wptr_Physical4     = 0;
        static MS_U32 Previous_Wptr_Physical4    = 0;
        static MS_U32 copy_size4                 = 0;

        //==================================================================================================================================

        while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor_bEnable)
        {
            if(pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable)
            {
                //==================================================================================================================================
                // [Debug] Dump DEC PCM1 buffer
                //==================================================================================================================================
                if(pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable)
                {
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_BASE, &Base_Addr_Physical);
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_SIZE, &Bffer_Length);
                    End_Addr_Physical = Base_Addr_Physical + Bffer_Length;
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_PCM1_BUF_WPTR, &Current_Wptr_Physical);

                    #if 0
                    AU_nPRINT("|Base:0x%-9x|buffLength:0x%-6x|End:0x%-9x|CurrWptr:0x%-9x|PrevWptr:0x%-9x|\n",
                                (unsigned int)Base_Addr_Physical,
                                (unsigned int)Bffer_Length,
                                (unsigned int)End_Addr_Physical,
                                (unsigned int)Current_Wptr_Physical,
                                (unsigned int)Previous_Wptr_Physical);
                    #endif

                    if(Current_Wptr_Physical > Previous_Wptr_Physical)
                    {
                        if(Current_Wptr_Physical - Previous_Wptr_Physical <= Bffer_Length)
                        {
                            //               case1:
                            //      Prev-> ----------- base Addr
                            //            |///////////|
                            //            |///////////|
                            //            |___________|
                            //      Curr->|           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |___________|end Addr

                            copy_size = Current_Wptr_Physical - Previous_Wptr_Physical;

                            if(pAU_GeneralBufferDumpFile != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical), sizeof(char), copy_size, pAU_GeneralBufferDumpFile);
                            }
                        }
                    }
                    else if(Current_Wptr_Physical < Previous_Wptr_Physical)
                    {
                        if(Current_Wptr_Physical == Base_Addr_Physical)
                        {

                            //               case2:
                            //      Curr-> ----------- base Addr
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //      Prev->|___________|
                            //            |///////////|
                            //            |///////////|
                            //            |___________|end Addr

                            copy_size = End_Addr_Physical - Previous_Wptr_Physical;

                            if(pAU_GeneralBufferDumpFile != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical), sizeof(char), copy_size, pAU_GeneralBufferDumpFile);
                            }
                        }
                        else if(Current_Wptr_Physical > Base_Addr_Physical)
                        {
                            //               case3:
                            //             ----------- base Addr
                            //            |///////////|
                            //      Curr->|___________|
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //            |           |
                            //      Prev->|___________|
                            //            |///////////|
                            //            |___________|end Addr

                            copy_size = End_Addr_Physical - Previous_Wptr_Physical;

                            if(pAU_GeneralBufferDumpFile != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical), sizeof(char), copy_size, pAU_GeneralBufferDumpFile);
                            }

                            copy_size = Current_Wptr_Physical - Base_Addr_Physical;

                            if(pAU_GeneralBufferDumpFile != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Base_Addr_Physical), sizeof(char), copy_size, pAU_GeneralBufferDumpFile);
                            }
                        }
                    }
                    Previous_Wptr_Physical = Current_Wptr_Physical;
                }

                //==================================================================================================================================
                // [Debug] Dump HDMI NonPCM buffer
                //==================================================================================================================================
                if(pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable)
                {
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_BASE, &Base_Addr_Physical2);
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_SIZE, &Bffer_Length2);
                    End_Addr_Physical2 = Base_Addr_Physical2 + Bffer_Length2;
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_HDMI_NPCM_BUF_WPTR, &Current_Wptr_Physical2);

                    #if 0
                    AU_nPRINT("|Base:0x%-9x|buffLength:0x%-6x|End:0x%-9x|CurrWptr:0x%-9x|PrevWptr:0x%-9x|\n",
                                (unsigned int)Base_Addr_Physical2,
                                (unsigned int)Bffer_Length2,
                                (unsigned int)End_Addr_Physical2,
                                (unsigned int)Current_Wptr_Physical2,
                                (unsigned int)Previous_Wptr_Physical2);
                    #endif

                    if(Current_Wptr_Physical2 > Previous_Wptr_Physical2)
                    {
                        if(Current_Wptr_Physical2 - Previous_Wptr_Physical2 <= Bffer_Length2)
                        {
                            copy_size2 = Current_Wptr_Physical2 - Previous_Wptr_Physical2;

                            if(pAU_GeneralBufferDumpFile2 != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical2), sizeof(char), copy_size2, pAU_GeneralBufferDumpFile2);
                            }
                        }
                    }
                    else if(Current_Wptr_Physical2 < Previous_Wptr_Physical2)
                    {
                        if(Current_Wptr_Physical2 == Base_Addr_Physical2)
                        {
                            copy_size2 = End_Addr_Physical2 - Previous_Wptr_Physical2;

                            if(pAU_GeneralBufferDumpFile2 != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical2), sizeof(char), copy_size2, pAU_GeneralBufferDumpFile2);
                            }
                        }
                        else if(Current_Wptr_Physical2 > Base_Addr_Physical2)
                        {
                            copy_size2 = End_Addr_Physical2 - Previous_Wptr_Physical2;

                            if(pAU_GeneralBufferDumpFile2 != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical2), sizeof(char), copy_size2, pAU_GeneralBufferDumpFile2);
                            }

                            copy_size2 = Current_Wptr_Physical2 - Base_Addr_Physical2;

                            if(pAU_GeneralBufferDumpFile2 != NULL)
                            {
                                AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Base_Addr_Physical2), sizeof(char), copy_size2, pAU_GeneralBufferDumpFile2);
                            }
                        }
                    }
                    Previous_Wptr_Physical2 = Current_Wptr_Physical2;
                }

                //==================================================================================================================================
                // [Debug] Dump MS12 Meta data buffer
                //==================================================================================================================================
                if(pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable)
                {
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_BASE, &Base_Addr_Physical3);
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_SIZE, &Bffer_Length3);
                    End_Addr_Physical3 = Base_Addr_Physical3 + Bffer_Length3;
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_MS12_DDPE_METADATA_BUF_WPTR, &Current_Wptr_Physical3);

                    #if 0
                    AU_nPRINT("|Base:0x%-9x|buffLength:0x%-6x|End:0x%-9x|CurrWptr:0x%-9x|PrevWptr:0x%-9x|\n",
                                (unsigned int)Base_Addr_Physical3,
                                (unsigned int)Bffer_Length3,
                                (unsigned int)End_Addr_Physical3,
                                (unsigned int)Current_Wptr_Physical3,
                                (unsigned int)Previous_Wptr_Physical3);
                    #endif

                    if(Current_Wptr_Physical3 > Previous_Wptr_Physical3)
                    {
                        if(Current_Wptr_Physical3 - Previous_Wptr_Physical3 <= Bffer_Length3)
                        {
                            copy_size3 = Current_Wptr_Physical3 - Previous_Wptr_Physical3;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical3), sizeof(char), copy_size3, pAU_GeneralBufferDumpFile3);
                        }
                    }
                    else if(Current_Wptr_Physical3 < Previous_Wptr_Physical3)
                    {
                        if(Current_Wptr_Physical3 == Base_Addr_Physical3)
                        {
                            copy_size3 = End_Addr_Physical3 - Previous_Wptr_Physical3;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical3), sizeof(char), copy_size3, pAU_GeneralBufferDumpFile3);
                        }
                        else if(Current_Wptr_Physical3 > Base_Addr_Physical3)
                        {
                            copy_size3 = End_Addr_Physical3 - Previous_Wptr_Physical3;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical3), sizeof(char), copy_size3, pAU_GeneralBufferDumpFile3);

                            copy_size3 = Current_Wptr_Physical3 - Base_Addr_Physical3;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Base_Addr_Physical3), sizeof(char), copy_size3, pAU_GeneralBufferDumpFile3);
                        }
                    }
                    Previous_Wptr_Physical3 = Current_Wptr_Physical3;
                }

                //==================================================================================================================================
                // [Debug] Dump DEC ES1 buffer (For HDMI RX NPCM, using Rdptr to dump ES1)
                //==================================================================================================================================
                if(pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable)
                {
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_BASE, &Base_Addr_Physical4);
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_SIZE, &Bffer_Length4);
                    End_Addr_Physical4 = Base_Addr_Physical4 + Bffer_Length4;
                    API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_DEC_ES1_BUF_RPTR, &Current_Wptr_Physical4);

                    #if 0
                    AU_nPRINT("|Base:0x%-9x|buffLength:0x%-6x|End:0x%-9x|CurrWptr:0x%-9x|PrevWptr:0x%-9x|\n",
                                (unsigned int)Base_Addr_Physical4,
                                (unsigned int)Bffer_Length4,
                                (unsigned int)End_Addr_Physical4,
                                (unsigned int)Current_Wptr_Physical4,
                                (unsigned int)Previous_Wptr_Physical4);
                    #endif

                    if(Current_Wptr_Physical4 > Previous_Wptr_Physical4)
                    {
                        if(Current_Wptr_Physical4 - Previous_Wptr_Physical4 <= Bffer_Length4)
                        {
                            copy_size4 = Current_Wptr_Physical4 - Previous_Wptr_Physical4;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical4), sizeof(char), copy_size4, pAU_GeneralBufferDumpFile4);
                        }
                    }
                    else if(Current_Wptr_Physical4 < Previous_Wptr_Physical4)
                    {
                        if(Current_Wptr_Physical4 == Base_Addr_Physical4)
                        {
                            copy_size4 = End_Addr_Physical4 - Previous_Wptr_Physical4;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical4), sizeof(char), copy_size4, pAU_GeneralBufferDumpFile4);
                        }
                        else if(Current_Wptr_Physical4 > Base_Addr_Physical4)
                        {
                            copy_size4 = End_Addr_Physical4 - Previous_Wptr_Physical4;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical4), sizeof(char), copy_size4, pAU_GeneralBufferDumpFile4);

                            copy_size4 = Current_Wptr_Physical4 - Base_Addr_Physical4;
                            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Base_Addr_Physical4), sizeof(char), copy_size4, pAU_GeneralBufferDumpFile4);
                        }
                    }
                    Previous_Wptr_Physical4 = Current_Wptr_Physical4;
                }

            }

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_Monitor_Interval);
        }
    }
    #endif
}

static void AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor(void)
{
    #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE)
    {
        while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor_bEnable)
        {
            if(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_bEnable)
            {
                MS_U32 bDDP_71_Stream = 0;
                int okFrmCnt = 0;
                int chkCnt = 0;
                AUDIO_DEC_ID DecID = AU_DEC_INVALID;
                AU_UNUSED(DecID);

                switch(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex)
                {
                    case API_AUDIO_CUSTOMER_ADEC0:
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = 100000;
                        }
                        else
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = 1000;
                        }
                    }
                    break;

                    case API_AUDIO_CUSTOMER_ADEC1:
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect == API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = 100000;
                        }
                        else
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = 1000;
                        }
                    }
                    break;

                    default:
                    {
                        pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = 1000;
                    }
                    break;
                }


                for(chkCnt = 0; chkCnt < pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt; chkCnt++)
                {
                    AU_CUS_GetAudioInfo(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex, API_AUDIO_CUSTOMER_COMMON_INFO_OK_FRAME_CNT, &okFrmCnt);
                    if(okFrmCnt >= 10)
                    {
                        break;
                    }
                }

                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt = okFrmCnt;

                AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt);
                AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt     = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt);

                #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_STB_HDMI_TX)
                {
                    bDDP_71_Stream = MApi_AUDIO_GetAC3PInfo(Audio_AC3P_infoType_DDP_71_Stream);
                    if(bDDP_71_Stream)
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType != API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = TRUE;
                            AU_CUS_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3_BYPASS);
                            AU_CUS_PATCH_SeDSP_MS12_Enc_wo_Main_Snd_disable();
                        }
                    }
                    else
                    {
                        pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = FALSE;
                        AU_CUS_HDMI_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType);
                    }
                }
                #endif

                #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_TV_HDMI_ARC)
                {
                    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex);
                    MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_Is_DDP_8ch_Stream, &bDDP_71_Stream);

                    AU_nDBG("[bDDP_71_Stream = %d] \n", (unsigned int)bDDP_71_Stream);
                    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);

                    if(bDDP_71_Stream)
                    {
                        if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType != API_AUDIO_CUSTOMER_SPDIF_TX_PCM)
                        {
                            pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = TRUE;
                            AU_CUS_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_BYPASS);
                            AU_CUS_PATCH_SndR2_MS12_Enc_wo_Main_Snd_disable();
                        }
                    }
                    else
                    {
                        pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream = FALSE;
                        AU_CUS_SPDIF_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);
                    }
                }
                #endif

                pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_bEnable = FALSE;

                AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay);
                AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay);

                /* Make sure current cmd is still UPPER_PLAY */
                if( (pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex == API_AUDIO_CUSTOMER_ADEC0 && pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) ||
                    (pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex == API_AUDIO_CUSTOMER_ADEC1 && pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY) )
                {
                    /* Start decode */
                    AU_CUS_SetPlayCmdByAdecSource(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex);
                }

                /* Recover sync mode */
                switch(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_adecIndex)
                {
                    case API_AUDIO_CUSTOMER_ADEC0:
                    {
                        AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode);
                    }
                    break;

                    case API_AUDIO_CUSTOMER_ADEC1:
                    {
                        AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC1, pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode);
                    }
                    break;

                    default:
                        break;
                }
            }

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Monitor_Interval);
        }
    }
    #endif
}

static void AU_CUS_PATCH_Dump_R2_Log_Monitor(void)
{
    #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
    {
        static MS_U32 Base_Addr_Physical        = 0;
        static MS_U32 Bffer_Length              = 0;
        static MS_U32 End_Addr_Physical         = 0;
        static MS_U32 Current_Wptr_Physical     = 0;
        static MS_U32 Previous_Wptr_Physical    = 0;

        while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_PATCH_Dump_R2_Log_Monitor_bEnable)
        {
            if(pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable)
            {
                API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_BASE, &Base_Addr_Physical);
                API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_SIZE, &Bffer_Length);
                End_Addr_Physical = Base_Addr_Physical + Bffer_Length;
                API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_INFO_R2_UART_BUF_WPTR, &Current_Wptr_Physical);

                #if 0
                AU_nPRINT("|Base:0x%-9x|buffLength:0x%-6x|End:0x%-9x|CurrWptr:0x%-9x|PrevWptr:0x%-9x|c-p=%-9d\n",
                            (unsigned int)Base_Addr_Physical,
                            (unsigned int)Bffer_Length,
                            (unsigned int)End_Addr_Physical,
                            (unsigned int)Current_Wptr_Physical,
                            (unsigned int)Previous_Wptr_Physical,
                            (int)((int)Current_Wptr_Physical-(int)Previous_Wptr_Physical) );
                #endif

                int copy_size1, copy_size2, copy_length;

                if (!Previous_Wptr_Physical)
                {
                    Previous_Wptr_Physical = Base_Addr_Physical;
                }

                copy_length = Current_Wptr_Physical - Previous_Wptr_Physical;
                if (copy_length < 0)
                {
                    copy_length += Bffer_Length;
                }

                if (copy_length >= (End_Addr_Physical - Previous_Wptr_Physical))
                {
                    copy_size1 = End_Addr_Physical - Previous_Wptr_Physical;
                    copy_size2 = copy_length - copy_size1;

                    if(pAU_R2LogBufferDumpFile != NULL)
                    {
                        AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical), sizeof(char), copy_size1, pAU_R2LogBufferDumpFile);
                        AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Base_Addr_Physical),     sizeof(char), copy_size2, pAU_R2LogBufferDumpFile);
                    }
                }
                else
                {
                    if(pAU_R2LogBufferDumpFile != NULL)
                    {
                        AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(Previous_Wptr_Physical), sizeof(char), copy_length, pAU_R2LogBufferDumpFile);
                    }
                }

                Previous_Wptr_Physical = Current_Wptr_Physical;
            }

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_patch_Dump_R2_Log_Monitor_Interval);
        }
    }
    #endif
}

static void AU_CUS_ThreadPrintMsg_Monitor(void)
{
    while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_ThreadPrintMsg_Monitor_bEnable)
    {
        if(pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg)
        {
            pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg = TRUE;

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval);

            pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg = FALSE;
            pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Line = 0;

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval);
        }

        AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval);
    }
}

static void AU_CUS_INTERNAL_PATCH_R2_Active_Monitor(void)
{
    #if(CUSTOMIZED_INTERNAL_PATCH_R2_ACTIVE_MONITOR_ENABLE)
    {
        MS_U32 u32R2_ACK1_Response = 0;

        while(pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_R2_Active_Monitor_bEnable)
        {
            if( (g_api_audio_InitializeModule_R2_bActive == FALSE) && (pstAudioCustomerShmData->g_audio_customer_Init_Done == TRUE) )
            {
                u32R2_ACK1_Response = (MS_U32)AU_CUS_ReadAbsReg(REG_DECR2_ACK1);
                //AU_nPRINT("[u32R2_ACK1_Response = 0x%x] \n", (unsigned int)u32R2_ACK1_Response);

                if(u32R2_ACK1_Response == REG_DECR2_ACK1_RESPONSE)
                {
                    g_api_audio_InitializeModule_R2_bActive = TRUE;
                    break;
                }
                else
                {
                    g_api_audio_InitializeModule_R2_bActive = FALSE;
                }
            }

            AU_CUS_Delay1MS(pstAudioCustomerShmData->g_audio_customer_internal_patch_R2_Active_Monitor_Interval);
        }
    }
    #endif
}

//AU Demo MM New Mode Enter point
MS_BOOL AU_CUS_Demo_MM_New_Mode_Play(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo, MS_U32 bufSize, void *pExternalBuf)
{
    AU_nDBG("[adecIndex             = 0x%x] \n", (unsigned int)adecIndex);
    AU_nDBG("[clipInfo.clipType     = 0x%x] \n", (unsigned int)clipInfo.clipType);
    AU_nDBG("[clipInfo.repeatNumber = 0x%x] \n", (unsigned int)clipInfo.repeatNumber);
    AU_nDBG("[bufSize               = 0x%x] \n", (unsigned int)bufSize);

    //update DecInfo for AU_CUS_Demo_MM_New_Mode_Play_Monitor
    AU_Demo_MM_New_Mode_DecInfo.adecIndex    = adecIndex;
    AU_Demo_MM_New_Mode_DecInfo.extBufaddr_V = pExternalBuf;
    AU_Demo_MM_New_Mode_DecInfo.u32Size      = bufSize;
    AU_Demo_MM_New_Mode_DecInfo.u32RepeatNum = clipInfo.repeatNumber;
    AU_Demo_MM_New_Mode_DecInfo.bIsPause     = FALSE;
    AU_Demo_MM_New_Mode_DecInfo.bIsStart     = FALSE;

    // Step2: Buffer init
    AU_CUS_Demo_MM_New_Mode_AllBufInit(adecIndex);

    // step3: control Wptr of External buffer.
    pAU_Demo_MM_New_Mode_DecExtBufInfo->u32BufWptr_V += AU_Demo_MM_New_Mode_DecInfo.u32Size;

    // Step4: Start decoding
    API_AUDIO_CUSTOMER_StartDecoding(adecIndex);

    // Step5: Start play monitor thread
    AU_Demo_MM_New_Mode_DecInfo.bIsStart = TRUE;

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_Stop(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_DecInfo.bIsStart = FALSE;

    API_AUDIO_CUSTOMER_StopDecoding(adecIndex);

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_Pause(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_DecInfo.bIsPause = TRUE;

    API_AUDIO_CUSTOMER_PauseDecoding(adecIndex);

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_Resume(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_DecInfo.bIsPause = FALSE;

    API_AUDIO_CUSTOMER_StartDecoding(adecIndex);

    return TRUE;
}

//AU Demo MM New Mode (AD) Enter point
MS_BOOL AU_CUS_Demo_MM_New_Mode_AD_Play(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo, MS_U32 bufSize, void *pExternalBuf)
{
    AU_nDBG("[adecIndex             = 0x%x] \n", (unsigned int)adecIndex);
    AU_nDBG("[clipInfo.clipType     = 0x%x] \n", (unsigned int)clipInfo.clipType);
    AU_nDBG("[clipInfo.repeatNumber = 0x%x] \n", (unsigned int)clipInfo.repeatNumber);
    AU_nDBG("[bufSize               = 0x%x] \n", (unsigned int)bufSize);

    //update DecInfo for AU_CUS_Demo_MM_New_Mode_Play_Monitor
    AU_Demo_MM_New_Mode_AD_DecInfo.adecIndex    = adecIndex;
    AU_Demo_MM_New_Mode_AD_DecInfo.extBufaddr_V = pExternalBuf;
    AU_Demo_MM_New_Mode_AD_DecInfo.u32Size      = bufSize;
    AU_Demo_MM_New_Mode_AD_DecInfo.u32RepeatNum = clipInfo.repeatNumber;
    AU_Demo_MM_New_Mode_AD_DecInfo.bIsPause     = FALSE;
    AU_Demo_MM_New_Mode_AD_DecInfo.bIsStart     = FALSE;

    // Step2: Buffer init
    AU_CUS_Demo_MM_New_Mode_AD_AllBufInit(adecIndex);

    // step3: control Wptr of AD External buffer.
    pAU_Demo_MM_New_Mode_AD_DecExtBufInfo->u32BufWptr_V += AU_Demo_MM_New_Mode_AD_DecInfo.u32Size;

    // Step4: Start play AD monitor thread
    AU_Demo_MM_New_Mode_AD_DecInfo.bIsStart = TRUE;

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_AD_Stop(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_AD_DecInfo.bIsStart = FALSE;

    API_AUDIO_CUSTOMER_StopDecoding(adecIndex);

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_AD_Pause(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_AD_DecInfo.bIsPause = TRUE;

    API_AUDIO_CUSTOMER_PauseDecoding(adecIndex);

    return TRUE;
}

MS_BOOL AU_CUS_Demo_MM_New_Mode_AD_Resume(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    AU_Demo_MM_New_Mode_AD_DecInfo.bIsPause = FALSE;

    API_AUDIO_CUSTOMER_StartDecoding(adecIndex);

    return TRUE;
}

// AU_Demo (MM New Mode) (PCM Path: MCU)
static MS_BOOL AU_CUS_Demo_MM_New_Mode_AdecPcmCallBackFun(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 copySize)
{
    if(AU_DEMO_MM_NEW_MODE_GET_PCM_BUFFER_SIZE < copySize)
    {
        AU_nPRINT("warning: buffer size is not enough, copySize = %d \n", (unsigned int)copySize);
    }

    API_AUDIO_CUSTOMER_AdecPcmGet(adecIndex, pAU_Demo_MM_New_Mode_Get_PCM_Buffer, copySize);

    if(pAU_Demo_MM_New_Mode_AdecPcmDump != NULL)
    {
        AU_CUS_FileWrite(pAU_Demo_MM_New_Mode_Get_PCM_Buffer, sizeof(char), copySize, pAU_Demo_MM_New_Mode_AdecPcmDump);
    }
    return TRUE;
}

// AU_Demo (MM New Mode) (End of Stream)
static MS_BOOL AU_CUS_Demo_MM_New_Mode_EndOfStreamCallBackFun(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nPRINT("[adecIndex = 0x%x] End of Stream !! \n", (unsigned int)adecIndex);

    API_AUDIO_CUSTOMER_StopDecoding(adecIndex);

    return TRUE;
}

// AU_Demo (MM New Mode) (ADEC Underrun)
static MS_BOOL AU_CUS_Demo_MM_New_Mode_AdecUnderrunCallBackFun(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nPRINT("[adecIndex = 0x%x] Underrun !! \n", (unsigned int)adecIndex);

    return TRUE;
}

#if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
// AU_Demo (HDMI RX Monitor Event)
static MS_BOOL AU_CUS_Demo_HDMI_Monitor_Event_CallBackFun(API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT eventType, API_AUDIO_CUSTOMER_HDMI_MONITOR_EVENT_INFO info)
{
    AU_nPRINT("[eventType = 0x%x] [info = 0x%x] !! \n", (unsigned int)eventType, (unsigned int)info);

    return TRUE;
}
#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// [Distinction Area] [kernel space / user space] [function] declare / implement in this area.
//-------------------------------------------------------------------------------------------------------------------------------------
//0x9993
void AU_CUS_Where_Am_I(void)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello Kernel Space] \n", __FUNCTION__, __LINE__);
    }
    #else //User Space
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello User Space] \n", __FUNCTION__, __LINE__);
    }
    #endif

    #ifdef AUDIO_UTOPIA_20 //Utopia 2.0
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello Utopia 2.0] \n", __FUNCTION__, __LINE__);
    }
    #else //Utopia 1.0
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello Utopia 1.0] \n", __FUNCTION__, __LINE__);
    }
    #endif

    #ifdef CONFIG_MBOOT //mboot
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello mboot] \n", __FUNCTION__, __LINE__);
    }
    #else //application
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Hello Application] \n", __FUNCTION__, __LINE__);
    }
    #endif
}

int AU_CUS_strcmp(const char * str1, const char * str2, size_t n)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        #if(LINUX_KERNEL_VERSION_4_4_3)
        {
            return strncasecmp(str1, str2, n);
        }
        #else
        {
            return strnicmp(str1, str2, n);
        }
        #endif
    }
    #else //User Space
    {
        return strcmp(str1, str2);
    }
    #endif
}

void AU_CUS_Delay1MS(int delay1MS)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        msleep(delay1MS);
    }
    #else //User Space
    {
        MsOS_DelayTask(delay1MS);
    }
    #endif
}

static MS_BOOL AU_CUS_ShmInit(void)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        if(pstAudioCustomerShmData) return TRUE;

        if(pstAudioCustomerShmData == NULL)
        {
            pstAudioCustomerShmData = &stAudioCustomerShmData;
            AU_CUS_ShmInit_All_variables();
        }
        return TRUE;
    }
    #else //User Space
    {
        MS_U32 u32ShmId;
        MS_U32 u32Addr;
        MS_U32 u32BufSize;
        char SHM_ID[] = "Audio_Customer driver";
        MS_BOOL bFirstRun = FALSE;

        if(pstAudioCustomerShmData) return TRUE;

        MsOS_SHM_Init();

        if(FALSE == MsOS_SHM_GetId((MS_U8 *)SHM_ID, sizeof(St_Audio_Customer_Shm_data), &u32ShmId, &u32Addr, &u32BufSize, SYS_SHM_QUERY))
        {
            if(FALSE == MsOS_SHM_GetId((MS_U8 *)SHM_ID, sizeof(St_Audio_Customer_Shm_data), &u32ShmId, &u32Addr, &u32BufSize, SYS_SHM_CREATE))
            {
                return FALSE;
            }
            memset((MS_U8 *)u32Addr, 0, sizeof(St_Audio_Customer_Shm_data));
            bFirstRun = TRUE;
        }

        pstAudioCustomerShmData = (St_Audio_Customer_Shm_data *)u32Addr;

        if(pstAudioCustomerShmData == NULL)
        {
            return FALSE;
        }

        // first time to access, so init the data
        if(bFirstRun == TRUE)
        {
            AU_CUS_ShmInit_All_variables();
        }
        return TRUE;
    }
    #endif
}

void AU_CUS_Mutex_Init(void)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_init(&AU_Customer_ReadAbsReg_mutex_lock);
        mutex_init(&AU_Customer_WriteAbsReg_mutex_lock);
        mutex_init(&AU_Customer_ReadDM_mutex_lock);
        mutex_init(&AU_Customer_WriteDM_mutex_lock);
        mutex_init(&AU_Customer_ReadPM_mutex_lock);
        mutex_init(&AU_Customer_WritePM_mutex_lock);
        mutex_init(&AU_Customer_ReadAbsXbox_mutex_lock);
        mutex_init(&AU_Customer_WriteAbsXbox_mutex_lock);
        mutex_init(&AU_Customer_MM2_initAesInfo_mutex_lock);
        mutex_init(&AU_Customer_MM2_checkAesInfo_mutex_lock);
        mutex_init(&AU_Customer_MM2_inputAesFinished_mutex_lock);
        mutex_init(&AU_Customer_SPDIF_TX_SetOutputType_mutex_lock);
    }
    #else //User Space
    {
        if(AU_Customer_ReadAbsReg_mutex_lock == -1)
        {
            AU_Customer_ReadAbsReg_mutex_lock = OS_CREATE_MUTEX(AU_Customer_ReadAbsReg);
            if (AU_Customer_ReadAbsReg_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_WriteAbsReg_mutex_lock == -1)
        {
            AU_Customer_WriteAbsReg_mutex_lock = OS_CREATE_MUTEX(AU_Customer_WriteAbsReg);
            if (AU_Customer_WriteAbsReg_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_ReadDM_mutex_lock == -1)
        {
            AU_Customer_ReadDM_mutex_lock = OS_CREATE_MUTEX(AU_Customer_ReadDM);
            if (AU_Customer_ReadDM_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_WriteDM_mutex_lock == -1)
        {
            AU_Customer_WriteDM_mutex_lock = OS_CREATE_MUTEX(AU_Customer_WriteDM);
            if (AU_Customer_WriteDM_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_ReadPM_mutex_lock == -1)
        {
            AU_Customer_ReadPM_mutex_lock = OS_CREATE_MUTEX(AU_Customer_ReadPM);
            if (AU_Customer_ReadPM_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_WritePM_mutex_lock == -1)
        {
            AU_Customer_WritePM_mutex_lock = OS_CREATE_MUTEX(AU_Customer_WritePM);
            if (AU_Customer_WritePM_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_ReadAbsXbox_mutex_lock == -1)
        {
            AU_Customer_ReadAbsXbox_mutex_lock = OS_CREATE_MUTEX(AU_Customer_ReadAbsXbox);
            if (AU_Customer_ReadAbsXbox_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_WriteAbsXbox_mutex_lock == -1)
        {
            AU_Customer_WriteAbsXbox_mutex_lock = OS_CREATE_MUTEX(AU_Customer_WriteAbsXbox);
            if (AU_Customer_WriteAbsXbox_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_MM2_initAesInfo_mutex_lock == -1)
        {
            AU_Customer_MM2_initAesInfo_mutex_lock = OS_CREATE_MUTEX(AU_Customer_MM2_initAesInfo);
            if (AU_Customer_MM2_initAesInfo_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_MM2_checkAesInfo_mutex_lock == -1)
        {
            AU_Customer_MM2_checkAesInfo_mutex_lock = OS_CREATE_MUTEX(AU_Customer_MM2_checkAesInfo);
            if (AU_Customer_MM2_checkAesInfo_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_MM2_inputAesFinished_mutex_lock == -1)
        {
            AU_Customer_MM2_inputAesFinished_mutex_lock = OS_CREATE_MUTEX(AU_Customer_MM2_inputAesFinished);
            if (AU_Customer_MM2_inputAesFinished_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }

        if(AU_Customer_SPDIF_TX_SetOutputType_mutex_lock == -1)
        {
            AU_Customer_SPDIF_TX_SetOutputType_mutex_lock = OS_CREATE_MUTEX(AU_Customer_SPDIF_TX_SetOutputType);
            if (AU_Customer_SPDIF_TX_SetOutputType_mutex_lock == -1)
            {
                AU_nPRINT("[%d]Error! Create Mutex failed!\n", __LINE__);
            }
        }
    }
    #endif
}

static MS_U16 AU_CUS_ReadAbsReg(MS_U32 regaddr)
{
    MS_U32 pInfo = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_ReadAbsReg_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_ReadAbsReg_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_ReadReg_Target, regaddr);
    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID1, Audio_infoType_Abs_ReadReg, (void *)&pInfo);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_ReadAbsReg_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_ReadAbsReg_mutex_lock);
    }
    #endif

    return (MS_U16)pInfo;
}

static void AU_CUS_WriteAbsReg(MS_U32 regaddr, MS_U16 data)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_WriteAbsReg_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_WriteAbsReg_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_WriteReg_Target, regaddr);
    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_WriteReg_Value, (MS_U32)data);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_WriteAbsReg_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_WriteAbsReg_mutex_lock);
    }
    #endif
}

static void AU_CUS_WriteAbsMaskReg(MS_U32 u32RegAddr, MS_U16 u16Mask, MS_U16 u16Val)
{
    MS_U16 u16RegVal;

    u16RegVal = AU_CUS_ReadAbsReg(u32RegAddr);
    u16RegVal = ((u16RegVal & (~(u16Mask))) | (u16Val & u16Mask));
    AU_CUS_WriteAbsReg(u32RegAddr, u16RegVal);
}

static MS_U16 AU_CUS_ReadDM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_BOOL bIsIDMA)
{
    MS_U32 pInfo = 0;
    MS_U16 tmpReg = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_ReadDM_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_ReadDM_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(bIsIDMA)
    {
        tmpReg = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA);
        AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x80, 0);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 8, ((MS_U16)regaddr | 0x08000));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x0B);
        AU_CUS_Delay1MS(5);
        pInfo = (MS_U32)AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 12);
        pInfo = (pInfo << 8) + (MS_U32)(AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 14) & 0xFF);

        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, tmpReg);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_ReadDM_Target, regaddr);
        MApi_AUDIO_GetAudioInfo2( DecID, Audio_infoType_ReadDM_Value, (void *)&pInfo);
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_ReadDM_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_ReadDM_mutex_lock);
    }
    #endif

    return (MS_U16)pInfo;
}

static void AU_CUS_WriteDM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_U16 data, MS_BOOL bIsIDMA)
{
    MS_U16 tmpReg = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_WriteDM_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_WriteDM_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(bIsIDMA)
    {
        tmpReg = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA);
        AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x80, 0);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 4, ((MS_U16)regaddr | 0x08000));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 2, (MS_U16)((data & 0xFFFF00)>>8));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 2, (MS_U16)(data & 0x0FF));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, tmpReg);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_WriteDM_Target, regaddr);
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_WriteDM_Value, (MS_U32)data);
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_WriteDM_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_WriteDM_mutex_lock);
    }
    #endif
}

static MS_U16 AU_CUS_ReadPM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_BOOL bIsIDMA)
{
    MS_U32 pInfo = 0;
    MS_U16 tmpReg = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_ReadPM_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_ReadPM_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(bIsIDMA)
    {
        tmpReg = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA);
        AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x80, 0);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 8, (MS_U16)regaddr);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x0B);
        AU_CUS_Delay1MS(5);
        pInfo = (MS_U32)AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 12);
        pInfo = (pInfo << 8) + (MS_U32)(AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 14) & 0xFF);

        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, tmpReg);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_ReadPM_Target, regaddr);
        MApi_AUDIO_GetAudioInfo2( DecID, Audio_infoType_ReadPM_Value, (void *)&pInfo);
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_ReadPM_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_ReadPM_mutex_lock);
    }
    #endif

    return (MS_U16)pInfo;
}

static void AU_CUS_WritePM(AUDIO_DEC_ID DecID, MS_U32 regaddr, MS_U32 data, MS_BOOL bIsIDMA)
{
    MS_U16 tmpReg = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_WritePM_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_WritePM_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(bIsIDMA)
    {
        tmpReg = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA);
        AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_ASND_DSP_IDMA, 0x80, 0);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 4, (MS_U16)regaddr);
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 2, (MS_U16)((data & 0xFFFF00)>>8));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA + 2, (MS_U16)(data & 0x0FF));
        AU_CUS_Delay1MS(5);
        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_IDMA, tmpReg);
    }
    else
    {
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_WritePM_Target, regaddr);
        MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_WritePM_Value, (MS_U32)data);
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_WritePM_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_WritePM_mutex_lock);
    }
    #endif
}

static MS_U32 AU_CUS_ReadAbsXbox(MS_U32 xboxaddr)
{
    MS_U32 pInfo = 0;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_ReadAbsXbox_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_ReadAbsXbox_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_ReadXbox_Target, xboxaddr);
    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID1, Audio_infoType_Abs_ReadXbox, (void *)&pInfo);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_ReadAbsXbox_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_ReadAbsXbox_mutex_lock);
    }
    #endif

    return (MS_U32)pInfo;
}

static void AU_CUS_WriteAbsXbox(MS_U32 xboxaddr, MS_U32 data)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_WriteAbsXbox_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_WriteAbsXbox_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_WriteXbox_Target, xboxaddr);
    MApi_AUDIO_SetAudioParam2(AU_DEC_ID1, Audio_ParamType_Abs_WriteXbox_Value, (MS_U32)data);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_WriteAbsXbox_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_WriteAbsXbox_mutex_lock);
    }
    #endif
}

static void AU_CUS_CreateThread(void)
{
    #ifdef CONFIG_MBOOT //mboot
    {
    }
    #else //application
    {
        //================================================================================================
        //                   Clip Decoder Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pClipDecoderThread = NULL;

            pClipDecoderThread = kthread_create((void*)AU_CUS_ClipDecoderMonitor, NULL, "MStar Clip Decoder Monitor");
            if (pClipDecoderThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create clip decoder monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("Clip decoder monitor thread created successfully \n");
                wake_up_process(pClipDecoderThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info0;
            pthread_attr_t      attr0;
            struct sched_param  sched0;
            int                 s32Result0;

            pthread_attr_init(&attr0);
            pthread_attr_setdetachstate(&attr0, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr0, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr0, SCHED_RR);
            pthread_attr_getschedparam(&attr0, &sched0);
            sched0.sched_priority = 85;
            pthread_attr_setschedparam(&attr0, &sched0);

            s32Result0 = pthread_create(&thread_info0, &attr0, (void*)AU_CUS_ClipDecoderMonitor, (void *) NULL);
            if (s32Result0 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create clip decoder monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("Clip decoder monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   MP3 Encode Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pMP3EncodeThread = NULL;

            pMP3EncodeThread = kthread_create((void*)AU_CUS_MP3EncodeMonitor, NULL, "MStar MP3 encode Monitor");
            if (pMP3EncodeThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create mp3 encode monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("mp3 encode monitor thread created successfully \n");
                wake_up_process(pMP3EncodeThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info1;
            pthread_attr_t      attr1;
            struct sched_param  sched1;
            int                 s32Result1;

            pthread_attr_init(&attr1);
            pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr1, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr1, SCHED_RR);
            pthread_attr_getschedparam(&attr1, &sched1);
            sched1.sched_priority = 85;
            pthread_attr_setschedparam(&attr1, &sched1);

            s32Result1 = pthread_create(&thread_info1, &attr1, (void*)AU_CUS_MP3EncodeMonitor, (void *) NULL);
            if (s32Result1 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create mp3 encode monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("mp3 encode monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        // Audio monitor Service for:
        // 1. HDMI Tx (STB_ENABLE only)
        // 2. SPDIF
        // 3. Audio Auto-Recovery
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pMonitorServiceThread = NULL;

            pMonitorServiceThread = kthread_create((void*)AU_CUS_MonitorService, NULL, "AU_CUS_MonitorService");
            if (pMonitorServiceThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_MonitorService thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_MonitorService thread created successfully \n");
                wake_up_process(pMonitorServiceThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info2;
            pthread_attr_t      attr2;
            struct sched_param  sched2;
            int                 s32Result2;

            pthread_attr_init(&attr2);
            pthread_attr_setdetachstate(&attr2, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr2, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr2, SCHED_RR);
            pthread_attr_getschedparam(&attr2, &sched2);
            sched2.sched_priority = 85;
            pthread_attr_setschedparam(&attr2, &sched2);

            s32Result2 = pthread_create(&thread_info2, &attr2, (void*)AU_CUS_MonitorService, (void *) NULL);
            if (s32Result2 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_MonitorService thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_MonitorService thread created successfully \n");
            }
        }
        #endif

        #if (UTPA_SUPPORT_AAC_ENCODE == 1)
        //================================================================================================
        //                   AAC Encode Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAACEncodeThread = NULL;

            pAACEncodeThread = kthread_create((void*)AU_CUS_AACEncodeMonitor, NULL, "MStar AAC encode Monitor");
            if (pAACEncodeThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create aac encode monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("aac encode monitor thread created successfully \n");
                wake_up_process(pAACEncodeThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info3;
            pthread_attr_t      attr3;
            struct sched_param  sched3;
            int                 s32Result3;

            pthread_attr_init(&attr3);
            pthread_attr_setdetachstate(&attr3, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr3, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr3, SCHED_RR);
            pthread_attr_getschedparam(&attr3, &sched3);
            sched3.sched_priority = 85;
            pthread_attr_setschedparam(&attr3, &sched3);

            s32Result3 = pthread_create(&thread_info3, &attr3, (void*)AU_CUS_AACEncodeMonitor, (void *) NULL);
            if (s32Result3 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create aac encode monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("aac encode monitor thread created successfully \n");
            }
        }
        #endif
        #endif

        //================================================================================================
        //                   Limit Time Mute Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pMuteDuringLimitedTimeThread = NULL;

            pMuteDuringLimitedTimeThread = kthread_create((void*)AU_CUS_MuteDuringLimitedTime_Monitor, NULL, "MuteDuringLimitedTimeThread Monitor");
            if (pMuteDuringLimitedTimeThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create MuteDuringLimitedTimeThread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("MuteDuringLimitedTimeThread created successfully \n");
                wake_up_process(pMuteDuringLimitedTimeThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info4;
            pthread_attr_t      attr4;
            struct sched_param  sched4;
            int                 s32Result4;

            pthread_attr_init(&attr4);
            pthread_attr_setdetachstate(&attr4, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr4, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr4, SCHED_RR);
            pthread_attr_getschedparam(&attr4, &sched4);
            sched4.sched_priority = 85;
            pthread_attr_setschedparam(&attr4, &sched4);

            s32Result4 = pthread_create(&thread_info4, &attr4, (void*)AU_CUS_MuteDuringLimitedTime_Monitor, (void *) NULL);
            if (s32Result4 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't MuteDuringLimitedTimeThread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("MuteDuringLimitedTimeThread successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   ADEC PCM OUT MONITOR
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_AdecPcmOutMonitorThread = NULL;

            pAU_AdecPcmOutMonitorThread = kthread_create((void*)AU_CUS_AdecPcmOutMonitor, NULL, "AU_CUS_AdecPcmOutMonitor");
            if (pAU_AdecPcmOutMonitorThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_AdecPcmOutMonitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_AdecPcmOutMonitor thread created successfully \n");
                wake_up_process(pAU_AdecPcmOutMonitorThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info5;
            pthread_attr_t      attr5;
            struct sched_param  sched5;
            int                 s32Result5;

            pthread_attr_init(&attr5);
            pthread_attr_setdetachstate(&attr5, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr5, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr5, SCHED_RR);
            pthread_attr_getschedparam(&attr5, &sched5);
            sched5.sched_priority = 85;
            pthread_attr_setschedparam(&attr5, &sched5);

            s32Result5 = pthread_create(&thread_info5, &attr5, (void*)AU_CUS_AdecPcmOutMonitor, (void *) NULL);
            if (s32Result5 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_AdecPcmOutMonitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_AdecPcmOutMonitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   PCM Capture Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pPCMCaptureThread = NULL;

            pPCMCaptureThread = kthread_create((void*)AU_CUS_PCMCaptureMonitor, NULL, "MStar PCM Capture Monitor");
            if (pPCMCaptureThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create pcm capture monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("pcm capture monitor thread created successfully \n");
                wake_up_process(pPCMCaptureThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info6;
            pthread_attr_t      attr6;
            struct sched_param  sched6;
            int                 s32Result6;

            pthread_attr_init(&attr6);
            pthread_attr_setdetachstate(&attr6, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr6, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr6, SCHED_RR);
            pthread_attr_getschedparam(&attr6, &sched6);
            sched6.sched_priority = 85;
            pthread_attr_setschedparam(&attr6, &sched6);

            s32Result6 = pthread_create(&thread_info6, &attr6, (void*)AU_CUS_PCMCaptureMonitor, (void *) NULL);
            if (s32Result6 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create pcm capture monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("pcm capture monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU End of Stream Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_End_Of_Stream_Thread = NULL;

            pAU_End_Of_Stream_Thread = kthread_create((void*)AU_CUS_EndOfStreamMonitor, NULL, "MStar AU End of Stream Monitor");
            if (pAU_End_Of_Stream_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't Create AU End of Stream monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU End of Stream monitor thread created successfully \n");
                wake_up_process(pAU_End_Of_Stream_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info7;
            pthread_attr_t      attr7;
            struct sched_param  sched7;
            int                 s32Result7;

            pthread_attr_init(&attr7);
            pthread_attr_setdetachstate(&attr7, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr7, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr7, SCHED_RR);
            pthread_attr_getschedparam(&attr7, &sched7);
            sched7.sched_priority = 85;
            pthread_attr_setschedparam(&attr7, &sched7);

            s32Result7 = pthread_create(&thread_info7, &attr7, (void*)AU_CUS_EndOfStreamMonitor, (void *) NULL);
            if (s32Result7 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't Create AU End of Stream monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo MM New Mode Play monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU Demo PCMIO Play Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_Demo_PCMIO_PlayThread = NULL;

            pAU_Demo_PCMIO_PlayThread = kthread_create((void*)AU_CUS_Demo_PCMIO_Play_Monitor, NULL, "MStar AU Demo PCMIO Play Monitor");
            if (pAU_Demo_PCMIO_PlayThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo PCMIO Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo PCMIO Play monitor thread created successfully \n");
                wake_up_process(pAU_Demo_PCMIO_PlayThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info8;
            pthread_attr_t      attr8;
            struct sched_param  sched8;
            int                 s32Result8;

            pthread_attr_init(&attr8);
            pthread_attr_setdetachstate(&attr8, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr8, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr8, SCHED_RR);
            pthread_attr_getschedparam(&attr8, &sched8);
            sched8.sched_priority = 85;
            pthread_attr_setschedparam(&attr8, &sched8);

            s32Result8 = pthread_create(&thread_info8, &attr8, (void*)AU_CUS_Demo_PCMIO_Play_Monitor, (void *) NULL);
            if (s32Result8 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo PCMIO Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo PCMIO Play monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU Demo MM New Mode Play Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_Demo_MM_New_ModeThread = NULL;

            pAU_Demo_MM_New_ModeThread = kthread_create((void*)AU_CUS_Demo_MM_New_Mode_Play_Monitor, NULL, "MStar AU Demo MM New Mode Play Monitor");
            if (pAU_Demo_MM_New_ModeThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo MM New Mode Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo MM New Mode Play monitor thread created successfully \n");
                wake_up_process(pAU_Demo_MM_New_ModeThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info9;
            pthread_attr_t      attr9;
            struct sched_param  sched9;
            int                 s32Result9;

            pthread_attr_init(&attr9);
            pthread_attr_setdetachstate(&attr9, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr9, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr9, SCHED_RR);
            pthread_attr_getschedparam(&attr9, &sched9);
            sched9.sched_priority = 85;
            pthread_attr_setschedparam(&attr9, &sched9);

            s32Result9 = pthread_create(&thread_info9, &attr9, (void*)AU_CUS_Demo_MM_New_Mode_Play_Monitor, (void *) NULL);
            if (s32Result9 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo MM New Mode Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo MM New Mode Play monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU AV Sync Info Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_AV_Sync_Info_Thread = NULL;

            pAU_AV_Sync_Info_Thread = kthread_create((void*)AU_CUS_AV_Sync_Info_Monitor, NULL, "MStar AU_CUS_AV_Sync_Info_Monitor");
            if (pAU_AV_Sync_Info_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_AV_Sync_Info_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_AV_Sync_Info_Monitor thread created successfully \n");
                wake_up_process(pAU_AV_Sync_Info_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info10;
            pthread_attr_t      attr10;
            struct sched_param  sched10;
            int                 s32Result10;

            pthread_attr_init(&attr10);
            pthread_attr_setdetachstate(&attr10, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr10, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr10, SCHED_RR);
            pthread_attr_getschedparam(&attr10, &sched10);
            sched10.sched_priority = 85;
            pthread_attr_setschedparam(&attr10, &sched10);

            s32Result10 = pthread_create(&thread_info10, &attr10, (void*)AU_CUS_AV_Sync_Info_Monitor, (void *) NULL);
            if (s32Result10 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_AV_Sync_Info_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_AV_Sync_Info_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   ADEC Underrun Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_ADEC_Underrun_Thread = NULL;

            pAU_ADEC_Underrun_Thread = kthread_create((void*)AU_CUS_ADEC_Underrun_Monitor, NULL, "MStar AU_CUS_ADEC_Underrun_Monitor");
            if (pAU_ADEC_Underrun_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_ADEC_Underrun_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_ADEC_Underrun_Monitorthread created successfully \n");
                wake_up_process(pAU_ADEC_Underrun_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info11;
            pthread_attr_t      attr11;
            struct sched_param  sched11;
            int                 s32Result11;

            pthread_attr_init(&attr11);
            pthread_attr_setdetachstate(&attr11, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr11, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr11, SCHED_RR);
            pthread_attr_getschedparam(&attr11, &sched11);
            sched11.sched_priority = 85;
            pthread_attr_setschedparam(&attr11, &sched11);

            s32Result11 = pthread_create(&thread_info11, &attr11, (void*)AU_CUS_ADEC_Underrun_Monitor, (void *) NULL);
            if (s32Result11 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_ADEC_Underrun_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_ADEC_Underrun_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   Customized internal patch: Auto_Audio_Delay_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Thread = NULL;

            pAU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Thread = kthread_create((void*)AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor, NULL, "MStar AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor");
            if (pAU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor thread created successfully \n");
                wake_up_process(pAU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info12;
            pthread_attr_t      attr12;
            struct sched_param  sched12;
            int                 s32Result12;

            pthread_attr_init(&attr12);
            pthread_attr_setdetachstate(&attr12, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr12, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr12, SCHED_RR);
            pthread_attr_getschedparam(&attr12, &sched12);
            sched12.sched_priority = 85;
            pthread_attr_setschedparam(&attr12, &sched12);

            s32Result12 = pthread_create(&thread_info12, &attr12, (void*)AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor, (void *) NULL);
            if (s32Result12 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   Customized internal patch: AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Thread = NULL;

            pAU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Thread = kthread_create((void*)AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor, NULL, "MStar AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor");
            if (pAU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor thread created successfully \n");
                wake_up_process(pAU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info13;
            pthread_attr_t      attr13;
            struct sched_param  sched13;
            int                 s32Result13;

            pthread_attr_init(&attr13);
            pthread_attr_setdetachstate(&attr13, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr13, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr13, SCHED_RR);
            pthread_attr_getschedparam(&attr13, &sched13);
            sched13.sched_priority = 85;
            pthread_attr_setschedparam(&attr13, &sched13);

            s32Result13 = pthread_create(&thread_info13, &attr13, (void*)AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor, (void *) NULL);
            if (s32Result13 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   Customized internal patch: AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Thread = NULL;

            pAU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Thread = kthread_create((void*)AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor, NULL, "MStar AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor");
            if (pAU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor thread created successfully \n");
                wake_up_process(pAU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info14;
            pthread_attr_t      attr14;
            struct sched_param  sched14;
            int                 s32Result14;

            pthread_attr_init(&attr14);
            pthread_attr_setdetachstate(&attr14, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr14, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr14, SCHED_RR);
            pthread_attr_getschedparam(&attr14, &sched14);
            sched14.sched_priority = 85;
            pthread_attr_setschedparam(&attr14, &sched14);

            s32Result14 = pthread_create(&thread_info14, &attr14, (void*)AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor, (void *) NULL);
            if (s32Result14 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   Customized patch: AU_CUS_PATCH_Dump_R2_Log_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_PATCH_Dump_R2_Log_Thread = NULL;

            pAU_CUS_PATCH_Dump_R2_Log_Thread = kthread_create((void*)AU_CUS_PATCH_Dump_R2_Log_Monitor, NULL, "MStar AU_CUS_PATCH_Dump_R2_Log_Monitor");
            if (pAU_CUS_PATCH_Dump_R2_Log_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_PATCH_Dump_R2_Log_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_PATCH_Dump_R2_Log_Monitor thread created successfully \n");
                wake_up_process(pAU_CUS_PATCH_Dump_R2_Log_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info15;
            pthread_attr_t      attr15;
            struct sched_param  sched15;
            int                 s32Result15;

            pthread_attr_init(&attr15);
            pthread_attr_setdetachstate(&attr15, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr15, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr15, SCHED_RR);
            pthread_attr_getschedparam(&attr15, &sched15);
            sched15.sched_priority = 85;
            pthread_attr_setschedparam(&attr15, &sched15);

            s32Result15 = pthread_create(&thread_info15, &attr15, (void*)AU_CUS_PATCH_Dump_R2_Log_Monitor, (void *) NULL);
            if (s32Result15 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_PATCH_Dump_R2_Log_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_PATCH_Dump_R2_Log_Monitor successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU Demo MM AD New Mode Play Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_Demo_MM_New_Mode_AD_Thread = NULL;

            pAU_Demo_MM_New_Mode_AD_Thread = kthread_create((void*)AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor, NULL, "MStar AU Demo MM New Mode AD Play Monitor");
            if (pAU_Demo_MM_New_Mode_AD_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo MM New Mode AD Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo MM New Mode AD Play monitor thread created successfully \n");
                wake_up_process(pAU_Demo_MM_New_Mode_AD_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info16;
            pthread_attr_t      attr16;
            struct sched_param  sched16;
            int                 s32Result16;

            pthread_attr_init(&attr16);
            pthread_attr_setdetachstate(&attr16, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr16, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr16, SCHED_RR);
            pthread_attr_getschedparam(&attr16, &sched16);
            sched16.sched_priority = 85;
            pthread_attr_setschedparam(&attr16, &sched16);

            s32Result16 = pthread_create(&thread_info16, &attr16, (void*)AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor, (void *) NULL);
            if (s32Result16 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU Demo MM New Mode AD Play thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU Demo MM New Mode AD Play monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU_CUS_ThreadPrintMsg_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_ThreadPrintMsg_Thread = NULL;

            pAU_CUS_ThreadPrintMsg_Thread = kthread_create((void*)AU_CUS_ThreadPrintMsg_Monitor, NULL, "MStar AU_CUS_ThreadPrintMsg_Monitor");
            if (pAU_CUS_ThreadPrintMsg_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_ThreadPrintMsg_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_ThreadPrintMsg_Monitor created successfully \n");
                wake_up_process(pAU_CUS_ThreadPrintMsg_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info17;
            pthread_attr_t      attr17;
            struct sched_param  sched17;
            int                 s32Result17;

            pthread_attr_init(&attr17);
            pthread_attr_setdetachstate(&attr17, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr17, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr17, SCHED_RR);
            pthread_attr_getschedparam(&attr17, &sched17);
            sched17.sched_priority = 85;
            pthread_attr_setschedparam(&attr17, &sched17);

            s32Result17 = pthread_create(&thread_info17, &attr17, (void*)AU_CUS_ThreadPrintMsg_Monitor, (void *) NULL);
            if (s32Result17 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_ThreadPrintMsg_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_ThreadPrintMsg_Monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU_CUS_INTERNAL_PATCH_R2_Active_Monitor
        //================================================================================================
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_CUS_INTERNAL_PATCH_R2_Active_Thread = NULL;

            pAU_CUS_INTERNAL_PATCH_R2_Active_Thread = kthread_create((void*)AU_CUS_INTERNAL_PATCH_R2_Active_Monitor, NULL, "MStar AU_CUS_INTERNAL_PATCH_R2_Active_Monitor");
            if (pAU_CUS_INTERNAL_PATCH_R2_Active_Thread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_INTERNAL_PATCH_R2_Active_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_R2_Active_Monitor created successfully \n");
                wake_up_process(pAU_CUS_INTERNAL_PATCH_R2_Active_Thread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info18;
            pthread_attr_t      attr18;
            struct sched_param  sched18;
            int                 s32Result18;

            pthread_attr_init(&attr18);
            pthread_attr_setdetachstate(&attr18, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr18, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr18, SCHED_RR);
            pthread_attr_getschedparam(&attr18, &sched18);
            sched18.sched_priority = 85;
            pthread_attr_setschedparam(&attr18, &sched18);

            s32Result18 = pthread_create(&thread_info18, &attr18, (void*)AU_CUS_INTERNAL_PATCH_R2_Active_Monitor, (void *) NULL);
            if (s32Result18 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't AU_CUS_INTERNAL_PATCH_R2_Active_Monitor thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_INTERNAL_PATCH_R2_Active_Monitor thread created successfully \n");
            }
        }
        #endif

        //================================================================================================
        //                   AU_CUS_HDMI_RX_Monitor
        //================================================================================================
        #if (CUSTOMIZED_PATCH_PARAM_HDMI_RX_SWITCH_TO_PCM_DEBOUNCE)
        {
            #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
            {
                struct task_struct *pAU_CUS_INTERNAL_PATCH_HDMI_RX_Monitor_Thread = NULL;

                pAU_CUS_INTERNAL_PATCH_HDMI_RX_Monitor_Thread = kthread_create((void*)AU_CUS_HDMI_RX_Monitor, NULL, "MStar AU_CUS_HDMI_RX_Monitor");
                if (pAU_CUS_INTERNAL_PATCH_HDMI_RX_Monitor_Thread == NULL)
                {
                    AU_nPRINT("[Error] [%s] [Can't create AU_CUS_HDMI_RX_Monitor thread] \n", __FUNCTION__);
                }
                else
                {
                    AU_nDBG("AU_CUS_HDMI_RX_Monitor created successfully \n");
                    wake_up_process(pAU_CUS_INTERNAL_PATCH_HDMI_RX_Monitor_Thread);
                }
            }
            #else //User Space
            {
                pthread_t           thread_info19;
                pthread_attr_t      attr19;
                struct sched_param  sched19;
                int                 s32Result19;

                pthread_attr_init(&attr19);
                pthread_attr_setdetachstate(&attr19, PTHREAD_CREATE_JOINABLE);
                pthread_attr_setinheritsched(&attr19, PTHREAD_EXPLICIT_SCHED);
                pthread_attr_setschedpolicy(&attr19, SCHED_RR);
                pthread_attr_getschedparam(&attr19, &sched19);
                sched19.sched_priority = 85;
                pthread_attr_setschedparam(&attr19, &sched19);

                s32Result19 = pthread_create(&thread_info19, &attr19, (void*)AU_CUS_HDMI_RX_Monitor, (void *) NULL);
                if (s32Result19 != 0)
                {
                    AU_nPRINT("[Error] [%s] [Can't AU_CUS_HDMI_RX_Monitor thread] \n", __FUNCTION__);
                }
                else
                {
                    AU_nDBG("AU_CUS_HDMI_RX_Monitor thread created successfully \n");
                }
            }
            #endif
        }
        #endif
    }
    #endif

}

static void AU_CUS_CreateDebugMenuThread(void)
{
    #ifdef CONFIG_MBOOT //mboot
    {
    }
    #else //application
    {
        #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        {
            struct task_struct *pAU_DebugMenuThread = NULL;

            pAU_DebugMenuThread = kthread_create((void*)AU_CUS_DebugMenu, NULL, "MStar AU_CUS_DebugMenu");
            if (pAU_DebugMenuThread == NULL)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_DebugMenu thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_DebugMenu thread created successfully \n");
                wake_up_process(pAU_DebugMenuThread);
            }
        }
        #else //User Space
        {
            pthread_t           thread_info99;
            pthread_attr_t      attr99;
            struct sched_param  sched99;
            int                 s32Result99;

            pthread_attr_init(&attr99);
            pthread_attr_setdetachstate(&attr99, PTHREAD_CREATE_JOINABLE);
            pthread_attr_setinheritsched(&attr99, PTHREAD_EXPLICIT_SCHED);
            pthread_attr_setschedpolicy(&attr99, SCHED_RR);
            pthread_attr_getschedparam(&attr99, &sched99);
            sched99.sched_priority = 85;
            pthread_attr_setschedparam(&attr99, &sched99);

            s32Result99 = pthread_create(&thread_info99, &attr99, (void*)AU_CUS_DebugMenu, (void *) NULL);
            if (s32Result99 != 0)
            {
                AU_nPRINT("[Error] [%s] [Can't create AU_CUS_DebugMenu thread] \n", __FUNCTION__);
            }
            else
            {
                AU_nDBG("AU_CUS_DebugMenu thread created successfully \n");
            }
        }
        #endif
    }
    #endif
}

MS_U8* AU_CUS_MemoryAlloc(MS_U32 allocSize)
{
    MS_U8 *allocBuffer = NULL;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
        allocBuffer = kzalloc(sizeof(MS_U8) * allocSize, GFP_KERNEL);
    #else //User Space
        allocBuffer = malloc(sizeof(MS_U8) * allocSize);
    #endif

    if (allocBuffer == NULL)
    {
        AU_nPRINT("%s: Error! fail to allocate 0x%x bytes memory !\n", __FUNCTION__, (unsigned int)(sizeof(MS_U8) * allocSize));
        return allocBuffer;
    }

    memset(allocBuffer, 0x00, sizeof(MS_U8) * allocSize);

    return allocBuffer;
}

void AU_CUS_MemoryFree(void *pMemoryBuffer)
{
    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel space
        kfree(pMemoryBuffer);
    #else //user space
        free(pMemoryBuffer);
    #endif
}

#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel space
struct file * AU_CUS_FileOpen(const char * filename, const char *mode)
{
    return filp_open(filename, O_RDWR|O_CREAT|O_APPEND, S_IRWXU | S_IRWXG | S_IRWXO);
}

void AU_CUS_FileClose(struct file *fp)
{
    filp_close(fp, NULL);
}

void AU_CUS_FileWrite(const void *p, size_t size, size_t nmemb, struct file * fp)
{
    mm_segment_t fs;
    /* get current->addr_limit. It should be 0-3G */
    fs = get_fs();
    /* set current->addr_limit to 4G */
    set_fs(get_ds());

    if (fp->f_op && fp->f_op->write)
        fp->f_op->write(fp, p, nmemb, &fp->f_pos);

    if (fp->f_op && fp->f_op->flush)
        fp->f_op->flush(fp, NULL);

    /* restore the addr_limit */
    set_fs(fs);
}

#if (UTPA_SUPPORT_AAC_ENCODE == 1)
tEmzInt32 Mpeg4AacEnc_Create(void **aHandle)
{
    return 0;
}
tEmzInt32 Mpeg4AacEnc_Reset(void *aHandle, tMp4AacEncParams *aEncPrms)
{
    return 0;
}
tEmzInt32 Mpeg4AacEnc_Encode(void *aHandle, tEmzInt16 aSrc[], tEmzInt32 aSrcLen, tEmzUint8 aDst[], tEmzInt32 *aDstLen)
{
    return 0;
}
tEmzInt32 Mpeg4AacEnc_Delete(void  *aHandle)
{
    return 0;
}
#endif

#else //User space
FILE * AU_CUS_FileOpen(const char * filename, const char *mode)
{
#ifdef CONFIG_MBOOT
    return NULL;
#else
    return fopen(filename, mode);
#endif
}

int AU_CUS_FileClose(FILE * fp)
{
#ifdef CONFIG_MBOOT
    return NULL;
#else
    return fclose(fp);
#endif
}

void AU_CUS_FileWrite(const void *p, size_t size, size_t nmemb, FILE *fp)
{
#ifdef CONFIG_MBOOT
    return;
#else
    fwrite(p, size, nmemb, fp);
    fflush(fp);
#endif
}
#endif

/* Debug Related functions */
#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
MS_BOOL AU_CUS_DebugMenu(void)
{
    //Kernel Space dont support IO. need to use proc
    return TRUE;
}

/* kernel debug proc */
static struct AU_CUS_kernel_debug_proc_st au_cus_kernel_debug_proc_child[AU_CUS_KERNEL_DEBUG_PROC_MAX_CHILD] =
{
    {
        /* proc child 1 */
        .proc_entry = NULL,
        .proc_fops  =
        {
            .owner  = THIS_MODULE,
            .read   = AU_CUS_kernel_debug_proc_read_nDBG,
            .write  = AU_CUS_kernel_debug_proc_write_nDBG,
        },
        .proc_name  = AU_CUS_KERNEL_DEBUG_PROC_CHILD_0001_NDBG,
        .proc_mode  = 0x0666,
    },
    {
        /* proc child 2 */
        .proc_entry = NULL,
        .proc_fops  =
        {
            .owner  = THIS_MODULE,
            .read   = AU_CUS_kernel_debug_proc_read_ShowVersion,
        },
        .proc_name  = AU_CUS_KERNEL_DEBUG_PROC_CHILD_0002_SHOW_VERSION,
        .proc_mode  = 0x0666,
    },
};

//-----------------------------------------------------------------------------
// Proc Operations (Init / Exit)
//-----------------------------------------------------------------------------
static int AU_CUS_KERNEL_DEBUG_PROC_init(void)
{
    struct AU_CUS_kernel_debug_proc_st *proc_child = NULL;
    int loop = 0;
    int ret = 0;

    g_proc_root = proc_mkdir(AU_CUS_KERNEL_DEBUG_PROC_ROOT_NAME, NULL);
    if (g_proc_root == NULL)
    {
        AU_nDBG(KERN_ERR "Error! fail to create root directory of proc filesystem (%s)!\n", AU_CUS_KERNEL_DEBUG_PROC_ROOT_NAME);
        ret = -EACCES;
    }
    else
    {
        for (loop = 0; loop < AU_CUS_KERNEL_DEBUG_PROC_MAX_CHILD; loop++)
        {
            proc_child = &au_cus_kernel_debug_proc_child[loop];

            proc_child->proc_entry = proc_create_data(proc_child->proc_name, proc_child->proc_mode, g_proc_root, &proc_child->proc_fops, NULL);
            if (proc_child->proc_entry == NULL)
            {
                AU_nDBG(KERN_ERR "Error! fail to create child directory of proc filesystem (%s)!\n", proc_child->proc_name);
                ret = -EACCES;
                break;
            }
        }
    }
    AU_nDBG("\033[1;32m *****MstarAudioCustomerDebug proc insert SUCESS!! \033[0m \n");

    return ret;
}

static inline void AU_CUS_KERNEL_DEBUG_PROC_exit(void)
{
    struct AU_CUS_kernel_debug_proc_st *proc_child = NULL;
    int loop = 0;

    for (loop = 0; loop < AU_CUS_KERNEL_DEBUG_PROC_MAX_CHILD; loop++)
    {
        proc_child = &au_cus_kernel_debug_proc_child[loop];

        if (proc_child->proc_entry != NULL)
        {
            remove_proc_entry(proc_child->proc_name, g_proc_root);
        }
    }

    remove_proc_entry(AU_CUS_KERNEL_DEBUG_PROC_ROOT_NAME, NULL);

    return;
}

/*

note:
cat  xxx            // proc read
echo ooo on  > xxx  // proc write
echo ooo off > xxx  // proc write

===============================================================================
 * * * How to use kernel debug proc * * *
===============================================================================
#------------------------------------------
#Child 1: "0001_nDBG"
#------------------------------------------
cd /proc/MstarAudioCustomerDebug/
cat  0001_nDBG
echo EnableNonThreadPrint       > 0001_nDBG
echo EnableThreadPrint          > 0001_nDBG
echo DisableNonThreadPrint      > 0001_nDBG
echo DisableThreadPrint         > 0001_nDBG
echo DisableAllThreadMonitor    > 0001_nDBG

#------------------------------------------
#Child 2: "0002_Version"
#------------------------------------------
cd /proc/MstarAudioCustomerDebug/
cat  0002_ShowVersion

*/

//-----------------------------------------------------------------------------
// Proc Operations (Child 1, "001_AudioLog")
//-----------------------------------------------------------------------------
static ssize_t AU_CUS_kernel_debug_proc_read_nDBG(struct file *file, char __user *buffer, size_t count, loff_t *pos)
{
    AU_nPRINT("Proc_Read_Test\n");

    return 0;
}

static ssize_t AU_CUS_kernel_debug_proc_write_nDBG(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
{
    char value_str[AU_CUS_KERNEL_DEBUG_PROC_STRING_BUFFER_LENGTH] = {'\0'};
    char action[AU_CUS_KERNEL_DEBUG_PROC_STRING_BUFFER_LENGTH];

    if (copy_from_user(value_str, buffer, count))
    {
        return -EFAULT;
    }

    value_str[count] = '\0';
    sscanf(value_str, "%s\n", action);

    AU_nPRINT("*********%s\n", action);

    if (!strcmp("EnableNonThreadPrint",action))
    {
        AU_nPRINT("EnableNonThreadPrint \n");
        pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = TRUE;
    }

    if (!strcmp("EnableThreadPrint",action))
    {
        AU_nPRINT("EnableThreadPrint \n");
        pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg = TRUE;
    }

    if (!strcmp("DisableNonThreadPrint",action))
    {
        AU_nPRINT("DisableNonThreadPrint \n");
        pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = FALSE;
    }

    if (!strcmp("DisableThreadPrint",action))
    {
        AU_nPRINT("DisableThreadPrint \n");
        pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg = FALSE;
    }

    if (!strcmp("DisableAllThreadMonitor",action))
    {
        AU_nPRINT("DisableAllThreadMonitor \n");
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_ClipDecoderMonitor_bEnable                         = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_MP3EncodeMonitor_bEnable                           = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_MonitorService_bEnable                             = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_AACEncodeMonitor_bEnable                           = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_MuteDuringLimitedTime_Monitor_bEnable              = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_AdecPcmOutMonitor_bEnable                          = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_PCMCaptureMonitor_bEnable                          = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_EndOfStreamMonitor_bEnable                         = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_Underrun_Monitor_bEnable                      = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_PATCH_Dump_R2_Log_Monitor_bEnable                  = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor_bEnable    = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor_bEnable = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor_bEnable  = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_R2_Active_Monitor_bEnable           = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor_bEnable           = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_Play_Monitor_bEnable              = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_PCMIO_Play_Monitor_bEnable                    = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_AV_Sync_Info_Monitor_bEnable                       = FALSE;
        pstAudioCustomerShmData->g_audio_customer_AU_CUS_ThreadPrintMsg_Monitor_bEnable                     = FALSE;
    }

    return count;
}

//-----------------------------------------------------------------------------
// Proc Operations (Child 2, "0002_ShowVersion")
//-----------------------------------------------------------------------------
static ssize_t AU_CUS_kernel_debug_proc_read_ShowVersion(struct file *file, char __user *buffer, size_t count, loff_t *pos)
{
    AU_CUS_SHOW_ALL_VERSION();

    return 0;
}

#else //User Space
char* AU_CUS_fgets(char* buf, int num, FILE* fp)
{
    char* c_eof = 0;

    if(!fgets(buf, num, fp))
    {
        return NULL;
    }
    while(buf[0]== '\n')
    {
        if(!fgets(buf, num, fp))
        {
            return NULL;
        }
        if((c_eof = strrchr(buf, '\n')))
        {
            *c_eof = '\0';
        }
        else
        {
            int ch;
            while(((ch = fgetc(fp)) != EOF) && (ch != '\n'));
        }

    }
    return buf;
}

unsigned int AU_CUS_Debug_GetHex(const char *szComment)
{
    if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == TRUE)
    {
        char cmd[256];
        memset(cmd, 0, 256);

        AU_nPRINT("%s", szComment);
        fflush(stdout);

        do
        {
            AU_CUS_fgets(cmd, sizeof(cmd), stdin);
        }while( !isxdigit((int)(*cmd)) && (fprintf(stderr, "please enter a hex integer\n") || 1 ));

        cmd[255] = 0x0;

        return (strtoul( cmd, (char**) NULL, 16 ));
    }
    else if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == FALSE) //NON_SCANF version: Allow debug menu to work without scanf
    {
        unsigned int ret = 0xFFFF;

        if(szComment)
        {
            AU_nPRINT("%s", szComment);
            fflush(stdout);
        }

        while(non_scanf_paramsCount == 0)
        {
            // No more non_scanf_params, block until more non_scanf_params become avail.
            sleep(2);
        }
        if((non_scanf_paramsCount>0) && (non_scanf_paramIdx < NON_SCANF_DEBUG_CMD_PARAMS_MAX))
        {
            non_scanf_paramsCount--;
            ret= non_scanf_paramsHex[non_scanf_paramIdx++];
        }

        return ret;
    }

    return TRUE;
}

int AU_CUS_Debug_GetDec(void)
{
    if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == TRUE)
    {
        int dValue;

        if(scanf("%d", &dValue)==FALSE)
        {
            dValue=9284;
        }

        return dValue;
    }
    else if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == FALSE) //NON_SCANF version: Allow debug menu to work without scanf
    {
        unsigned int ret = 0xFFFF;
        while(non_scanf_paramsCount == 0)
        {
            // No more non_scanf_params, block until more non_scanf_params become avail.
            sleep(2);
        }
        if((non_scanf_paramsCount>0) && (non_scanf_paramIdx < NON_SCANF_DEBUG_CMD_PARAMS_MAX))
        {
            non_scanf_paramsCount--;
            ret = non_scanf_params[non_scanf_paramIdx++];
        }
        return ret;
    }

    return TRUE;
}

char* AU_CUS_Debug_GetString(void)
{
    if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == TRUE)
    {
        if(scanf("%s", au_debug_input_string)==FALSE)
        {
            memset(au_debug_input_string, 'F', AU_DEBUG_INPUT_STR_LENGTH+1);
        }
    }
    else if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == FALSE) //NON_SCANF version: Allow debug menu to work without scanf
    {
        while(non_scanf_paramsCount == 0)
        {
            // No more non_scanf_params, block until more non_scanf_params become avail.
            sleep(2);
        }
        non_scanf_paramsCount--;
        strcpy(au_debug_input_string, non_scanf_paramsStr);
    }

    return au_debug_input_string;
}

#if(DTS_AUDIO_PARSER_ENABLE)
dtsUint64 AU_CUS_DTS_Parser_dtsHDEndianConvert64(dtsUint64 number)
{
    dtsUint64 rc;

    rc  = (number >> 56) & 0xff;
    rc |= (((number >> 48) & 0xff) << 8 );
    rc |= (((number >> 40) & 0xff) << 16);
    rc |= (((number >> 32) & 0xff) << 24);
    rc |= (((number >> 24) & 0xff) << 32);
    rc |= (((number >> 16) & 0xff) << 40);
    rc |= (((number >> 8 ) & 0xff) << 48);
    rc |= (((number >> 0 ) & 0xff) << 56);

    return rc;
}

dtsUint32 AU_CUS_DTS_Parser_dtsHDEndianConvert32(dtsUint32 number)
{
    dtsUint32 rc;

    rc  = (number >> 24) & 0xff;
    rc |= (((number >> 16) & 0xff) << 8 );
    rc |= (((number >> 8 ) & 0xff) << 16);
    rc |= (((number >> 0 ) & 0xff) << 24);

    return rc;
}

dtsUint16 AU_CUS_DTS_Parser_dtsHDEndianConvert16(dtsUint16 number)
{
    dtsUint16 rc;

    rc = (number >> 8) & 0xff;
    rc |= ((number & 0xff) << 8);

    return rc;
}

void AU_CUS_DTS_Parser_dtsHDDecodeChunk(FILE *fp, dtsUint8 *chunkId, dtsUint64 chunkLength, dtsHDFileInfo *pFileInfo)
{
    dtsUint32 i;
    fpos_tt currentFilePosition;

    fgetpos(fp, &currentFilePosition);

    for(i = 0; i < sizeof(dtsHDChunkDecodeMatrix) / sizeof(dtsHDChunkDecodeMatrix[0]); i++)
    {
        if(0 == memcmp(dtsHDChunkDecodeMatrix[i].pChunkdId, chunkId, DTS_HD_CHUNK_ID_LENGTH))
        {
            if(NULL != dtsHDChunkDecodeMatrix[i].pChunkDecode)
            {
                dtsHDChunkDecodeMatrix[i].pChunkDecode(fp, pFileInfo, chunkLength);
            }
            break;
        }
    }

    fsetpos(fp, &currentFilePosition);

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeDTSHDHR(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 headerChunk[DTS_HD_DTSHDR_MIN_LENGTH_IN_BYTES];
    dtsUint8 *pTimeCode;
    dtsUint16 metaData;

    if(DTS_HD_DTSHDR_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        /* Read the chunk data before parsing */
        if(DTS_HD_DTSHDR_MIN_LENGTH_IN_BYTES == fread(headerChunk, 1, DTS_HD_DTSHDR_MIN_LENGTH_IN_BYTES, fp))
        {
            pFileInfo->hdr.valid = dtsTrue;

            /* Read the header version */
            memcpy(&pFileInfo->hdr.hdrVersion, headerChunk, 4);
            pFileInfo->hdr.hdrVersion = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->hdr.hdrVersion);

            /* Read the time code */
            pFileInfo->hdr.timeCode = 0;
            pTimeCode = (dtsUint8 *)&pFileInfo->hdr.timeCode;
            memcpy(&pTimeCode[3], &headerChunk[4], 5);

            pFileInfo->hdr.timeCode = AU_CUS_DTS_Parser_dtsHDEndianConvert64(pFileInfo->hdr.timeCode);

            /* Read the Frame Rate */
            pFileInfo->hdr.TCFrameRate = headerChunk[9];

            /* Read the meta data */
            memcpy(&metaData, &headerChunk[10], 2);
            metaData = AU_CUS_DTS_Parser_dtsHDEndianConvert16(metaData);

            pFileInfo->hdr.bitWStreamMetaData.vbr       = DTS_BOOLEAN_CONVERT(metaData & 0x01);
            pFileInfo->hdr.bitWStreamMetaData.pbrs      = DTS_BOOLEAN_CONVERT(metaData & 0x02);
            pFileInfo->hdr.bitWStreamMetaData.navi      = DTS_BOOLEAN_CONVERT(metaData & 0x04);
            pFileInfo->hdr.bitWStreamMetaData.coreSStrm = DTS_BOOLEAN_CONVERT(metaData & 0x08);
            pFileInfo->hdr.bitWStreamMetaData.extSStrm  = DTS_BOOLEAN_CONVERT(metaData & 0x10);

            /* Read the number of audio presentations */
            pFileInfo->hdr.NumAudioPres = headerChunk[12];
        }
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeCORESSMD(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 coreChunk[DTS_HD_CORESSMD_MIN_LENGTH_IN_BYTES];
    dtsUint8 *srPtr;

    if(DTS_HD_CORESSMD_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        /* Read the chunk data before parsing */
        if(DTS_HD_CORESSMD_MIN_LENGTH_IN_BYTES == fread(coreChunk, 1, DTS_HD_CORESSMD_MIN_LENGTH_IN_BYTES, fp))
        {
            pFileInfo->coreSSMD.valid = dtsTrue;

            /* Read the max sample rate */
            pFileInfo->coreSSMD.maxSampleRateHz = 0;
            srPtr = (dtsUint8 *)&pFileInfo->coreSSMD.maxSampleRateHz;
            memcpy(&srPtr[1], coreChunk, 3);
            pFileInfo->coreSSMD.maxSampleRateHz = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->coreSSMD.maxSampleRateHz);

            /* Read the bit rate */
            memcpy(&pFileInfo->coreSSMD.bitRateKbps, &coreChunk[3], 2);
            pFileInfo->coreSSMD.bitRateKbps = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->coreSSMD.bitRateKbps);

            /* Read the channel mask */
            memcpy(&pFileInfo->coreSSMD.channelMask, &coreChunk[5], 2);
            pFileInfo->coreSSMD.channelMask = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->coreSSMD.channelMask);

            /* Read the frame payload */
            memcpy(&pFileInfo->coreSSMD.framePayloadBytes, &coreChunk[7], 4);
            pFileInfo->coreSSMD.framePayloadBytes = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->coreSSMD.framePayloadBytes);

        }
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeEXTSSMD(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 extChunk[DTS_HD_EXTSSMD_MAX_LENGTH_IN_BYTES];
    dtsUint8 length;
    dtsUint8 *brPtr;

    if(DTS_HD_EXTSSMD_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        /* This chunk's length is dependent on the hdr */
        if(dtsTrue == pFileInfo->hdr.bitWStreamMetaData.vbr)
        {
            length = DTS_HD_EXTSSMD_MAX_LENGTH_IN_BYTES;
        }
        else
        {
            length = DTS_HD_EXTSSMD_MIN_LENGTH_IN_BYTES;
        }

        /* Read the chunk data before parsing */
        if(length == fread(extChunk, 1, length, fp))
        {
            pFileInfo->extSSMD.valid = dtsTrue;

            /* Read the avg bit rate */
            pFileInfo->extSSMD.avgBitRateKbps = 0;
            brPtr = (dtsUint8 *)&pFileInfo->extSSMD.avgBitRateKbps;
            memcpy(&brPtr[1], extChunk, 3);
            pFileInfo->extSSMD.avgBitRateKbps = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->extSSMD.avgBitRateKbps);


            if(dtsTrue == pFileInfo->hdr.bitWStreamMetaData.vbr)
            {
                /* Read the peak bit rate */
                pFileInfo->extSSMD.peakBitRateKbps = 0;
                brPtr = (dtsUint8 *)&pFileInfo->extSSMD.peakBitRateKbps;
                memcpy(&brPtr[1], &extChunk[3], 3);
                pFileInfo->extSSMD.peakBitRateKbps = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->extSSMD.peakBitRateKbps);


                /* Read the pbr smoothing buffer size */
                memcpy(&pFileInfo->extSSMD.pbrSmoothBuffSizeKb, &extChunk[6], 2);
                pFileInfo->extSSMD.pbrSmoothBuffSizeKb = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->extSSMD.pbrSmoothBuffSizeKb);


                pFileInfo->extSSMD.framePayloadBytes = 0;
            }
            else
            {
                /* Read the frame payload */
                memcpy(&pFileInfo->extSSMD.framePayloadBytes, &extChunk[3], 4);
                pFileInfo->extSSMD.framePayloadBytes = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->extSSMD.framePayloadBytes);


                pFileInfo->extSSMD.peakBitRateKbps = 0;
                pFileInfo->extSSMD.pbrSmoothBuffSizeKb = 0;
            }
        }
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeAUPRHDR(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 auprChunk[DTS_HD_AUPRHDR_MAX_LENGTH_IN_BYTES];
    dtsUint8 *srPtr, idx;
    dtsUint16 metaData;

    if(DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        /* This chunk's length is dependent on it's metadata, read it in two bits */
        if(DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES == fread(auprChunk, 1, DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES, fp))
        {
            /* Read the index */
            idx = auprChunk[0];

            if(idx < DTS_HD_MAX_ASSETS)
            {
                pFileInfo->auPrHdr[idx].valid = dtsTrue;

                /* Read the meta data */
                memcpy(&metaData, &auprChunk[1], 2);
                metaData = AU_CUS_DTS_Parser_dtsHDEndianConvert16(metaData);

                pFileInfo->auPrHdr[idx].bitWAupresMetaData.BCCCComp = DTS_BOOLEAN_CONVERT(metaData & 0x01);
                pFileInfo->auPrHdr[idx].bitWAupresMetaData.BCCCCompInExtSS = DTS_BOOLEAN_CONVERT(metaData & 0x02);
                pFileInfo->auPrHdr[idx].bitWAupresMetaData.LLCComp = DTS_BOOLEAN_CONVERT(metaData & 0x04);
                pFileInfo->auPrHdr[idx].bitWAupresMetaData.LBRCComp = DTS_BOOLEAN_CONVERT(metaData & 0x08);

                /* Read the sample rate */
                pFileInfo->auPrHdr[idx].maxSampleRate = 0;
                srPtr = (dtsUint8 *)&pFileInfo->auPrHdr[idx].maxSampleRate;
                memcpy(&srPtr[1], &auprChunk[3], 3);
                pFileInfo->auPrHdr[idx].maxSampleRate = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->auPrHdr[idx].maxSampleRate);

                /* Read the number of frames */
                memcpy(&pFileInfo->auPrHdr[idx].numFrames, &auprChunk[6], 4);
                pFileInfo->auPrHdr[idx].numFrames = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->auPrHdr[idx].numFrames);

                /* Read the samples per frame at max fs */
                memcpy(&pFileInfo->auPrHdr[idx].samplesPerFrameMaxFs, &auprChunk[10], 2);
                pFileInfo->auPrHdr[idx].samplesPerFrameMaxFs = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->auPrHdr[idx].samplesPerFrameMaxFs);

                /* Read the original samples at max fs */
                pFileInfo->auPrHdr[idx].numSamplesOrigAudioMaxFs = 0;
                srPtr = (dtsUint8 *)&pFileInfo->auPrHdr[idx].numSamplesOrigAudioMaxFs;
                memcpy(&srPtr[3], &auprChunk[12], 5);
                pFileInfo->auPrHdr[idx].numSamplesOrigAudioMaxFs = AU_CUS_DTS_Parser_dtsHDEndianConvert64(pFileInfo->auPrHdr[idx].numSamplesOrigAudioMaxFs);

                /* Read the channel mask */
                memcpy(&pFileInfo->auPrHdr[idx].channelMask, &auprChunk[17], 2);
                pFileInfo->auPrHdr[idx].channelMask = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->auPrHdr[idx].channelMask);

                /* Read the delay */
                memcpy(&pFileInfo->auPrHdr[idx].codecDelayMaxFs, &auprChunk[19], 2);
                pFileInfo->auPrHdr[idx].codecDelayMaxFs = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->auPrHdr[idx].codecDelayMaxFs);

                if((dtsTrue == pFileInfo->auPrHdr[idx].bitWAupresMetaData.BCCCComp) && (dtsTrue == pFileInfo->auPrHdr[idx].bitWAupresMetaData.BCCCCompInExtSS))
                {
                    /* Read another 7 bytes */
                    if(7 != fread(&auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES], 1, 7, fp))
                    {
                        pFileInfo->auPrHdr[idx].valid = dtsFalse;
                    }
                    else
                    {
                        /* Read the core max sample rate */
                        pFileInfo->auPrHdr[idx].BCCoreMaxSampleRate = 0;
                        srPtr = (dtsUint8 *)&pFileInfo->auPrHdr[idx].BCCoreMaxSampleRate;
                        memcpy(&srPtr[1], &auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES], 3);
                        pFileInfo->auPrHdr[idx].BCCoreMaxSampleRate = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->auPrHdr[idx].BCCoreMaxSampleRate);

                        /* Read the core bit rate */
                        memcpy(&pFileInfo->auPrHdr[idx].BCCoreBitRate, &auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES + 3], 2);
                        pFileInfo->auPrHdr[idx].BCCoreBitRate = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->auPrHdr[idx].BCCoreBitRate);

                        /* Read the core channel mask */
                        memcpy(&pFileInfo->auPrHdr[idx].BCCoreChannelMask, &auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES + 5], 2);
                        pFileInfo->auPrHdr[idx].BCCoreChannelMask = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->auPrHdr[idx].BCCoreChannelMask);
                    }
                }
                else
                {
                    pFileInfo->auPrHdr[idx].BCCoreMaxSampleRate = 0;
                    pFileInfo->auPrHdr[idx].BCCoreBitRate = 0;
                    pFileInfo->auPrHdr[idx].BCCoreChannelMask = 0;
                }

                if(dtsTrue == pFileInfo->auPrHdr[idx].bitWAupresMetaData.LLCComp)
                {
                    /* Read another 1 byte */
                    if(1 != fread(&auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES + 7], 1, 1, fp))
                    {
                        pFileInfo->auPrHdr[idx].valid = dtsFalse;
                    }
                    else
                    {
                        /* Read the core bit rate */
                        pFileInfo->auPrHdr[idx].LSBTrimPercent = auprChunk[DTS_HD_AUPRHDR_MIN_LENGTH_IN_BYTES + 7];
                    }
                }
                else
                {
                    pFileInfo->auPrHdr[idx].LSBTrimPercent = 0;
                }
            }
        }
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeSTRMDATA(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    /* Initialise the structure */
    pFileInfo->data.bytesRead = 0;
    pFileInfo->data.streamDataByteSize = chunkLength;
    pFileInfo->eof = dtsFalse;

    /* Record the current position in the file */
    fgetpos(fp, &pFileInfo->data.currentFilePosition);

    pFileInfo->data.valid = dtsTrue;
    memcpy(&pFileInfo->data.positionStartOfData, &pFileInfo->data.currentFilePosition, sizeof(fpos_tt));

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeNAVITBL(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 naviChunk[DTS_HD_NAVITBL_MIN_LENGTH_IN_BYTES];

    if(DTS_HD_NAVITBL_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        /* Read the first 3 fields */
        if(DTS_HD_NAVITBL_MIN_LENGTH_IN_BYTES == fread(naviChunk, 1, DTS_HD_NAVITBL_MIN_LENGTH_IN_BYTES, fp))
        {
            pFileInfo->navi.valid = dtsTrue;

            /* Read the number of entries */
            memcpy(&pFileInfo->navi.numEntries, naviChunk, 4);
            pFileInfo->navi.numEntries = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->navi.numEntries);


            /* Read the interval in frames */
            memcpy(&pFileInfo->navi.intervalFrames, &naviChunk[4], 2);
            pFileInfo->navi.intervalFrames = AU_CUS_DTS_Parser_dtsHDEndianConvert16(pFileInfo->navi.intervalFrames);


            /* Read the entry size */
            pFileInfo->navi.entrySize = naviChunk[6];

            /* Record the start of the table postion */
            fgetpos(fp, &pFileInfo->navi.tblEntryStartPos);

        }
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeBUILDVER(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 bldVerChunk[DTS_HD_BUILDVER_MAX_LENGTH_IN_BYTES];
    unsigned int toRead;

    if(DTS_HD_BUILDVER_MAX_LENGTH_IN_BYTES < chunkLength)
    {
        toRead = DTS_HD_BUILDVER_MAX_LENGTH_IN_BYTES;
    }
    else
    {
        toRead = (unsigned int)chunkLength;
    }

    /* Read the data */
    if(toRead == fread(bldVerChunk, 1, toRead, fp))
    {
        pFileInfo->bldVer.valid = dtsTrue;
        memcpy(&pFileInfo->bldVer.data, bldVerChunk, toRead);
    }

    return;
}

void AU_CUS_DTS_Parser_dtsDecodeTIMECODE(FILE *fp, dtsHDFileInfo *pFileInfo, dtsUint64 chunkLength)
{
    dtsUint8 timeChunk[DTS_HD_TIMECODE_MIN_LENGTH_IN_BYTES];

    if(DTS_HD_TIMECODE_MIN_LENGTH_IN_BYTES <= chunkLength)
    {
        if(DTS_HD_TIMECODE_MIN_LENGTH_IN_BYTES == fread(timeChunk, 1, DTS_HD_TIMECODE_MIN_LENGTH_IN_BYTES, fp))
        {
            pFileInfo->timecode.valid = dtsTrue;

            /* Read the clock */
            memcpy(&pFileInfo->timecode.clock, timeChunk, 4);
            pFileInfo->timecode.clock = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->timecode.clock);

            /* Read the frame rate */
            pFileInfo->timecode.frameRate = timeChunk[4];

            /* Read the start samples since midnight */
            memcpy(&pFileInfo->timecode.startSampSinceMidnight, &timeChunk[5], 8);
            pFileInfo->timecode.startSampSinceMidnight = AU_CUS_DTS_Parser_dtsHDEndianConvert64(pFileInfo->timecode.startSampSinceMidnight);

            /* calculate the end samples since midnight */
            pFileInfo->timecode.endSampSinceMidnight = pFileInfo->timecode.startSampSinceMidnight + pFileInfo->auPrHdr[0].numSamplesOrigAudioMaxFs;

            /* Read the start residual */  //not used
            memcpy(&pFileInfo->timecode.startResidual, &timeChunk[13], 4);
            pFileInfo->timecode.startResidual = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->timecode.startResidual);

            /* Read the reference samples since midnight */  //not used
            memcpy(&pFileInfo->timecode.refSampSinceMidnight, &timeChunk[17], 8);
            pFileInfo->timecode.refSampSinceMidnight = AU_CUS_DTS_Parser_dtsHDEndianConvert64(pFileInfo->timecode.refSampSinceMidnight);

            /* Read the reference residual */  //not used
            memcpy(&pFileInfo->timecode.refResidual, &timeChunk[25], 4);
            pFileInfo->timecode.refResidual = AU_CUS_DTS_Parser_dtsHDEndianConvert32(pFileInfo->timecode.refResidual);
        }
    }

    return;
}

dtsBoolean AU_CUS_DTS_Parser_dtsIsHDFile(FILE *fp, dtsBoolean *isHDFile)
{
    dtsUint8 chunkId[DTS_HD_CHUNK_ID_LENGTH];

    /* Assume that the file is not an HD file */
    *isHDFile = dtsFalse;

    /* Make sure this is the start of the file */
    fseek(fp, 0, SEEK_SET);

    /* Read the chunkId from the file */
    if(DTS_HD_CHUNK_ID_LENGTH != fread(chunkId, 1, DTS_HD_CHUNK_ID_LENGTH, fp))
        return dtsFalse;

    /* Check to see if it says the correct thing */
    if(0 == memcmp(chunkId, DTS_HD_CHUNK_HDR, DTS_HD_CHUNK_ID_LENGTH))
    {
        *isHDFile = dtsTrue;
    }

    return dtsTrue;
}

dtsBoolean AU_CUS_DTS_Parser_decodeChunkAndAdvance(FILE *fp, dtsUint8 *chunkId, dtsHDFileInfo *pFileInfo)
{
    dtsBoolean okToContinue = dtsTrue;
    dtsUint64 chunkSize;

    if(DTS_HD_CHUNK_LENGTH_LENGTH != fread(&chunkSize, 1, DTS_HD_CHUNK_LENGTH_LENGTH, fp))
        return dtsFalse;

    chunkSize = AU_CUS_DTS_Parser_dtsHDEndianConvert64(chunkSize);
    AU_CUS_DTS_Parser_dtsHDDecodeChunk(fp, chunkId, chunkSize, pFileInfo);

    if(0 != fseek(fp, chunkSize, SEEK_CUR))  //seek to next chunk
       return dtsFalse;

    return okToContinue;
}

void AU_CUS_DTS_Parser_dtsHDChunksInit(dtsHDFileInfo *pFileInfo)
{
    dtsUint8 i;

    for(i = 0; i < DTS_HD_MAX_ASSETS; i++)
    {
        pFileInfo->auPrHdr[i].valid = dtsFalse;
    }

    pFileInfo->hdr.valid = dtsFalse;
    pFileInfo->coreSSMD.valid = dtsFalse;
    pFileInfo->extSSMD.valid = dtsFalse;
    pFileInfo->data.valid = dtsFalse;
    pFileInfo->navi.valid = dtsFalse;
    pFileInfo->bldVer.valid = dtsFalse;
    pFileInfo->timecode.valid = dtsFalse;
}

dtsBoolean AU_CUS_DTS_Parser_dtsHDFileInitRead(FILE *fp, dtsHDFileInfo *pFileInfo)
{
    dtsUint8 chunkId[DTS_HD_CHUNK_ID_LENGTH + 1];
    unsigned int amountRead;
    HDParserState decodeState = HD_PS_START;

    /* Set all chunks to invalid */
    AU_CUS_DTS_Parser_dtsHDChunksInit(pFileInfo);

    /* Move to the start of the file */
    fseek(fp, 0, SEEK_SET);

    while(decodeState != HD_PS_EOF)
    {
        /* Re-initialise the chunk id */
        memset(chunkId, 0, sizeof(chunkId));

        /* Read the next chunk */
        amountRead = fread(chunkId, 1, DTS_HD_CHUNK_ID_LENGTH, fp);

        /* enter HD file parser state machine */
        switch(decodeState)
        {
            case HD_PS_START:   /* Check for HD header chunk */
            {
                 //chunkId = "DTSHDHDR"
                if((DTS_HD_CHUNK_ID_LENGTH == amountRead) && (0 == memcmp(chunkId, DTS_HD_CHUNK_HDR, DTS_HD_CHUNK_ID_LENGTH)))
                {
                    decodeState = HD_PS_HDR_FOUND;
                    AU_CUS_DTS_Parser_decodeChunkAndAdvance(fp, chunkId, pFileInfo);
                }
                else
                {
                    return dtsFalse;
                }
            }
            break;

            case HD_PS_HDR_FOUND:
            {
                if(DTS_HD_CHUNK_ID_LENGTH == amountRead)
                {
                    if(0 == memcmp(chunkId, DTS_HD_CHUNK_STRMDATA, DTS_HD_CHUNK_ID_LENGTH))  //chunkId = "STRMDATA"
                    {
                        decodeState = HD_PS_STREAM_FOUND;
                    }
                    AU_CUS_DTS_Parser_decodeChunkAndAdvance(fp, chunkId, pFileInfo);
                }
                else
                {
                    return dtsFalse;
                }
            }
            break;

            case HD_PS_STREAM_FOUND:
                if(amountRead == 0)
                {
                    fsetpos(fp, &pFileInfo->data.currentFilePosition);
                    decodeState = HD_PS_EOF;
                }
                else if(amountRead == DTS_HD_CHUNK_ID_LENGTH)
                    AU_CUS_DTS_Parser_decodeChunkAndAdvance(fp, chunkId, pFileInfo);
                else
                    return dtsFalse;
                break;

           default:
                break;
        }
    }

    return dtsTrue;
}

dtsBoolean AU_CUS_DTS_Parser_dtsHDFileRead(FILE *fp, dtsUint8 *pBytes, dtsUint32 numberOfBytesToRead, dtsHDFileInfo *pFileInfo)
{
    dtsBoolean okToContinue = dtsTrue;
    fpos_tt oldPosition;

    /* Check to see that there are enough bytes left in the chunk to read */
    if(pFileInfo->data.bytesRead + numberOfBytesToRead > pFileInfo->data.streamDataByteSize)
    {
        pFileInfo->eof = dtsTrue;
        return dtsFalse;
    }

    if(0 != fgetpos(fp, &oldPosition))
       return dtsFalse;

    if(0 != fsetpos(fp, &pFileInfo->data.currentFilePosition))
       return dtsFalse;

    fread(pBytes, 1, numberOfBytesToRead, fp);

    pFileInfo->data.bytesRead += numberOfBytesToRead;

    if(0 != fgetpos(fp, &pFileInfo->data.currentFilePosition))
        return dtsFalse;

    if(0 != fsetpos(fp, &oldPosition))
        return dtsFalse;

    return okToContinue;
}

static dtsBoolean AU_CUS_DTS_Parser_dtsReadWavFileHeader(FILE *fp, dtsWavFileHeader *header)
{
    dtsBoolean okToContinue = dtsTrue;

    if(0 != fseek(fp, 0, SEEK_SET))
        return dtsFalse;

    /* Read the file id */
    if(DTS_WAV_FILE_ID_LENGTH != fread(header->id, 1, DTS_WAV_FILE_ID_LENGTH, fp))
        return dtsFalse;

    /* Read the length of the file */
    if(4 != fread(&header->length, 1, 4, fp))
        return dtsFalse;

    /* Read the content of the wav file */
    if(DTS_WAV_FILE_CONTENT_LENGTH != fread(header->content, 1, DTS_WAV_FILE_CONTENT_LENGTH, fp))
        return dtsFalse;

    return okToContinue;
}

static dtsBoolean AU_CUS_DTS_Parser_dtsWavFileHeaderIsValid(dtsWavFileHeader *header)
{
    dtsBoolean headerIsValid = dtsFalse;

    if(0 == memcmp(header->id, DTS_WAV_FILE_IDENTIFIER, DTS_WAV_FILE_ID_LENGTH))
    {
        if(0 == memcmp(header->content, DTS_WAV_FILE_CONTENT, DTS_WAV_FILE_CONTENT_LENGTH))
        {
            headerIsValid = dtsTrue;
        }
    }

    return headerIsValid;
}

static dtsBoolean AU_CUS_DTS_Parser_dtsWavFileLocateChunk(FILE *fp, const char *chunkId)
{
    dtsBoolean okToContinue = dtsTrue;
    dtsUint8 fileChunkId[DTS_WAV_FILE_CHUNK_ID_LENGTH];
    dtsBoolean chunkFound;
    dtsUint32 chunkLength;

    /* Indicate that the chunk has not been found */
    chunkFound = dtsFalse;
    while((dtsFalse == chunkFound) && (dtsTrue == okToContinue))
    {
        if(DTS_WAV_FILE_CHUNK_ID_LENGTH != fread(fileChunkId, 1, DTS_WAV_FILE_CHUNK_ID_LENGTH, fp))
        {
            okToContinue = dtsFalse;
        }
        else
        {
            if(0 == memcmp(fileChunkId, chunkId, DTS_WAV_FILE_CHUNK_ID_LENGTH))
            {
                chunkFound = dtsTrue;
            }
            else
            {
                /* Read the length of the chunk */
                if(DTS_WAV_FILE_CHUNK_LENGTH_LENGTH != fread(&chunkLength, 1, 4, fp))
                {
                    okToContinue = dtsFalse;
                }
                else
                {
                    /* Move to the next position */
                    if(0 != fseek(fp, chunkLength, SEEK_CUR))
                    {
                        okToContinue = dtsFalse;
                    }
                }
            }
        }

    } /* End of while statememt */

    if(dtsTrue == okToContinue)
    {
        okToContinue = chunkFound;
    }

    return okToContinue;
}

dtsBoolean AU_CUS_DTS_Parser_dtsIsWavFile(FILE *fp, dtsBoolean *isWavFile)
{
    dtsBoolean okToContinue = dtsFalse;
    dtsWavFileHeader header;

    /* Assume that it is not a wav file */
    *isWavFile = dtsFalse;

    /* Read the header */
    okToContinue = AU_CUS_DTS_Parser_dtsReadWavFileHeader(fp, &header);

    /* Check to see if it is valid */
    if(dtsTrue == okToContinue)
    {
        *isWavFile = AU_CUS_DTS_Parser_dtsWavFileHeaderIsValid(&header);
    }

    return okToContinue;
}

dtsBoolean AU_CUS_DTS_Parser_dtsWavFileInitRead(FILE *fp, dtsWavFileInfo *pFileInfo)
{
    dtsBoolean okToContinue = dtsFalse;
    dtsWavFileHeader header;
    dtsUint32 chunkLength = 0;
    dtsUint8 formatBuffer[DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE];
    dtsUint32 formatBufferIndex;

    /* Only interested in reading */
    pFileInfo->isWritable = dtsFalse;

    /* Read the header */
    okToContinue = AU_CUS_DTS_Parser_dtsReadWavFileHeader(fp, &header);
    if(dtsTrue == okToContinue)
    {
        /* Check that it is a valid wav file */
        okToContinue = AU_CUS_DTS_Parser_dtsWavFileHeaderIsValid(&header);
    }

    /* Find the format chunk */
    if(dtsTrue == okToContinue)
    {
        if(dtsTrue == AU_CUS_DTS_Parser_dtsWavFileLocateChunk(fp, DTS_WAV_FILE_FORMAT_CHUNK_ID))
        {
            /* Read the length of the chunk */
            if(dtsUint32SizeBytes != fread(&chunkLength, 1, 4, fp))
            {
                okToContinue = dtsFalse;
            }
        }
        else
        {
            okToContinue = dtsFalse;
        }
    }

    /* Verify the length and read the rest of the format */
    if(dtsTrue == okToContinue)
    {
        if(chunkLength != DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE)
        {
            okToContinue = dtsFalse;
        }
        else
        {
            if(DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE != fread(formatBuffer, 1, DTS_WAV_FILE_FORMAT_PCM_CHUNK_PAYLOAD_SIZE, fp))
            {
                okToContinue = dtsFalse;
            }
            else
            {
                /* Read each of the fields from the chunk data */
                formatBufferIndex = 0;
                memcpy(&pFileInfo->format.wFormatTag, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.wFormatTag));
                pFileInfo->format.wFormatTag = (pFileInfo->format.wFormatTag);
                formatBufferIndex += sizeof(pFileInfo->format.wFormatTag);
                memcpy(&pFileInfo->format.wChannels, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.wChannels));
                pFileInfo->format.wChannels = (pFileInfo->format.wChannels);
                formatBufferIndex += sizeof(pFileInfo->format.wChannels);
                memcpy(&pFileInfo->format.dwSamplesPerSec, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.dwSamplesPerSec));
                pFileInfo->format.dwSamplesPerSec = (pFileInfo->format.dwSamplesPerSec);
                formatBufferIndex += sizeof(pFileInfo->format.dwSamplesPerSec);
                memcpy(&pFileInfo->format.dwAvgBytesPerSec, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.dwAvgBytesPerSec));
                pFileInfo->format.dwAvgBytesPerSec = (pFileInfo->format.dwAvgBytesPerSec);
                formatBufferIndex += sizeof(pFileInfo->format.dwAvgBytesPerSec);
                memcpy(&pFileInfo->format.wBlockAlign, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.wBlockAlign));
                pFileInfo->format.wBlockAlign = (pFileInfo->format.wBlockAlign);
                formatBufferIndex += sizeof(pFileInfo->format.wBlockAlign);
                memcpy(&pFileInfo->format.wBitsPerSample, &formatBuffer[formatBufferIndex], sizeof(pFileInfo->format.wBitsPerSample));
                pFileInfo->format.wBitsPerSample = (pFileInfo->format.wBitsPerSample);

                /* Check that the format tag says PCM */
                if(DTS_WAV_FILE_FORMAT_PCM_ID != pFileInfo->format.wFormatTag)
                {
                    okToContinue = dtsFalse;
                }
            }
        }
    }

    /* Read the header from the data chunk ... always occurs sometime after a format chunk */
    if(dtsTrue == okToContinue)
    {
        if(dtsTrue == AU_CUS_DTS_Parser_dtsWavFileLocateChunk(fp, DTS_WAV_FILE_DATA_CHUNK_ID))
        {
            /* Read the length of the chunk */
            if(dtsUint32SizeBytes !=fread(&chunkLength, 1, 4, fp))
            {
                okToContinue = dtsFalse;
            }
            else
            {
                /* Store the length */
                pFileInfo->data.lengthInBytes = chunkLength;

                /* Initialise the number of bytes read from the chunk */
                pFileInfo->data.bytesRead = 0;

                /* This is not the end of the file */
                pFileInfo->eof = dtsFalse;

                /* Read the current position in the file */
                fgetpos(fp, &pFileInfo->readInfo.nextReadPosition);
            }
        }
        else
        {
            okToContinue = dtsFalse;
        }
    }

    pFileInfo->isInit = okToContinue;

    return okToContinue;
}

dtsBoolean AU_CUS_DTS_Parser_ParseInputFile(const char *pFileName)
{
    dtsBoolean okToContinue = dtsTrue;
    dtsBoolean isFileType = dtsFalse;
    uint32_t totalbytes; /* number of bytes in input file */
    FILE *p_infile;

    p_infile = fopen(pFileName, "rb");

    if (p_infile == NULL)
    {
        printf("input open file FAIL %s\n", pFileName);
        return dtsFalse;
    }
    fseek(p_infile, 0, SEEK_END);
    totalbytes = ftell(p_infile);
    fseek(p_infile, 0, SEEK_SET);

    if (totalbytes == 0)
        return (dtsFalse);

    //---found DTS WAV file---
    if(AU_CUS_DTS_Parser_dtsIsWavFile(p_infile, &isFileType) != dtsTrue)
        return dtsFalse;

    if(isFileType == dtsTrue)
    {
        /* Initialise the wav file */
        dtsfile_info.type = DTS_FILETYPE_WAV;
        okToContinue = AU_CUS_DTS_Parser_dtsWavFileInitRead(p_infile, &dtsfile_info.info.wav);
        return okToContinue;
    }

    //---found DTS HD file---
    if(AU_CUS_DTS_Parser_dtsIsHDFile(p_infile, &isFileType) != dtsTrue)
       return dtsFalse;

    if(dtsTrue == isFileType)
    {
        dtsfile_info.type = DTS_FILETYPE_DTSHD;

        //parse each chunk in the file, until to file-ending.
        okToContinue = AU_CUS_DTS_Parser_dtsHDFileInitRead(p_infile, &dtsfile_info.info.dtshd);
    }
    else
    {
        //---found PCM file---
        dtsfile_info.type = DTS_FILETYPE_RAW_PCM;
        if (-1 == fseek(p_infile, 0, SEEK_END))
            return dtsFalse;

        dtsfile_info.info.pcm.size = (dtsUint32)ftell(p_infile);
        rewind(p_infile);
    }
#if 0
    *inputFile = p_infile;
#endif
    pAU_debug_input_file = p_infile;

    return okToContinue;
}
#endif //#if(DTS_AUDIO_PARSER_ENABLE)

#if(WMA_AUDIO_PARSER_ENABLE)
int AU_CUS_WMA_Parser_Buf_Update(int bRead, unsigned int u32Size, Buffer_Control_t* pBuf)
{
    int iRV = 0;
    if(bRead == 1)
    {
        unsigned char* pRPtr = pBuf->pRptr + u32Size;

        if(pRPtr > pBuf->pEndAddr)
        {
            WMA_DBG_PRINT(printf("=== rptr(0x%x), endptr(0x%x) === \n", (unsigned int)pRPtr, (unsigned int)pBuf->pEndAddr));
            iRV = -1;
        }
        else
        {
            pBuf->consumed_bytes += u32Size;
            pBuf->pRptr += u32Size;
            pBuf->u32Level -= u32Size;

            // all data finish, reset pointer
            if(pBuf->u32Level == 0)
            {
                pBuf->pRptr = pBuf->pStartAddr;
                pBuf->pWptr = pBuf->pStartAddr;
            }
        }
    }
    else
    {
        unsigned char* pWPtr = pBuf->pWptr + u32Size;

        if(pWPtr > pBuf->pEndAddr)
        {
            iRV = -1;
        }
        else
        {
            pBuf->pWptr += u32Size;
            pBuf->u32Level += u32Size;
        }
    }

    return iRV;
}

int AU_CUS_WMA_Parser_DecodeFifoFeed(void)
{
    Buffer_Control_t* pDecodeBuf = &sDecodeFifo_Info;
    unsigned int u32SizeGet = 0;
    unsigned int u32RequestSize = pDecodeBuf->u32Size - pDecodeBuf->u32Level; // remain buffer space
    int iRV = 0;

    if (u32RequestSize <= 0)
    {
        WMA_DBG_PRINT(printf("=== no enough ES in framework, fail to fill decode fifo, request_Size(0x%x) \n", u32RequestSize));
        iRV = -1;
        return iRV;
    }

    if (0 != fseek (g_wmaInput_fp, (unsigned int)u64FileOffset, SEEK_SET))
    {
        return iRV;
    }

    if (pDecodeBuf->u32Level != 0)
    {
        memmove(pDecodeBuf->pStartAddr, pDecodeBuf->pRptr, (size_t)pDecodeBuf->u32Level);
        pDecodeBuf->pWptr = pDecodeBuf->pStartAddr + pDecodeBuf->u32Level;
        pDecodeBuf->pRptr = pDecodeBuf->pStartAddr;
    }

    u32SizeGet = fread(pDecodeBuf->pWptr , 1, (size_t)u32RequestSize, g_wmaInput_fp);

    if (u32SizeGet == 0)
    {
        return iRV;
    }

    if (u32SizeGet < u32RequestSize)
    {
        printf("\n  !!! EOF !!! , request size(0x%x), get size(0x%x)\n", (unsigned int)u32RequestSize, (unsigned int)u32SizeGet);
        bEOF = 1;
    }

    AU_CUS_WMA_Parser_Buf_Update(BUF_WRITE, u32SizeGet, pDecodeBuf);

    WMA_DBG_PRINT(printf("=== SizeRequest:  (%d), SizeGet:  (%d),  Offset (%d), === \n", (int)u32RequestSize, (int)u32SizeGet, (int)u64FileOffset));

    u64FileOffset += u32SizeGet;

    return iRV;
}

// When previous and current file offset mismatch , need to skip bytes, either backward or forward
unsigned int AU_CUS_WMA_Parser_WMAEsSkip(int bJumpForward, unsigned int u32SkipSize, Buffer_Control_t* pBuf)
{
    int iRV = 0;

    if(bJumpForward == 1)
    {
        // jump to the future --> flush ES bytes, read pointer increase
        pBuf->u32Level -= u32SkipSize;
        pBuf->pRptr += u32SkipSize;
    }
    else
    {
        // jump to the past, --> reduce read pointer
        pBuf->u32Level += u32SkipSize;
        pBuf->pRptr -= u32SkipSize;
    }

    return iRV;
}

unsigned int AU_CUS_WMA_Parser_WMAGetData(unsigned long long offset, unsigned int num_bytes, char  **ppData)
{
    Buffer_Control_t* pBuf = &sDecodeFifo_Info;
    unsigned int  u32BytesSkip = 0;
    int bJumpForward = 1;
    unsigned int u32SizeGet = num_bytes;
    unsigned long long *pExpectOffset = &u64offset_expect;

    AU_CUS_WMA_Parser_DecodeFifoFeed();
    WMA_DBG_PRINT(printf("=== AU_CUS_WMA_Parser_WMAGetData, offset(0x%x), size(%d), expect_offset(0x%x), level(%d) === \n", (unsigned int)offset, (int)num_bytes, (unsigned int)*pExpectOffset, (int)pBuf->u32Level));

    if (pBuf->u32Level < MaxRequestSize)
    {
        WMA_DBG_PRINT(printf("=== not enough ES data for feeding, wait state === \n"));
        return 0;
    }

    // if expected offset doesn't equal real offset, means skip bytes happens, handle carefully
    if(offset > *pExpectOffset)
    {
        u32BytesSkip = offset - *pExpectOffset;

        if(u32BytesSkip <= pBuf->u32Level)
        {
            AU_CUS_WMA_Parser_WMAEsSkip(bJumpForward, u32BytesSkip, pBuf);

            u32BytesSkip = 0;
        }
        else
        {
            while(u32BytesSkip)
            {
                WMA_DBG_PRINT(printf("=== Remain skip bytes (%d) === \n ", (int)u32BytesSkip));
                if(u32BytesSkip > pBuf->u32Level)
                {
                    u32BytesSkip -= pBuf->u32Level;

                    AU_CUS_WMA_Parser_WMAEsSkip(bJumpForward, pBuf->u32Level, pBuf);

                    pBuf->pRptr = pBuf->pStartAddr;
                    pBuf->pWptr = pBuf->pStartAddr;
                }
                else
                {
                    AU_CUS_WMA_Parser_WMAEsSkip(bJumpForward, u32BytesSkip, pBuf);

                    u32BytesSkip = 0;
                }

                u32BytesSkip = u32BytesSkip;

                // if feeding fail, no new data in ES buffer
                if (AU_CUS_WMA_Parser_DecodeFifoFeed() != 0)
                {
                    WMA_DBG_PRINT(puts("=== AU_CUS_WMA_Parser_DecodeFifoFeed fail  === \n"));
                    break;
                }
            }

        }
    }
    else if (offset < *pExpectOffset)
    {
        u32BytesSkip = *pExpectOffset - offset;
        bJumpForward = 0;

        AU_CUS_WMA_Parser_WMAEsSkip(bJumpForward, u32BytesSkip, pBuf);
    }

    if (pBuf->u32Level < num_bytes)
    {
        u32SizeGet = pBuf->u32Level;
    }

    *ppData = (char*)pBuf->pRptr;

    // prepare for next round check
    *pExpectOffset = offset + u32SizeGet;

    // update level, read pointer
    AU_CUS_WMA_Parser_Buf_Update(BUF_READ, u32SizeGet, pBuf);

    return u32SizeGet;
}

WMAERR AU_CUS_WMA_Parser_LoadHeaderObject(tWMAFileHdrStateInternal *pInt)
{
    GUID objectId;
    QWORD qwSize;
    unsigned int cHeaders =0;
    unsigned char align =0;
    unsigned char arch =0;

    unsigned char *pData = NULL;
    unsigned int cbActual =0;
    unsigned int cbWanted =0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbWanted = MIN_OBJECT_SIZE + sizeof(unsigned int) + 2*sizeof(unsigned char);
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset, cbWanted, (char**)&pData);

    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    pInt->currPacketOffset += cbActual;

    LoadGUID(objectId, pData);
    LoadQWORD(qwSize, pData);
    LoadDWORD(cHeaders, pData);
    cHeaders = cHeaders;
    LoadBYTE(align, pData);
    LoadBYTE(arch, pData);

    if(!WMA_IsEqualGUID(&CLSID_CAsfHeaderObjectV0, &objectId)
            || align != 1
            || arch  != 2)
    {
        return WMAERR_INVALIDHEADER;
    }

    /* use all */
    pInt->cbHeader = qwSize.dwLo;

    return WMAERR_OK;
}

static unsigned int AU_CUS_WMA_Parser_HnsQWORDtoMsDWORD (QWORD qw)
{
    unsigned int msLo, msHi;

    msLo = qw.dwLo/10000;
    msHi = (unsigned int)((float)qw.dwHi*429496.7296);

    return msLo + msHi;
}

WMAERR AU_CUS_WMA_Parser_LoadPropertiesObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    GUID  mmsId;
    QWORD qwTotalSize;
    QWORD qwCreateTime;
    QWORD qwPackets;
    QWORD qwPlayDuration;
    QWORD qwSendDuration;
    QWORD qwPreroll;
    unsigned int dwFlags         = 0;
    unsigned int dwMinPacketSize = 0;
    unsigned int dwMaxPacketSize = 0;
    unsigned int dwMaxBitrate    = 0;

    unsigned char *pData   = NULL;
    unsigned int  cbActual = 0;
    unsigned int  cbWanted = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }
    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = sizeof(GUID) + 6*sizeof(QWORD) + 4*sizeof(unsigned int);
    if(cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    LoadGUID(mmsId, pData);
    mmsId = mmsId;
    LoadQWORD(qwTotalSize, pData);
    qwTotalSize = qwTotalSize;
    LoadQWORD(qwCreateTime, pData);
    qwCreateTime = qwCreateTime;
    LoadQWORD(qwPackets, pData);
    LoadQWORD(qwPlayDuration, pData);
    qwPlayDuration = qwPlayDuration;
    LoadQWORD(qwSendDuration, pData);
    LoadQWORD(qwPreroll, pData);
    LoadDWORD(dwFlags, pData);
    LoadDWORD(dwMinPacketSize, pData);
    LoadDWORD(dwMaxPacketSize, pData);
    LoadDWORD(dwMaxBitrate, pData);
    dwMaxBitrate = dwMaxBitrate;

    if( (dwMinPacketSize != dwMaxPacketSize) || (qwPackets.dwLo == 0 && qwPackets.dwHi == 0) )
    {
        return WMAERR_FAIL;
    }

    pInt->cbPacketSize = dwMaxPacketSize;
    pInt->cPackets     = qwPackets.dwLo;
    pInt->msDuration   = AU_CUS_WMA_Parser_HnsQWORDtoMsDWORD(qwSendDuration);
    pInt->msPreroll    = qwPreroll.dwLo;
    pInt->dwFilePropertiesFlags = dwFlags;

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

void *AU_CUS_WMA_Parser_auMalloc(const size_t iSize)
{
    return malloc(iSize);
}

void AU_CUS_WMA_Parser_auFree(void *pFree)
{
    free(pFree);
}

WMAERR AU_CUS_WMA_Parser_LoadLicenseStoreObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    unsigned char *pData         = NULL;
    unsigned int  cbActual       = 0;
    unsigned int  cbWanted       = 0;
    unsigned int  cbOffset       = 0;
    unsigned int  cbWanted1      = 0;
    unsigned int  m_dwFlag       = 0;
    unsigned int  cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 8;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD(m_dwFlag, pData);
    m_dwFlag = m_dwFlag;
    LoadDWORD(pInt->m_dwLicenseLen, pData);

    cbWanted = pInt->m_dwLicenseLen;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_NOTDONE;
    }

    pInt->m_pLicData = AU_CUS_WMA_Parser_auMalloc(cbWanted);
    if (NULL ==  pInt->m_pLicData)
    {
        return WMAERR_OUTOFMEMORY;
    }

    if(cbWanted > MAX_BUFSIZE)
    {
        cbOffset=0;
        do
        {
            cbWanted1 =  cbWanted > MAX_BUFSIZE ? MAX_BUFSIZE : cbWanted;
            cbActual  = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted1, (char**)&pData);
            if(cbActual != cbWanted1)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbObjectOffset += cbActual;
            cbWanted -= cbActual;
            if(cbOffset+cbActual  <= (unsigned int)pInt->m_dwLicenseLen)
            {
                memcpy(pInt->m_pLicData+cbOffset, pData, cbActual);
            }
            else
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbOffset +=cbActual;
        }
        while(cbWanted >0);
    }
    else
    {
        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbObjectOffset += cbActual;
        memcpy(pInt->m_pLicData, pData, cbActual);
    }

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr(tHWMAFileState *pInt, unsigned long long *piCurrFileOffset,
                                  const unsigned long long iMaxFileOffset, unsigned short *pcbTotalBytesWanted, unsigned char **ppBuffer)
{
    unsigned char *pData        = NULL;
    WMAERR        wmaerr        = WMAERR_OK;
    unsigned int  cbBytesToRead = 0;
    unsigned int  cbBytesRead   = 0;
    unsigned char *pBuffer      = NULL;

    // WMAFileCBGetData uses MAX_BUFSIZE, but this function uses WMA_MAX_DATA_REQUESTED.
    // I don't know why we need two constants here, but just make sure our assumptions hold.

    // Check if reading the requested number of bytes would push us past end of object
    if (*piCurrFileOffset + *pcbTotalBytesWanted > iMaxFileOffset)
    {
        wmaerr = (WMAERR_CORRUPTDATA);

        // Return directly, to avoid advancing *piCurrFileOffset into hyperspace
        return wmaerr;
    }

    // Limit us to a reasonable size, esp for embedded devices. No 64kB artist names!
    cbBytesToRead = *pcbTotalBytesWanted;
    if (cbBytesToRead > WMA_MAX_METADATA_LEN)
    {
        cbBytesToRead = WMA_MAX_METADATA_LEN;
    }

    pBuffer = AU_CUS_WMA_Parser_auMalloc(cbBytesToRead + sizeof(unsigned short)); // +1 for null-term
    if (NULL == pBuffer)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }

    memset(pBuffer, 0, cbBytesToRead + sizeof(unsigned short)); // +1 for null-term

    for (cbBytesRead = 0; cbBytesRead < cbBytesToRead; )
    {
        unsigned int cbWanted;
        unsigned int cbActual;

        cbWanted = MIN(WMA_MAX_DATA_REQUESTED, (cbBytesToRead - cbBytesRead));
        cbActual = AU_CUS_WMA_Parser_WMAGetData(*piCurrFileOffset + cbBytesRead, cbWanted, (char**)&pData);
        if (cbActual != cbWanted)
        {
            wmaerr = (WMAERR_BUFFERTOOSMALL);
            goto exit;
        }

        memcpy(&pBuffer[cbBytesRead], pData, cbActual);
        cbBytesRead += cbActual;
    }

    if (cbBytesRead != cbBytesToRead)
    {
        wmaerr = (WMAERR_BUFFERTOOSMALL);
        goto exit;
    }

exit:
    // Deal with errors in a "transactional" fashion: either succeed completely,
    // or fail completely. In other words, clean up if we encountered any errors.
    if (WMAERR_OK != wmaerr)
    {
        cbBytesRead = 0;
        if (pBuffer)
        {
            AU_CUS_WMA_Parser_auFree(pBuffer);
            pBuffer = NULL;
        }
    }

    // Return our results
    *piCurrFileOffset += *pcbTotalBytesWanted;          // Increment by requested amt even if we truncated
    *pcbTotalBytesWanted = (unsigned short)cbBytesRead; // Report actual number of bytes read
    *ppBuffer = pBuffer;

    return wmaerr;
}

WMAERR AU_CUS_WMA_Parser_LoadVirtualMetaDataObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize, unsigned int Offset)
{
    unsigned char *pData   = NULL;
    unsigned int  cbActual = 0;
    unsigned int  cbWanted = 0;
    unsigned long long iCurrFileOffset;
    unsigned long long iMaxFileOffset;
    WMAERR         wmaerr = WMAERR_OK;
    unsigned short DescRecCount = 0;
    unsigned short i = 0;

    WMA_MetaDataDescRecords *tDesc = NULL;

    iCurrFileOffset = pInt->currPacketOffset + Offset + MIN_OBJECT_SIZE;
    iMaxFileOffset  = iCurrFileOffset + cbSize - MIN_OBJECT_SIZE;

    if (pInt->ptMetaDataEntry)
    {
        goto exit;
    }

    // Load Description Records Count
    cbWanted = 2;
    if (iCurrFileOffset + cbWanted > iMaxFileOffset)
    {
        wmaerr = (WMAERR_CORRUPTDATA);
        goto exit;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset,   cbWanted, (char**)&pData);
    if (cbActual != cbWanted)
    {
        wmaerr = (WMAERR_BUFFERTOOSMALL);
        goto exit;
    }

    iCurrFileOffset += cbActual;
    LoadWORD(DescRecCount , pData);

    if (0 == DescRecCount)
    {
        goto exit;
    }

    // Allocate a description records structure, and an array to hold all description records
    pInt->ptMetaDataEntry = AU_CUS_WMA_Parser_auMalloc(sizeof(WMA_MetaDataEntry));
    if (NULL == pInt->ptMetaDataEntry)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }

    pInt->ptMetaDataEntry->m_wDescRecordsCount = DescRecCount;

    pInt->ptMetaDataEntry->pDescRec = AU_CUS_WMA_Parser_auMalloc(DescRecCount * sizeof(WMA_MetaDataDescRecords));
    if (NULL == pInt->ptMetaDataEntry->pDescRec)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }
    memset(pInt->ptMetaDataEntry->pDescRec, 0, DescRecCount * sizeof(WMA_MetaDataDescRecords));
    tDesc = pInt->ptMetaDataEntry->pDescRec;

    // Read in all description records
    for (i = 0; i < DescRecCount; i++)
    {
        // Load in the fixed portion of the description record
        cbWanted = 12;
        if (iCurrFileOffset + cbWanted > iMaxFileOffset)
        {
            wmaerr = (WMAERR_CORRUPTDATA);
            goto exit;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset, cbWanted, (char**)&pData);
        if (cbActual != cbWanted)
        {
            wmaerr = (WMAERR_BUFFERTOOSMALL);
            goto exit;
        }
        iCurrFileOffset += cbActual;

        LoadWORD ( tDesc[i].wLangIdIndex , pData );
        LoadWORD ( tDesc[i].wStreamNumber, pData );
        LoadWORD ( tDesc[i].wNameLenth   , pData );
        LoadWORD ( tDesc[i].wDataType    , pData );
        LoadDWORD( tDesc[i].dwDataLength , pData );

        // verify data length with respect to data type.


        // Read in the name. Truncate if necessary.
        wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset, iMaxFileOffset, &tDesc[i].wNameLenth, (unsigned char **)&tDesc[i].pwName);
        if (WMAERR_OK != wmaerr)
        {
            goto exit;
        }

        // Read in the value.
        if (ECD_STRING == tDesc[i].wDataType)
        {
            unsigned short wDataLength = 0;
            unsigned int   dwAdditionalSkip = 0;

            if (tDesc[i].dwDataLength > 0x0000FFFF)
            {
                // Truncate to 16-bit size, and remember to add the remainder to file offset
                dwAdditionalSkip = tDesc[i].dwDataLength - 0x0000FFFF;
                tDesc[i].dwDataLength = 0x0000FFFF;
            }

            // We will truncate this string if necessary
            wDataLength = (unsigned short)tDesc[i].dwDataLength;
            wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset, iMaxFileOffset, &wDataLength, &tDesc[i].pData);
            tDesc[i].dwDataLength = wDataLength;
            if (WMAERR_OK != wmaerr)
            {
                goto exit;
            }

            iCurrFileOffset += dwAdditionalSkip;
        }
        else
        {
            unsigned int cbBytesRead;
            const unsigned int cbBytesToRead = tDesc[i].dwDataLength;

            // Do not truncate
            // Check if reading this object takes us past end of object
            if (iCurrFileOffset + tDesc[i].dwDataLength > iMaxFileOffset)
            {
                wmaerr = (WMAERR_CORRUPTDATA);
                goto exit;
            }

            tDesc[i].pData = AU_CUS_WMA_Parser_auMalloc(tDesc[i].dwDataLength);
            if (NULL == tDesc[i].pData)
            {
                wmaerr = (WMAERR_OUTOFMEMORY);
                goto exit;
            }

            for (cbBytesRead = 0; cbBytesRead < cbBytesToRead; )
            {
                cbWanted = MIN(MAX_BUFSIZE, (cbBytesToRead - cbBytesRead));
                cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset + cbBytesRead,  cbWanted, (char**)&pData);
                if (cbActual != cbWanted)
                {
                    wmaerr = (WMAERR_BUFFERTOOSMALL);
                    goto exit;
                }

                memcpy(&tDesc[i].pData[cbBytesRead], pData, cbActual);
                cbBytesRead += cbActual;
            }

            if (cbBytesRead != cbBytesToRead)
            {
                wmaerr = (WMAERR_BUFFERTOOSMALL);
                goto exit;
            }

            iCurrFileOffset += cbBytesRead;

        } // else (NOT ECD_STRING)
    }

exit:
    // Deal with errors in a "transactional" fashion: either succeed completely,
    // or fail completely. In other words, clean up if we encountered any errors.
    if (WMAERR_OK != wmaerr)
    {
        if (pInt->ptMetaDataEntry)
        {
            if (pInt->ptMetaDataEntry->pDescRec)
            {
                tDesc = pInt->ptMetaDataEntry->pDescRec;
                for (i = 0; i < pInt->ptMetaDataEntry->m_wDescRecordsCount; i++)
                {
                    // it's OK to pass NULL pointers to free
                    AU_CUS_WMA_Parser_auFree(tDesc[i].pwName);
                    AU_CUS_WMA_Parser_auFree(tDesc[i].pData);
                }
                AU_CUS_WMA_Parser_auFree(pInt->ptMetaDataEntry->pDescRec);
            }

            AU_CUS_WMA_Parser_auFree(pInt->ptMetaDataEntry);
            pInt->ptMetaDataEntry = NULL;
        }
    }

    // Note: This function is not responsible for advancing pInt->currPacketOffset

    return wmaerr;
}

WMAERR AU_CUS_WMA_Parser_LoadVirtualObjectHeader(tWMAFileHdrStateInternal *pInt, GUID *pObjectId, QWORD *pqwSize, unsigned int Offset)
{
    unsigned char *pData = NULL;
    unsigned int cbActual =0;
    unsigned int cbWanted =0;

    cbWanted = MIN_OBJECT_SIZE;
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + Offset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    LoadGUID((*pObjectId), pData);
    LoadQWORD((*pqwSize), pData);

    if (pqwSize->dwLo  < MIN_OBJECT_SIZE)
    {
        return WMAERR_INVALIDHEADER;
    }

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_LoadAudioObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    GUID streamType;
    GUID ecStrategy;
    QWORD qwOffset;
    unsigned int cbTypeSpecific   = 0;
    unsigned int cbErrConcealment = 0;
    unsigned short wStreamNum     = 0;
    unsigned int dwJunk           = 0;
    unsigned int nBlocksPerObject = 0;
    AsfXAcmAudioErrorMaskingData *pScramblingData=NULL;
    // WAVEFORMATEX *pFmt;

    unsigned char *pData  = NULL;
    unsigned int cbActual = 0;
    unsigned int cbWanted = 0;

    unsigned short      tw  = 0;
    unsigned int        tdw = 0;
    const unsigned char *tp = NULL;
    unsigned int cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 2*sizeof(GUID) + sizeof(QWORD) + 3*sizeof(unsigned int) + sizeof(unsigned short);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadGUID(streamType, pData);
    LoadGUID(ecStrategy, pData);
    LoadQWORD(qwOffset, pData);
    qwOffset = qwOffset;
    LoadDWORD(cbTypeSpecific, pData);
    LoadDWORD(cbErrConcealment, pData);
    LoadWORD(wStreamNum, pData);
    LoadDWORD(dwJunk, pData);
    dwJunk = dwJunk;

    wStreamNum &= 0x7F;

    if( !WMA_IsEqualGUID( &CLSID_AsfXStreamTypeAcmAudio, &streamType ) )
    {
        /* Skip over the rest */
        pInt->currPacketOffset += cbSize;
        return WMAERR_OK;
    }
    pInt->cAudioStreams++;

    if (pInt->cAudioStreams != pInt->wTargetAudioStreamNumber)
    {
        // We dont want to decode this stream
        /* Skip over the rest */
        pInt->currPacketOffset += cbSize;
        return WMAERR_OK;
    }

    /* Type specific */
    pInt->wAudioStreamId = wStreamNum; //Amit

    if(cbTypeSpecific > 0)
    {
        cbWanted = cbTypeSpecific;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        tp = pData;
        LoadWORD (tw ,tp);
        pInt->wFormatTag = tw;

        switch(tw)
        {
            case WAVE_FORMAT_WMAUDIO3: // fall into
            case WAVE_FORMAT_WMAUDIO_LOSSLESS:
            {
                if(cbTypeSpecific < 36)
                {
                    return WMAERR_FAIL;
                }
                pInt->nVersion         = 3;
                tp = pData +  4;
                LoadDWORD(tdw,tp);
                pInt->nSamplesPerSec   = tdw;
                tp = pData +  8;
                LoadDWORD(tdw,tp);
                pInt->nAvgBytesPerSec  = tdw;
                tp = pData + 12;
                LoadWORD (tw ,tp);
                pInt->nBlockAlign      = tw;
                tp = pData +  2;
                LoadWORD (tw ,tp);
                pInt->nChannels        = tw;

                // New information in V9
                pInt->wPCMFormatTag = WAVE_FORMAT_EXTENSIBLE;
                tp = pData + 14;
                LoadWORD (tw, tp);
                pInt->wValidBitsPerSample   = tw; // Container size

                // Round up the container size
                pInt->wBitsPerSample = 8 * ((pInt->wValidBitsPerSample + 7)/8);

                // Digest additional information
                tp = pData + 16;
                LoadWORD (tw, tp);

                // Has V3 specific info
                // pData+18 would be reserved.
                tp = pData + 20;
                LoadDWORD (tdw, tp);
                pInt->dwChannelMask = tdw;

                // pData+24, pData+28 are reseved DWORD
                tp = pData + 28;
                LoadDWORD (tdw, tp);
                pInt->nAdvancedEncodeOpt2 = tdw;
                tp = pData + 32;
                LoadWORD  (tw, tp);
                pInt->nEncodeOpt          = tw;
                tp = pData + 34;
                LoadWORD  (tw, tp);
                pInt->nAdvancedEncodeOpt  = tw;

                // set the GUID for file write: Should be done elsewhere
                // GUID information:
                COPY_KSDATAFORMAT_SUBTYPE_PCM(&(pInt->SubFormat));
            }
            break;

            case WAVE_FORMAT_WMAUDIO2:
            {
                if(cbTypeSpecific < 28 /*sizeof(WMAUDIO2WAVEFORMAT)*/)
                {
                    return WMAERR_FAIL;
                }

                pInt->nVersion         = 2;
                tp = pData +  4;
                LoadDWORD(tdw,tp);
                pInt->nSamplesPerSec   = tdw;
                tp = pData +  8;
                LoadDWORD(tdw,tp);
                pInt->nAvgBytesPerSec  = tdw;
                tp = pData + 12;
                LoadWORD (tw ,tp);
                pInt->nBlockAlign      = tw;
                tp = pData +  2;
                LoadWORD (tw ,tp);
                pInt->nChannels        = tw;

                // New information in V9
                pInt->wPCMFormatTag = WAVE_FORMAT_PCM;
                tp = pData + 14;
                LoadWORD (tw, tp);
                pInt->wBitsPerSample   = tw;
                pInt->wOriginalBitDepth = pInt->wValidBitsPerSample = pInt->wBitsPerSample;

                tp = pData + 18;
                LoadDWORD(tdw,tp);
                pInt->nSamplesPerBlock = tdw;
                tp = pData + 22;
                LoadWORD (tw ,tp);
                pInt->nEncodeOpt       = tw;

                switch (pInt->nChannels)
                {
                    case 1:
                    {
                        pInt->dwChannelMask = SPEAKER_FRONT_CENTER;
                    }
                    break;

                    case 2:
                    {
                        pInt->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                    }
                    break;

                    case 6:
                    {
                        // Only to support pseudo V3 streams
                        pInt->dwChannelMask = (SPEAKER_FRONT_LEFT   | SPEAKER_FRONT_RIGHT |
                                               SPEAKER_FRONT_CENTER | SPEAKER_BACK_LEFT   |
                                               SPEAKER_BACK_RIGHT   | SPEAKER_LOW_FREQUENCY);
                    }
                    break;

                    default:
                    {
                        // "Can not deal with % channels in this format\n"
                        return WMAERR_FAIL;
                    }
                }
            }
            break;

            case WAVE_FORMAT_MSAUDIO1:
            {
                if(cbTypeSpecific < 22 /*sizeof(MSAUDIO1WAVEFORMAT)*/)
                {
                    return WMAERR_FAIL;
                }

                pInt->nVersion         = 1;
                tp = pData +  4;
                LoadDWORD(tdw,tp);
                pInt->nSamplesPerSec   = tdw;
                tp = pData +  8;
                LoadDWORD(tdw,tp);
                pInt->nAvgBytesPerSec  = tdw;
                tp = pData + 12;
                LoadWORD (tw ,tp);
                pInt->nBlockAlign      = tw;
                tp = pData +  2;
                LoadWORD (tw ,tp);
                pInt->nChannels        = tw;
                tp = pData + 20;
                LoadWORD (tw,tp);
                pInt->nEncodeOpt       = tw;
                tp = pData + 18;
                LoadWORD (tw,tp);
                pInt->nSamplesPerBlock = tw;

                // New information in V9
                pInt->wPCMFormatTag = WAVE_FORMAT_PCM;
                tp = pData + 14;
                LoadWORD (tw, tp);
                pInt->wBitsPerSample   = tw;
                pInt->wOriginalBitDepth = pInt->wValidBitsPerSample = pInt->wBitsPerSample;

                switch (pInt->nChannels)
                {
                    case 1:
                    {
                        pInt->dwChannelMask = SPEAKER_FRONT_CENTER;
                    }
                    break;

                    case 2:
                    {
                        pInt->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                    }
                    break;

                    default:
                    {
                        // "Can not deal with % channels in this format\n"
                        return WMAERR_FAIL;
                    }
                }
            }
            break;

            default:
            {
                // unknown...
                return WMAERR_FAIL;
            }
        }
    }

    /* Error concealment - this can get as big as 400!!! */
    if(cbErrConcealment > 0)
    {
        if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))
        {
            cbWanted = 9; //sizeof(AsfXSignatureAudioErrorMaskingData); Amit it is giving 12 bytes while actual is 9 09/10/2001
        }
        else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))
        {

            cbWanted = 8; //cbWanted = sizeof(AsfXAcmAudioErrorMaskingData);
        }
        else
        {
            return WMAERR_FAIL;
        }

        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbObjectOffset += cbErrConcealment; // Skip over the rest - cbActual;

        if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))
        {
            pInt->cbAudioSize = ((AsfXSignatureAudioErrorMaskingData *)pData)->maxObjectSize;
        }
        else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))
        {
            pScramblingData = (AsfXAcmAudioErrorMaskingData *)pData;

            pInt->cbAudioSize = (unsigned int)(((unsigned short)(*(pData+1))) * ((unsigned short)(*pData)));
            if (pScramblingData->span >1)
            {
                return WMAERR_FAIL;
            }
        }
        else
        {
            return WMAERR_FAIL;
        }
    }

    if (pInt->nBlockAlign > 0)
    {
        nBlocksPerObject = pInt->cbAudioSize/pInt->nBlockAlign;
    }

    pInt->cbAudioSize = nBlocksPerObject*pInt->nSamplesPerBlock*pInt->nChannels*2;

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_LoadVirtualExtendedStreamPropertiesObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize, unsigned int Offset)
{
    unsigned int cbObjectOffset = 0;

    unsigned char   *pData = NULL;
    unsigned int    cbActual =0;
    unsigned int    cbWanted =0;
    unsigned short  wStreamNameCount = 0;
    unsigned short  wPayloadSystemExtensionCount = 0;
    WMAERR rc = WMAERR_OK;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;
    Offset+=MIN_OBJECT_SIZE; // Step over GUID + length field of current object

    // Get to stream name count
    cbObjectOffset = 60;
    cbWanted = 4;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + Offset + cbObjectOffset, cbWanted, (char**)&pData);
    if((cbActual != cbWanted)||(NULL == pData))
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadWORD (wStreamNameCount , pData);
    LoadWORD (wPayloadSystemExtensionCount , pData);

    // Read past the stream names
    if (0 != wStreamNameCount)
    {
        int i;
        int cStreamNames = (int) wStreamNameCount;
        unsigned short wStreamNameLength = 0;

        for (i = 0; i < cStreamNames; i++)
        {
            cbWanted = 2;
            // Dont care for language
            cbObjectOffset += 2;
            if(cbObjectOffset + cbWanted > cbSize)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + Offset + cbObjectOffset, cbWanted, (char**)&pData);

            if((cbActual != cbWanted)||(NULL == pData))
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbObjectOffset += cbActual;
            LoadWORD (wStreamNameLength , pData);
            cbObjectOffset += wStreamNameLength;
        }
    }

    // Read past the payload extension systems
    if (0 != wPayloadSystemExtensionCount)
    {
        int i;
        int cPayloadSystemExtensionCount = (int) wPayloadSystemExtensionCount;
        unsigned int wPayloadSystemLength = 0;

        for (i = 0; i < cPayloadSystemExtensionCount; i++)
        {
            cbWanted = 4;
            // Dont care for GUID etc
            cbObjectOffset += 18;
            if(cbObjectOffset + cbWanted > cbSize)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + Offset + cbObjectOffset, cbWanted, (char**)&pData);

            if((cbActual != cbWanted)||(NULL == pData))
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            cbObjectOffset += cbActual;
            LoadDWORD(wPayloadSystemLength, pData);
            cbObjectOffset += wPayloadSystemLength;
        }
    }

    // Check for existence of Stream Properties at the end of extended stream properties.
    if ((cbObjectOffset + MIN_OBJECT_SIZE) < cbSize)
    {
        GUID  sobjId;
        QWORD sqwSize;

        rc=  AU_CUS_WMA_Parser_LoadVirtualObjectHeader(pInt, &sobjId, &sqwSize, Offset + cbObjectOffset);
        if(rc != WMAERR_OK)
            return rc;

        cbObjectOffset += MIN_OBJECT_SIZE;

        if ( WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV1, &sobjId )
                || WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV2, &sobjId ))
        {
            // Try reading audio property here. Since AU_CUS_WMA_Parser_LoadAudioObject is not virtual, do
            // some work-around here.
            unsigned long long dwSafeCurrPacketOffset = pInt->currPacketOffset;
            pInt->currPacketOffset += Offset + cbObjectOffset;

            if (pInt->currPacketOffset + (sqwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            rc = AU_CUS_WMA_Parser_LoadAudioObject(pInt, sqwSize.dwLo);
            if(rc != WMAERR_OK)
            {
                return rc;
            }

            // restore
            pInt->currPacketOffset = dwSafeCurrPacketOffset;
        }
    }

    return rc;
}

WMAERR AU_CUS_WMA_Parser_LoadClockObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    unsigned int    cbObjectOffset = 0;
    GUID            PacketClockType;
    unsigned short  PacketClockSize;
    unsigned int    dwHeaderExtDataSize = 0;
    unsigned char   *pData = NULL;
    unsigned int    cbActual = 0;
    unsigned int    cbWanted = 0;
    WMAERR          rc = WMAERR_OK;
    unsigned short  wMetaDataObject = 0;
    unsigned short  wExtendedStreamPropertiesObject = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 18;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if((cbActual != cbWanted)||(NULL == pData))
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadGUID (PacketClockType, pData);

    if (WMA_IsEqualGUID( &CLSID_CAsfPacketClock1, &PacketClockType ) ==0)
    {
        pInt->currPacketOffset += cbSize;
        return WMAERR_BUFFERTOOSMALL;
    }

    LoadWORD (PacketClockSize, pData);

    if (PacketClockSize != 6)
    {
        pInt->currPacketOffset += cbSize;
        return WMAERR_BUFFERTOOSMALL;
    }

    cbWanted = 4;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);

    if((cbActual != cbWanted)||(NULL == pData))
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD (dwHeaderExtDataSize, pData);

    if (dwHeaderExtDataSize >= MIN_OBJECT_SIZE )
    {
        // There are more objects. parse them.
        GUID  sobjId;
        QWORD sqwSize;
        while(cbObjectOffset < cbSize)
        {
            rc=  AU_CUS_WMA_Parser_LoadVirtualObjectHeader(pInt, &sobjId, &sqwSize, cbObjectOffset);
            if(rc != WMAERR_OK)
            {
                return rc;
            }

            if( WMA_IsEqualGUID( &CLSID_AsfXMetaDataObject, &sobjId ) )
            {
                wMetaDataObject++;
                if ((cbObjectOffset + sqwSize.dwLo > cbSize)||(wMetaDataObject >1))
                {
                    rc = WMAERR_BUFFERTOOSMALL;
                    goto sabort;
                }
                rc = AU_CUS_WMA_Parser_LoadVirtualMetaDataObject(pInt, sqwSize.dwLo, cbObjectOffset );
                cbObjectOffset += sqwSize.dwLo;
                if (WMAERR_OK != rc)
                {
                    // Note the error, but ignore it and try to continue. It's just metadata.
                    rc = WMAERR_OK;
                }
            }
            else if (WMA_IsEqualGUID( &CLSID_CAsfExtendedStreamPropertiesObject, &sobjId ))
            {
                wExtendedStreamPropertiesObject++;
                if (cbObjectOffset + (sqwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
                {
                    return WMAERR_FAIL;
                }

                rc = AU_CUS_WMA_Parser_LoadVirtualExtendedStreamPropertiesObject(pInt, sqwSize.dwLo,cbObjectOffset);

                cbObjectOffset += sqwSize.dwLo;
                if(rc != WMAERR_OK)
                {
                    return rc;
                }
            }
            else
            {
                /* skip over this object */
                cbObjectOffset += sqwSize.dwLo;
            }
        }
    }

sabort:
    pInt->currPacketOffset += cbSize;
    return rc;
}

WMAERR AU_CUS_WMA_Parser_LoadExtendedContentDescObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    unsigned char   *pData = NULL;
    unsigned int    cbActual = 0;
    unsigned int    cbWanted = 0;
    tWMAExtendedContentDesc *pECDesc = NULL;
    unsigned short     cDescriptors = 0;
    unsigned long long iCurrFileOffset = 0;
    unsigned long long iMaxFileOffset = 0;
    WMAERR             wmaerr = WMAERR_OK;
    unsigned int       i = 0;

    iCurrFileOffset = pInt->currPacketOffset;
    iMaxFileOffset  = iCurrFileOffset + cbSize - MIN_OBJECT_SIZE;

    if (pInt->m_pECDesc)
    {
        goto exit;
    }

    pInt->m_pECDesc = AU_CUS_WMA_Parser_auMalloc(sizeof(tWMAExtendedContentDesc));
    if( pInt->m_pECDesc == NULL)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }
    pECDesc = pInt->m_pECDesc;
    memset(pECDesc, 0, sizeof(tWMAExtendedContentDesc));

    // Get descriptor count
    cbWanted = sizeof(unsigned short);
    if (iCurrFileOffset + cbWanted > iMaxFileOffset)
    {
        wmaerr = (WMAERR_CORRUPTDATA);
        goto exit;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset,  cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        wmaerr = (WMAERR_BUFFERTOOSMALL);
        goto exit;
    }
    iCurrFileOffset += cbActual;
    LoadWORD(cDescriptors, pData);
    pECDesc->cDescriptors = cDescriptors;

    // Allocate array to hold pointers to each descriptor record
    pECDesc->pDescriptors = (ECD_DESCRIPTOR *)AU_CUS_WMA_Parser_auMalloc(cDescriptors * sizeof(ECD_DESCRIPTOR));
    if(pECDesc->pDescriptors == NULL)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }

    memset(pECDesc->pDescriptors, 0, cDescriptors * sizeof(ECD_DESCRIPTOR));

    // Read in each descriptor record
    for (i = 0; i < cDescriptors; i++)
    {
        // Load in descriptor name length
        cbWanted = sizeof(unsigned short);
        if (iCurrFileOffset + cbWanted > iMaxFileOffset)
        {
            wmaerr = (WMAERR_CORRUPTDATA);
            goto exit;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset,  cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            wmaerr = (WMAERR_BUFFERTOOSMALL);
            goto exit;
        }
        iCurrFileOffset += cbActual;
        LoadWORD(pECDesc->pDescriptors[i].cbName, pData);

        // Load in descriptor name
        wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,
                                            iMaxFileOffset, &pECDesc->pDescriptors[i].cbName,
                                            (unsigned char **)&pECDesc->pDescriptors[i].pwszName);
        if (WMAERR_OK != wmaerr)
        {
            goto exit;
        }

        // Load in descriptor value type, and descriptor value length
        cbWanted = 2 * sizeof(unsigned short);
        if (iCurrFileOffset + cbWanted > iMaxFileOffset)
        {
            wmaerr = (WMAERR_CORRUPTDATA);
            goto exit;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset,  cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            wmaerr = (WMAERR_BUFFERTOOSMALL);
            goto exit;
        }
        iCurrFileOffset += cbActual;
        LoadWORD(pECDesc->pDescriptors[i].data_type, pData);
        LoadWORD(pECDesc->pDescriptors[i].cbValue, pData);

        // Load in descriptor value
        if (ECD_STRING == pECDesc->pDescriptors[i].data_type)
        {
            // We will truncate this string if necessary
            wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset, iMaxFileOffset, &pECDesc->pDescriptors[i].cbValue,  (unsigned char**)&pECDesc->pDescriptors[i].uValue.pbBinary);
            if (WMAERR_OK != wmaerr)
            {
                goto exit;
            }
        }
        else //(NOT ECD_STRING)
        {
            unsigned int cbBytesRead;
            const unsigned int cbBytesToRead = pECDesc->pDescriptors[i].cbValue;

            // Do not truncate
            // Check if reading this object takes us past end of object
            if (iCurrFileOffset + pECDesc->pDescriptors[i].cbValue > iMaxFileOffset)
            {
                wmaerr = (WMAERR_CORRUPTDATA);
                goto exit;
            }

            pECDesc->pDescriptors[i].uValue.pbBinary = AU_CUS_WMA_Parser_auMalloc(pECDesc->pDescriptors[i].cbValue);
            if (NULL == pECDesc->pDescriptors[i].uValue.pbBinary)
            {
                wmaerr = (WMAERR_OUTOFMEMORY);
                goto exit;
            }

            for (cbBytesRead = 0; cbBytesRead < cbBytesToRead; )
            {
                cbWanted = MIN(MAX_BUFSIZE, (cbBytesToRead - cbBytesRead));
                cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset + cbBytesRead,  cbWanted, (char**)&pData);
                if (cbActual != cbWanted)
                {
                    wmaerr = (WMAERR_BUFFERTOOSMALL);
                    goto exit;
                }

                memcpy(&pECDesc->pDescriptors[i].uValue.pbBinary[cbBytesRead],
                       pData, cbActual);
                cbBytesRead += cbActual;
            }

            if (cbBytesRead != cbBytesToRead)
            {
                wmaerr = (WMAERR_BUFFERTOOSMALL);
                goto exit;
            }

            iCurrFileOffset += cbBytesRead;
        }
    }

exit:
    // Deal with errors in a "transactional" fashion: either succeed completely,
    // or fail completely. In other words, clean up if we encountered any errors.
    if (WMAERR_OK != wmaerr)
    {
        if (pInt->m_pECDesc)
        {
            pECDesc = pInt->m_pECDesc;
            if (pECDesc->pDescriptors)
            {
                for (i = 0; i < pECDesc->cDescriptors; i++)
                {
                    // It's OK to pass NULL pointers to free
                    AU_CUS_WMA_Parser_auFree(pECDesc->pDescriptors[i].uValue.pbBinary);
                }

                AU_CUS_WMA_Parser_auFree(pECDesc->pDescriptors);
                pECDesc->pDescriptors = NULL;
            }

            AU_CUS_WMA_Parser_auFree(pInt->m_pECDesc);
            pInt->m_pECDesc = NULL;
        }
    }

    // Skip to end of object
    pInt->currPacketOffset = iMaxFileOffset;

    return wmaerr;
}

WMAERR AU_CUS_WMA_Parser_LoadContentDescriptionObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    unsigned char *pData = NULL;
    unsigned long long iCurrFileOffset = 0;
    unsigned long long iMaxFileOffset = 0;
    tWMAFileContDesc *pDesc = NULL;
    WMAERR       wmaerr = WMAERR_OK;
    unsigned int cbActual = 0;
    unsigned int cbWanted = 0;

    iCurrFileOffset = pInt->currPacketOffset;
    iMaxFileOffset  = iCurrFileOffset + cbSize - MIN_OBJECT_SIZE;

    if (NULL != pInt->m_pDesc)
    {
        goto exit;
    }

    pInt->m_pDesc = AU_CUS_WMA_Parser_auMalloc(sizeof(tWMAFileContDesc));
    if (NULL == pInt->m_pDesc)
    {
        wmaerr = (WMAERR_OUTOFMEMORY);
        goto exit;
    }

    pDesc = pInt->m_pDesc;
    memset(pDesc, 0, sizeof(tWMAFileContDesc));

    // Ugly. The programmer of this function assumed that tWMAFileHdrStateInternal *pInt
    // can be cast to (tHWMAFileState *), which is only true because
    // tWMAFileHdrStateInternal hdr_parse is first member in tWMAFileStateInternal.
    // Codify this assumption. Even here I am limited: if there are more than one
    // tWMAFileHdrStateInternal structures in tWMAFileStateInternal, we're lost.

    // Check if reading this next field pushes us past end of object
    cbWanted = 5*sizeof(unsigned short);
    if (iCurrFileOffset + cbWanted > iMaxFileOffset)
    {
        wmaerr = (WMAERR_CORRUPTDATA);
        goto exit;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(iCurrFileOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        wmaerr = (WMAERR_BUFFERTOOSMALL);
        goto exit;
    }
    iCurrFileOffset += cbActual;

    LoadWORD(pDesc->title_len, pData);
    LoadWORD(pDesc->author_len, pData);
    LoadWORD(pDesc->copyright_len, pData);
    LoadWORD(pDesc->description_len, pData);
    LoadWORD(pDesc->rating_len, pData);

    wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,  iMaxFileOffset, &pDesc->title_len, &pDesc->pTitle);
    if (WMAERR_OK != wmaerr)
    {
        goto exit;
    }

    wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,  iMaxFileOffset, &pDesc->author_len, &pDesc->pAuthor);
    if (WMAERR_OK != wmaerr)
    {
        goto exit;
    }


    wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,  iMaxFileOffset, &pDesc->copyright_len, &pDesc->pCopyright);
    if (WMAERR_OK != wmaerr)
    {
        goto exit;
    }

    wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,  iMaxFileOffset, &pDesc->description_len, &pDesc->pDescription);
    if (WMAERR_OK != wmaerr)
    {
        goto exit;
    }


    wmaerr = AU_CUS_WMA_Parser_AllocateAndLoadMetadataStr((tHWMAFileState *)pInt, &iCurrFileOffset,  iMaxFileOffset, &pDesc->rating_len, &pDesc->pRating);
    if (WMAERR_OK != wmaerr)
    {
        goto exit;
    }

    // Confirm that we have consumed the entire object EXACTLY

exit:
    // Deal with errors in a "transactional" fashion: either succeed completely,
    // or fail completely. In other words, clean up if we encountered any errors.
    if (WMAERR_OK != wmaerr)
    {
        if (pInt->m_pDesc)
        {
            pDesc = pInt->m_pDesc;

            // it's OK to pass NULL pointers to free
            AU_CUS_WMA_Parser_auFree(pDesc->pTitle);
            AU_CUS_WMA_Parser_auFree(pDesc->pAuthor);
            AU_CUS_WMA_Parser_auFree(pDesc->pCopyright);
            AU_CUS_WMA_Parser_auFree(pDesc->pDescription);
            AU_CUS_WMA_Parser_auFree(pDesc->pRating);

            AU_CUS_WMA_Parser_auFree(pInt->m_pDesc);
            pInt->m_pDesc = NULL;
        }
    }

    // Advance to end of object
    pInt->currPacketOffset = iMaxFileOffset;

    return wmaerr;
}

WMAERR AU_CUS_WMA_LoadObjectHeader(tWMAFileHdrStateInternal *pInt, GUID *pObjectId, QWORD *pqwSize)
{
    unsigned char *pData   = NULL;
    unsigned int  cbActual = 0;
    unsigned int  cbWanted = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbWanted = MIN_OBJECT_SIZE;
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    pInt->currPacketOffset += cbActual;

    LoadGUID(*pObjectId, pData);
    LoadQWORD(*pqwSize, pData);

    if (pqwSize->dwLo  < MIN_OBJECT_SIZE)
    {
        return WMAERR_INVALIDHEADER;
    }

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_LoadEncryptionObject(tWMAFileHdrStateInternal *pInt, unsigned int cbSize)
{
    unsigned int  cbBlock  = 0;
    unsigned char *pData   = NULL;
    unsigned int  cbActual = 0;
    unsigned int  cbWanted = 0;
    unsigned int  cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    pInt->cbSecretData = 0;

    /* SecretData */

    cbWanted = sizeof(unsigned int);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD(pInt->cbSecretData, pData);

    if (pInt->cbSecretData > 32)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    if(pInt->cbSecretData)
    {
        cbWanted = pInt->cbSecretData;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbObjectOffset += cbActual;

        if (cbActual <= 32)
        {
            memcpy(pInt->pbSecretData, pData, (size_t)cbActual);
        }
        else
        {
            return WMAERR_BUFFERTOOSMALL;
        }
    }

    /* Type string */

    cbWanted = sizeof(unsigned int);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbObjectOffset += cbActual;

        if (cbActual <= 16)
        {
            memcpy(pInt->pbType, pData, (size_t)cbActual);
        }
        else
        {
            return WMAERR_BUFFERTOOSMALL;
        }
    }

    /* Key ID */

    cbWanted = sizeof(unsigned int);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        cbObjectOffset += cbActual;
        if (cbActual <= 32)
        {
            memcpy(pInt->pbKeyID, pData, (size_t)cbActual);
        }
        else
        {
            return WMAERR_BUFFERTOOSMALL;
        }
    }

    /* License URL */

    cbWanted = sizeof(unsigned int);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        while (cbWanted>0)
        {
            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->currPacketOffset + cbObjectOffset, cbWanted, (char**)&pData);

            cbObjectOffset += cbActual;
            cbWanted -= cbActual;

        }

        /* ignore */
    }

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_ParseAsfHeader(tWMAFileHdrStateInternal *pInt)
{
    WMAERR wmarc = 0;
    GUID objId;
    QWORD qwSize;
    unsigned short wHeaderObject = 0;
    unsigned short wPropertiesObject = 0;
    unsigned short wStreamPropertiesObject = 0;
    unsigned short wContentDescriptionObject = 0;
    unsigned short wExtendedContentDescObject = 0;
    unsigned short wLicenceStoreObject = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    /* initialize the some state */

    pInt->currPacketOffset = 0;

    /* ASF Header Object */

    wmarc = AU_CUS_WMA_Parser_LoadHeaderObject(pInt);
    if(wmarc != WMAERR_OK)
    {
        return wmarc;
    }
    wHeaderObject++;
    pInt->cbFirstPacketOffset = pInt->cbHeader += DATA_OBJECT_SIZE;

    /* Scan Header Objects */

    while(pInt->currPacketOffset < pInt->cbFirstPacketOffset- DATA_OBJECT_SIZE)
    {
        wmarc = AU_CUS_WMA_LoadObjectHeader(pInt, &objId, &qwSize);

        if(wmarc != WMAERR_OK)
        {
            return wmarc;
        }

        if(WMA_IsEqualGUID(&CLSID_CAsfPropertiesObjectV2, &objId))
        {
            wPropertiesObject++;
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadPropertiesObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if( WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV1, &objId ) || WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV2, &objId ) )
        {
            wStreamPropertiesObject++;
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadAudioObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfContentEncryptionObject, &objId))
        {
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadEncryptionObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfContentDescriptionObjectV0, &objId))
        {
            wContentDescriptionObject++;
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadContentDescriptionObject(pInt, qwSize.dwLo);
            if (WMAERR_OK != wmarc)
            {
                // Note the error, but ignore it and try to continue. It's just metadata.
                wmarc = WMAERR_OK;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfExtendedContentDescObject, &objId))
        {
            wExtendedContentDescObject++;
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadExtendedContentDescObject(pInt, qwSize.dwLo);
            if (WMAERR_OK != wmarc)
            {
                // Note the error, but ignore it and try to continue. It's just metadata.
                wmarc = WMAERR_OK;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfLicenseStoreObject, &objId))
        {
            wLicenceStoreObject++;
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadLicenseStoreObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfClockObjectV0, &objId))
        {
            if (pInt->currPacketOffset + (qwSize.dwLo - MIN_OBJECT_SIZE) > pInt->cbFirstPacketOffset)
            {
                return WMAERR_FAIL;
            }

            wmarc = AU_CUS_WMA_Parser_LoadClockObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else
        {
            /* skip over this object */
            pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;
        }
    }

    if ((wHeaderObject !=1)||(wPropertiesObject !=1)||(wStreamPropertiesObject <1))
    {
        return WMAERR_FAIL;
    }

    if(pInt->currPacketOffset != (pInt->cbFirstPacketOffset - DATA_OBJECT_SIZE))
    {
        return WMAERR_FAIL;
    }

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_ParsePacketHeader(tWMAFileStateInternal *pInt)
{
    unsigned char b = 0;
    PACKET_PARSE_INFO_EX *pParseInfoEx = NULL;
    unsigned char *pData  = NULL;
    unsigned int cbActual = 0;
    unsigned int cbWanted = 0;
    unsigned int cbLocalOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    pParseInfoEx = &pInt->ppex;

    //cbWanted = 24;           /* at most  */
    cbWanted = 1;              /* at least */

    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset,  cbWanted, (char**)&pData);

    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    /* ParsePacket begins */
    pParseInfoEx->fParityPacket = FALSE;
    pParseInfoEx->cbParseOffset = 0;

    b = pData[cbLocalOffset];

    pParseInfoEx->fEccPresent = (int)( (b&0x80) == 0x80 );
    pParseInfoEx->bECLen = 0;

    if(pParseInfoEx->fEccPresent)
    {
        if(b&0x10)
        {
            pParseInfoEx->fParityPacket = TRUE;
            return WMAERR_OK;
        }

        if(b&0x60)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bECLen = (b&0x0f);
        if(pParseInfoEx->bECLen != 2)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->cbParseOffset = (unsigned int)(1 + pParseInfoEx->bECLen);

        cbWanted = 1; /* at least */
        cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,  cbWanted, (char**)&pData);

        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;

        }

        b = pData[cbLocalOffset];
    }

    pParseInfoEx->cbPacketLenTypeOffset = pParseInfoEx->cbParseOffset;

    pParseInfoEx->bPacketLenType   = (b&0x60)>>5;
    pParseInfoEx->bPadLenType      = (b&0x18)>>3;
    pParseInfoEx->bSequenceLenType = (b&0x06)>>1;
    pParseInfoEx->fMultiPayloads   = (int)(b&0x01);
    pParseInfoEx->cbParseOffset++;

    cbWanted = 1; /* at least */
    cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,  cbWanted, (char**)&pData);

    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    b = pData[cbLocalOffset];

    pParseInfoEx->bOffsetBytes = 4;
    pParseInfoEx->bOffsetLenType = 3;

    if(b != 0x5d)
    {
        if((b&0xc0) != 0x40)
        {
            return WMAERR_FAIL;
        }

        if((b&0x30) != 0x10)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bOffsetLenType = (b&0x0c)>>2;
        if(pParseInfoEx->bOffsetLenType == 0)
        {
            return WMAERR_FAIL;
        }
        else if(pParseInfoEx->bOffsetLenType < 3)
        {
            pParseInfoEx->bOffsetBytes = pParseInfoEx->bOffsetLenType;
        }

        if((b&0x03) != 0x01)
        {
            return WMAERR_FAIL;
        }
    }

    pParseInfoEx->cbParseOffset++;
    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bPacketLenType)
    {
        case 0x01:
        {
            cbWanted =1;
            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,  cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            pParseInfoEx->cbExplicitPacketLength = (unsigned int)(*pData);
            pParseInfoEx->cbParseOffset++;
        }
        break;

        case 0x02:
        {
            unsigned short w=0;
            cbWanted =2;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            GetUnalignedWord(pData, w);
            pParseInfoEx->cbExplicitPacketLength = (unsigned int)(w);
            pParseInfoEx->cbParseOffset+=2;
        }
        break;

        case 0x03:
        {
            unsigned int dw=0;
            cbWanted =4;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbExplicitPacketLength = dw;
            pParseInfoEx->cbParseOffset+=4;

        }
        break;

        default:
        {
            cbWanted =0;
            pParseInfoEx->cbExplicitPacketLength = 0;
        }
        break;
    }

    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bSequenceLenType)
    {
        case 0x01:
        {
            cbWanted =1;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            pParseInfoEx->dwSequenceNum =  (unsigned int)(*pData);
            pParseInfoEx->cbParseOffset++;
        }
        break;

        case 0x02:
        {
            unsigned short w = 0;
            cbWanted =2;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->dwSequenceNum =  (unsigned int)(w);
            pParseInfoEx->cbParseOffset += 2;
        }
        break;

        case 0x03:
        {
            unsigned int dw = 0;
            cbWanted =4;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->dwSequenceNum =  dw;
            pParseInfoEx->cbParseOffset += 4;
        }
        break;

        default:
        {
            cbWanted =0;
            pParseInfoEx->dwSequenceNum = 0;
        }
        break;
    }

    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bPadLenType)
    {
        case 0x01:
        {
            cbWanted =1;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            pParseInfoEx->cbPadding =  (unsigned int)(*pData);
            pParseInfoEx->cbParseOffset++;
        }
        break;

        case 0x02:
        {
            unsigned short w=0;
            cbWanted =2;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbPadding     =  (unsigned int)(w);
            pParseInfoEx->cbParseOffset += 2;
        }
        break;

        case 0x03:
        {
            unsigned int dw=0;
            cbWanted =4;
            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbPadding     =  dw;
            pParseInfoEx->cbParseOffset += 4;
        }
        break;

        default:
        {
            cbWanted =0;
            pParseInfoEx->cbPadding = 0;
        }
        break;
    }

    // Now read 6 bytes
    cbWanted =6;
    cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    GetUnalignedDword(&pData[cbLocalOffset], pParseInfoEx->dwSCR);
    pParseInfoEx->cbParseOffset += 4;
    GetUnalignedWord(&pData[cbLocalOffset+4], pParseInfoEx->wDuration);
    pParseInfoEx->cbParseOffset += 2;

    /* ParsePacketEx begins */

    pParseInfoEx->cbPayLenTypeOffset = 0;
    pParseInfoEx->bPayLenType = 0;
    pParseInfoEx->bPayBytes = 0;
    pParseInfoEx->cPayloads = 1;

    if(pParseInfoEx->fMultiPayloads)
    {
        cbWanted =1;
        cbActual = AU_CUS_WMA_Parser_WMAGetData(  pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,  cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

        b = pData[cbLocalOffset];

        pParseInfoEx->cbPayLenTypeOffset = pParseInfoEx->cbParseOffset;

        pParseInfoEx->bPayLenType = (b&0xc0)>>6;
        if(pParseInfoEx->bPayLenType != 2 && pParseInfoEx->bPayLenType != 1)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bPayBytes = pParseInfoEx->bPayLenType;

        pParseInfoEx->cPayloads = (unsigned int)(b&0x3f);
        if(pParseInfoEx->cPayloads == 0)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->cbParseOffset++;
    }

    return WMAERR_OK;
}

WMAERR AU_CUS_WMA_Parser_ParsePayloadHeader(tWMAFileStateInternal *pInt)
{
    unsigned int cbParseOffset   = 0;
    unsigned int cbRepDataOffset = 0;
    unsigned int dwPayloadSize   = 0;
    PACKET_PARSE_INFO_EX *pParseInfoEx = NULL;
    PAYLOAD_MAP_ENTRY_EX *pPayload = NULL;
    unsigned int cbLocalOffset   = 0;

    unsigned char  *pData   = NULL;
    unsigned int   cbActual = 0;
    unsigned int   cbWanted = 0;
    unsigned short wTotalDataBytes = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    pParseInfoEx = &pInt->ppex;
    pPayload = &pInt->payload;

    cbWanted = 2; /* at least */
    cbActual = AU_CUS_WMA_Parser_WMAGetData(  pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,  cbWanted, (char**)&pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbParseOffset = 0;

    /* Loop in ParsePacketAndPayloads */

    pPayload->cbPacketOffset = (unsigned short)pParseInfoEx->cbParseOffset;
    pPayload->bStreamId = (pData[cbParseOffset])&0x7f; // Amit to get correct Streamid
    pPayload->bObjectId = pData[cbParseOffset + 1];

    switch(pParseInfoEx->bOffsetLenType)
    {
        case 0x01:
        {
            cbWanted =1;
            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,  cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            pPayload->cbObjectOffset =  (unsigned int)(*pData);
        }
        break;

        case 0x02:
        {
            unsigned short w=0;
            cbWanted =2;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedWord(pData, w);
            pPayload->cbObjectOffset =  (unsigned int)(w);
        }
        break;

        case 0x03:
        {
            unsigned int dw=0;
            cbWanted =4;
            cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,  cbWanted, (char**)&pData);
            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }
            GetUnalignedDword(pData, dw);
            pPayload->cbObjectOffset =  dw;
        }
        break;

        default:
        {
            cbWanted =0;
        }
        break;
    }

    cbRepDataOffset = cbParseOffset + 2 + pParseInfoEx->bOffsetBytes;

    cbWanted = 1;
    cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset, cbWanted, (char**)&pData);

    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    pPayload->cbRepData = pData[cbLocalOffset];

    pPayload->msObjectPres = 0xffffffff;

    if(pPayload->cbRepData == 1)
    {
        pPayload->msObjectPres = pPayload->cbObjectOffset;
        pPayload->cbObjectOffset = 0;
        pPayload->cbObjectSize = 0;
        pPayload->bIsCompressedPayload = 1;

        cbWanted =1;
        cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1,  cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        pPayload->dwDeltaTime = pData[0];

        if( pParseInfoEx->fMultiPayloads)
        {
            cbWanted =2;
            cbActual = AU_CUS_WMA_Parser_WMAGetData(pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +2, cbWanted, (char**)&pData);

            if(cbActual != cbWanted)
            {
                return WMAERR_BUFFERTOOSMALL;
            }

            GetUnalignedWord( &pData[cbLocalOffset],wTotalDataBytes );
        }
        else
        {
            wTotalDataBytes = 0;
        }
    }
    else if(pPayload->cbRepData >= 8)
    {
        cbWanted =8;
        cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1, cbWanted, (char**)&pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        GetUnalignedDword(&pData[cbLocalOffset],  pPayload->cbObjectSize);
        GetUnalignedDword(&pData[cbLocalOffset+ 4], pPayload->msObjectPres);

        pPayload->bIsCompressedPayload =0;
    }

    pPayload->cbTotalSize = 1 + 1 + pParseInfoEx->bOffsetBytes + 1 + pPayload->cbRepData;

    if(pParseInfoEx->fMultiPayloads)
    {
        switch(pParseInfoEx->bPayLenType)
        {
            case 0x01:
            {
                cbWanted =1;
                cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +pPayload->cbTotalSize, cbWanted, (char**)&pData);
                if(cbActual != cbWanted)
                {
                    return WMAERR_BUFFERTOOSMALL;
                }
                dwPayloadSize =  (unsigned int)(*pData);
            }
            break;

            case 0x02:
            {
                unsigned short w = 0;
                cbWanted = 2;
                cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+pPayload->cbTotalSize, cbWanted, (char**)&pData);
                if(cbActual != cbWanted)
                {
                    return WMAERR_BUFFERTOOSMALL;
                }
                GetUnalignedWord(pData, w);
                dwPayloadSize =  (unsigned int)(w);
            }
            break;

            case 0x03:
            {
                unsigned int dw = 0;
                cbWanted = 4;
                cbActual = AU_CUS_WMA_Parser_WMAGetData( pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, (char**)&pData);
                if(cbActual != cbWanted)
                {
                    return WMAERR_BUFFERTOOSMALL;
                }
                GetUnalignedDword(pData, dw);
                dwPayloadSize =  dw;
            }
            break;

            default:
            {
                cbWanted = 0;
                dwPayloadSize = 0;
            }
            break;
        }
    }
    else if(pParseInfoEx->cbExplicitPacketLength > 0)
    {
        dwPayloadSize = pParseInfoEx->cbExplicitPacketLength
                        - pParseInfoEx->cbParseOffset
                        - pPayload->cbTotalSize
                        - pParseInfoEx->cbPadding;
    }
    else
    {
        dwPayloadSize = pInt->hdr_parse.cbPacketSize - pParseInfoEx->cbParseOffset - pPayload->cbTotalSize - pParseInfoEx->cbPadding;
    }

    if (0 == wTotalDataBytes)
    {
        wTotalDataBytes = (unsigned short) dwPayloadSize;
    }

    pPayload->cbPayloadSize = (unsigned short)dwPayloadSize;

    pPayload->cbTotalSize += pParseInfoEx->bPayBytes + (unsigned short)pPayload->cbPayloadSize;

    pPayload->wTotalDataBytes = wTotalDataBytes; // Amit

    pParseInfoEx->cbParseOffset += pPayload->cbTotalSize;

    if(pParseInfoEx->cbParseOffset > pInt->hdr_parse.cbPacketSize || (pParseInfoEx->cbParseOffset == pInt->hdr_parse.cbPacketSize && pInt->iPayload < pParseInfoEx->cPayloads - 1))
    {
        return WMAERR_CORRUPTDATA;
    }

    return WMAERR_OK;
}

tWMAFileStatus AU_CUS_WMA_Parser_UpdateNewPayload (tWMAFileStateInternal *pInt)
{
    /* internal call, so pInt should be okay */

    /* HongCho: separated out these parts from the parsing loop, because
     *          other parts (when a new payload is about to be retrieved)
     *          need to update the offsets and other states.
     *
     *          used in WMAFileDecodeData() and WMARawDecCBGetData ().
     */
    int pkt_idx = 0;
    WMAERR wmarc;

    do
    {
        switch (pInt->parse_state)
        {
            case csWMA_NewAsfPacket:
            {
                if(pInt->hdr_parse.bMstarHeader == 0)   // need to parse packet header or payload header only if not Mstar header mode
                {
                    if (pInt->hdr_parse.nextPacketOffset > pInt->hdr_parse.cbLastPacketOffset)
                    {
                        return cWMA_NoMoreFrames;
                    }
                    pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.nextPacketOffset;
                    pInt->hdr_parse.nextPacketOffset += pInt->hdr_parse.cbPacketSize;

                    wmarc = AU_CUS_WMA_Parser_ParsePacketHeader (pInt);
                    pkt_idx++;

                    if (wmarc == WMAERR_BUFFERTOOSMALL)
                    {
                        pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.currPacketOffset;
                        //  pInt->hdr_parse.currPacketOffset -= pInt->hdr_parse.cbPacketSize;
                        return cWMA_NoMoreDataThisTime;
                    }

                    if(wmarc != WMAERR_OK)
                    {
                        return cWMA_BadPacketHeader;
                    }

                    if (pInt->ppex.fEccPresent && pInt->ppex.fParityPacket)
                    {
                        /* HongCho: for some reason, ARM's code thinks a parity packet is
                         *          only at the end...  Here, I am not assuming that.
                         */
                        break;
                    }
                    pInt->iPayload = 0;     // indicate number of payload processed in this packet
                    pInt->parse_state = csWMA_DecodePayloadStart;
                }
                else
                {
                    pInt->iPayload = 0;     // indicate number of payload processed in this packet
                    pInt->parse_state = csWMA_DecodePayloadStart;
                    pInt->ppex.cPayloads = 1;
                }
            }
            break;

            case csWMA_DecodePayloadStart:
            {
                if(pInt->hdr_parse.bMstarHeader == 0)
                {
                    if (pInt->iPayload >= pInt->ppex.cPayloads)     // ppex.cPayloads:   information in packet header to indicate total number of payloads in this packet
                    {
                        // decode enough number of payloads in this packet --> start next packet
                        pInt->parse_state = csWMA_NewAsfPacket;
                        break;
                    }

                    wmarc = AU_CUS_WMA_Parser_ParsePayloadHeader(pInt);
                    if(wmarc != WMAERR_OK)
                    {
                        pInt->parse_state = csWMA_DecodePayloadEnd;
                        break;
                    }
                    pInt->wPayStart = pInt->payload.cbPacketOffset + pInt->payload.cbTotalSize - pInt->payload.cbPayloadSize;

                    if( pInt->payload.cbRepData != 1 )
                    {
                        pInt->parse_state = csWMA_DecodePayload;
                        pInt->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
                        break;
                    }
                    else if(pInt->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
                    {
                        pInt->parse_state = csWMA_DecodeCompressedPayload;
                        pInt->payload.bIsCompressedPayload =1;
                        break;
                    }
                    /* a payload has to be a multiple of audio "packets" */

                    if(pInt->payload.cbPayloadSize%pInt->hdr_parse.nBlockAlign != 0)
                    {
                        return cWMA_BrokenFrame;
                    }
                    pInt->parse_state = csWMA_DecodePayloadEnd;
                }
                else
                {
                    pInt->payload.cbRepData = 0;

                    if( pInt->payload.cbRepData != 1 )
                    {
                        pInt->parse_state = csWMA_DecodePayload;
                        pInt->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
                        break;
                    }
                    else if(pInt->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
                    {
                        pInt->parse_state = csWMA_DecodeCompressedPayload;
                        pInt->payload.bIsCompressedPayload =1;
                        break;
                    }
                }
            }
            break;

            case csWMA_DecodePayload:
            {
                if(pInt->hdr_parse.bMstarHeader == 0)   // need to parse packet header or payload header only if not Mstar header mode
                {
                    if (pInt->payload.bStreamId != pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload
                    {
                        pInt->parse_state = csWMA_DecodePayloadEnd;
                        break;
                    }

                    // pInt->wPayStart = pInt->payload.cbPacketOffset + pInt->payload.cbTotalSize - pInt->payload.cbPayloadSize;
                    pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;
                    pInt->bBlockStart     = TRUE;
                    pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;
                    pInt->cbPayloadLeft   = pInt->payload.cbPayloadSize - pInt->cbBlockLeft;

                    /* new payload, so take care of DRM */

                    pInt->parse_state = csWMA_DecodeAudioData;
                }
                else // mstar header
                {
                    // !!!! note:   need to check this offset
                    pInt->cbPayloadOffset = pInt->hdr_parse.u64CurPayloadOffset;
                    pInt->bBlockStart     = TRUE;
                    pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;
                    pInt->payload.cbPayloadSize = pInt->hdr_parse.payload_size;
                    pInt->cbPayloadLeft   = pInt->payload.cbPayloadSize - pInt->cbBlockLeft;

                    pInt->parse_state = csWMA_DecodeAudioData;
                }
                return cWMA_NoErr;
            }
            break;

            case csWMA_DecodePayloadEnd:
            {
                pInt->iPayload++;
                pInt->parse_state = csWMA_DecodePayloadStart;
            }
            break;

            case csWMA_DecodeCompressedPayload: // Added by Amit to take care of compressed payloads
            {
                if (pInt->payload.bStreamId != pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload
                {
                    pInt->parse_state = csWMA_DecodePayloadEnd;
                    break;
                }

                // pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;      // update in main, after parsing Mstar header
                pInt->bBlockStart        = TRUE;
                // pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;                             // update in main, after parsing Mstar header
                pInt->payload.wBytesRead = 0;
                pInt->payload.bSubPayloadState = 1;
                pInt->parse_state = csWMA_DecodeAudioData;

                return cWMA_NoErr;
            }
            break;

            default:
            {
                return cWMA_Internal;
            }
            break;
        }
    }
    while(1);

    return cWMA_NoErr;
}

int AU_CUS_WMA_Parser_ParseInputFile(const char *pFileName, int input_file_length)
{
    int     ret_file_length = 0;
    WMAERR  wmarc = 0;
    FILE    *g_intermediateFile = NULL;
    tWMAFileStateInternal *pWmaFileStateInternal;
    MS_U32  *pU32Tmp;
    MS_U8   u8ASFPayloadHeader[16];

    g_wmaInput_fp                   = pAU_debug_input_file;
    sDecodeFifo_Info.u32Level       = 0;
    sDecodeFifo_Info.pStartAddr     = WMAPRO_DecodeFifo;
    sDecodeFifo_Info.u32Size        = WMAPRO_DECODE_FIFO_SIZE;
    sDecodeFifo_Info.pWptr          = sDecodeFifo_Info.pStartAddr;
    sDecodeFifo_Info.pRptr          = sDecodeFifo_Info.pStartAddr;
    sDecodeFifo_Info.consumed_bytes = 0;
    sDecodeFifo_Info.pEndAddr       = sDecodeFifo_Info.pStartAddr + sDecodeFifo_Info.u32Size;
    memset(sDecodeFifo_Info.pStartAddr, 0, sDecodeFifo_Info.u32Size);

    u64FileOffset    = 0;
    u64offset_expect = 0;

    memset(&sWmaHandle, 0, sizeof(tWMAFileStateInternal));
    sWmaHandle.hdr_parse.wTargetAudioStreamNumber = 1;
    wmarc = AU_CUS_WMA_Parser_ParseAsfHeader(&(sWmaHandle.hdr_parse));
    if (wmarc != WMAERR_OK)
    {
        printf("AU_CUS_WMA_Parser_ParseAsfHeader error\n");
        return FALSE;
    }
    printf("wma_hdr_parse.cbPacketSize : %x\n", (sWmaHandle.hdr_parse).cbPacketSize);
    printf("wma_hdr_parse.nBlockAlign  : %x\n", (sWmaHandle.hdr_parse).nBlockAlign);
    printf("nVersion        : %d\n", (sWmaHandle.hdr_parse).nVersion);
    printf("nSamplesPerSec  : %d\n", (sWmaHandle.hdr_parse).nSamplesPerSec);
    printf("nAvgBytesPerSec : %d\n", (sWmaHandle.hdr_parse).nAvgBytesPerSec);
    printf("nBlockAlign     : %d\n", (sWmaHandle.hdr_parse).nBlockAlign);
    printf("nChannels       : %d\n", (sWmaHandle.hdr_parse).nChannels);
    printf("wBitsPerSample  : %d\n", (sWmaHandle.hdr_parse).wBitsPerSample);
    printf("dwChannelMask   : %d\n", (sWmaHandle.hdr_parse).dwChannelMask);
    printf("nEncodeOpt      : %d\n", (sWmaHandle.hdr_parse).nEncodeOpt);

    pWmaFileStateInternal = &sWmaHandle;
    u8ASFPayloadHeader[0] = 0x02;
    u8ASFPayloadHeader[1] = 0x80;
    u8ASFPayloadHeader[2] = 0xFD;
    u8ASFPayloadHeader[3] = 0x7F;
    pU32Tmp = (MS_U32 *)(&(u8ASFPayloadHeader[4]));
    *pU32Tmp = pWmaFileStateInternal->hdr_parse.nBlockAlign;
    memset(&u8ASFPayloadHeader[8], 0, 8);

    pWmaFileStateInternal->hdr_parse.cbLastPacketOffset = pWmaFileStateInternal->hdr_parse.cbFirstPacketOffset;
    if (pWmaFileStateInternal->hdr_parse.cPackets > 0)
    {
        pWmaFileStateInternal->hdr_parse.cbLastPacketOffset += ((unsigned long long)pWmaFileStateInternal->hdr_parse.cPackets - 1)*pWmaFileStateInternal->hdr_parse.cbPacketSize;
    }

    // If broadcast flag is set, packet count is invalid. Override cbLastPacketOffset
    if (FILEPROPFLAG_BROADCAST & pWmaFileStateInternal->hdr_parse.dwFilePropertiesFlags)
    {
        // Set last packet offset to MAX - 1 packet. This prevents us from wrapping around.
        pWmaFileStateInternal->hdr_parse.cbLastPacketOffset = -1; // By -1 we mean MAX UNSIGNED VALUE
        pWmaFileStateInternal->hdr_parse.cbLastPacketOffset -= pWmaFileStateInternal->hdr_parse.cbPacketSize;
    }

    pWmaFileStateInternal->hdr_parse.currPacketOffset = pWmaFileStateInternal->hdr_parse.cbHeader;
    pWmaFileStateInternal->hdr_parse.nextPacketOffset = pWmaFileStateInternal->hdr_parse.cbHeader;

    pWmaFileStateInternal->parse_state = csWMA_NewAsfPacket;

    char intermediateFileName[AU_DEBUG_INPUT_STR_LENGTH+1] = {'\0'};

    // open intermediate es dump file.
    strcpy( intermediateFileName, pFileName);
    intermediateFileName[strlen(intermediateFileName)-4] = NULL;
    strcat( intermediateFileName, ".es");

    g_intermediateFile = fopen(intermediateFileName, "wb");
    if (g_intermediateFile == NULL)
    {
        printf("Open wma intermediate es dump file for writing FAIL %s\n", intermediateFileName);
        fclose(pAU_debug_input_file);
        return FALSE;
    }

    printf("original File Path    (%s) \n", pFileName);
    printf("intermediateFileName  (%s) \n", intermediateFileName);

    while (1)
    {
        unsigned char *pData = NULL;
        tWMAFileStatus rc1 = cWMA_NoErr;

        WMA_DBG_PRINT(printf("FIFO original level (0x%x) \n", (unsigned int)sDecodeFifo_Info.u32Level));
        AU_CUS_WMA_Parser_DecodeFifoFeed();
        WMA_DBG_PRINT(printf("FIFO new level (0x%x) \n", (unsigned int)sDecodeFifo_Info.u32Level));
        if (sDecodeFifo_Info.u32Level < MaxRequestSize)
        {
            WMA_DBG_PRINT(printf("=== decode FIFO empty === \n"));
            goto wma_es_data_dump_to_intermediate_file_finish;
        }
        rc1 = AU_CUS_WMA_Parser_UpdateNewPayload(pWmaFileStateInternal);
        if (rc1 == cWMA_NoMoreDataThisTime)
        {
            WMA_DBG_PRINT(printf("AU_CUS_WMA_Parser_UpdateNewPayload return cWMA_NoMoreDataThisTime \n"));
            goto wma_es_data_dump_to_intermediate_file_finish;
        }
        WMA_DBG_PRINT(printf("currPacketOffset: %x\n", pWmaFileStateInternal->hdr_parse.currPacketOffset));
        WMA_DBG_PRINT(printf("wPayStart       : %x\n", pWmaFileStateInternal->wPayStart));

        AU_CUS_WMA_Parser_WMAGetData(pWmaFileStateInternal->hdr_parse.currPacketOffset+pWmaFileStateInternal->wPayStart, pWmaFileStateInternal->hdr_parse.nBlockAlign, (char**)&pData);

        AU_CUS_FileWrite(u8ASFPayloadHeader, 1, 16, g_intermediateFile);
        AU_CUS_FileWrite(pData, 1, pWmaFileStateInternal->hdr_parse.nBlockAlign, g_intermediateFile);
        fflush(g_intermediateFile);

        WMA_DBG_PRINT(printf("pWmaFileStateInternal->hdr_parse.currPacketOffset+pWmaFileStateInternal->wPayStart+pWmaFileStateInternal->hdr_parse.nBlockAlign: %x \n", pWmaFileStateInternal->hdr_parse.currPacketOffset+pWmaFileStateInternal->wPayStart+pWmaFileStateInternal->hdr_parse.nBlockAlign));
        if ((pWmaFileStateInternal->hdr_parse.currPacketOffset+pWmaFileStateInternal->wPayStart+pWmaFileStateInternal->hdr_parse.nBlockAlign) >= input_file_length)
        {
            goto wma_es_data_dump_to_intermediate_file_finish;
        }
        pWmaFileStateInternal->hdr_parse.currPacketOffset += (pWmaFileStateInternal->wPayStart+pWmaFileStateInternal->hdr_parse.nBlockAlign);
        pWmaFileStateInternal->parse_state = csWMA_DecodePayloadEnd;
    }

wma_es_data_dump_to_intermediate_file_finish:
    fflush(g_intermediateFile);
    fclose(g_intermediateFile);
    fclose(pAU_debug_input_file);
    pAU_debug_input_file = NULL;
    pAU_debug_input_file = fopen(intermediateFileName, "rb");
    if (pAU_debug_input_file == NULL)
    {
        printf("Open wma intermediate es dump file for reading FAIL %s\n", intermediateFileName);
        return FALSE;
    }

    if (fseek(pAU_debug_input_file, 0, SEEK_END))
    {
        //File seek error.
        return FALSE;
    }

    ret_file_length = ftell(pAU_debug_input_file);  //move ptr to begin of file:  rewind(fp);
    printf("Wma intermediate es dump file length %d\n", ret_file_length);
    rewind(pAU_debug_input_file);

    MS_U32 Param = 0;
    void *pParam = &Param;

    Param = 1;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_PARSINGBYAPP   , pParam);

    Param = (sWmaHandle.hdr_parse).nSamplesPerSec;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_SAMPLERATE     , pParam);

    Param = (sWmaHandle.hdr_parse).nVersion;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_VERSION        , pParam);

    Param = (sWmaHandle.hdr_parse).nChannels;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_CHANNELS       , pParam);

    Param = (sWmaHandle.hdr_parse).nAvgBytesPerSec;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BYTERATE       , pParam);

    Param = (sWmaHandle.hdr_parse).nEncodeOpt;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_ENCOPT         , pParam);

    Param = (sWmaHandle.hdr_parse).wBitsPerSample;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BITS_PER_SAMPLE, pParam);

    Param = (sWmaHandle.hdr_parse).dwChannelMask;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_CHANNELMASK    , pParam);

    Param = (sWmaHandle.hdr_parse).nBlockAlign;
    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_WMA_BLOCKALIGN     , pParam);

    return ret_file_length;
}
#endif //#if(WMA_AUDIO_PARSER_ENABLE)

#if(XPCM_AUDIO_PARSER_ENABLE)
void AU_CUS_XPCM_Parser_ParseInputFile(void)
{
    int tmp_readin_buf[50];
    int total_dec_size = 0;

    MS_U32 WrtBytes = 0;

    API_AUDIO_CUSTOMER_XPCM_PARAM xpcm_param;
    unsigned char *p_fmt_chunk;
    MS_U16 audioType;
    int sizeformatex, factchunksize;

    AU_UNUSED(WrtBytes);

    memset(&xpcm_param, 0, sizeof(xpcm_param));

    WrtBytes = fread(tmp_readin_buf, 1, 12, pAU_debug_input_file); // get 12 bytes RIFF chunk -> 4 bytes: "RIFF"+ 4 bytes for RIFF chunk size  + 4 bytes: "WAVE".
    WrtBytes = fread(tmp_readin_buf, 1, 4,  pAU_debug_input_file); // get 4  bytes for fmt chunk identifier: "fmt ".
    WrtBytes = fread(&sizeformatex,  1, 4,  pAU_debug_input_file); // get 4  bytes for fmt chunk size: formatex.
    printf("sizeformatex: %d\n", sizeformatex);
    WrtBytes = fread(tmp_readin_buf, 1, sizeformatex, pAU_debug_input_file); // get sizeformatex bytes.

    p_fmt_chunk = (unsigned char *)tmp_readin_buf;
    memcpy(&audioType, p_fmt_chunk, 2);

    switch(audioType)
    {
        case API_AUDIO_CUSTOMER_XPCM_LPCM:
        {
            printf("IMA_ADPCM.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_LPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_MS_ADPCM:
        {
            printf("LPCM.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_MS_ADPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_G711_A_LAW:
        {
            printf("MS_ADPCM.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_G711_A_LAW;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_G711_u_LAW:
        {
            printf("G711_A_LAW.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_G711_u_LAW;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_DVD_LPCM:
        {
            printf("G711_u_LAW.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_DVD_LPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_PRIVATE1_LPCM:
        {
            printf("MS_ADPCM.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_PRIVATE1_LPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_IMA_ADPCM:
        {
            printf("G711_A_LAW.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_IMA_ADPCM;
        }
        break;

        case API_AUDIO_CUSTOMER_XPCM_IMA_ADPCM_APPLE:
        {
            printf("G711_u_LAW.\n");
            xpcm_param.audioType = API_AUDIO_CUSTOMER_XPCM_IMA_ADPCM_APPLE;
        }
        break;

        default:
            break;
    }

    //set channel num
    memcpy(&xpcm_param.channels, p_fmt_chunk + 2, 2);
    xpcm_param.channels = xpcm_param.channels - 1;

    //set sampling rate
    memcpy(&xpcm_param.sampleRate, p_fmt_chunk + 4, 4);

    //set bit per sample
    memcpy(&xpcm_param.bitsPerSample, p_fmt_chunk + 14, 2);

    //set block size
    memcpy(&xpcm_param.blockSize, p_fmt_chunk + 12, 2);

    WrtBytes = fread(tmp_readin_buf, 1, 4, pAU_debug_input_file);      // get 4 bytes for next chunk's identifier.
    if (0 == memcmp(tmp_readin_buf , "fact", 4))                       // if get fact chunk identifier "fact".
    {
        WrtBytes = fread(&factchunksize,  1, 4, pAU_debug_input_file);
        printf("factchunksize   : %d\n", factchunksize);
        WrtBytes = fread(&total_dec_size, 1, 4, pAU_debug_input_file);
        WrtBytes = fread(tmp_readin_buf,  1, 4, pAU_debug_input_file); // get 4 bytes for next chunk's identifier: expect "data"
    }
    WrtBytes = fread(&total_dec_size, 1, 4, pAU_debug_input_file);
    printf("total_dec_size  : %d\n", total_dec_size);

    // calculate samplePerBlock which is necessary for MS ADPCM.
    xpcm_param.samplePerBlock = (((xpcm_param.blockSize - (7 * (xpcm_param.channels+1))) * 8) / (xpcm_param.bitsPerSample * (xpcm_param.channels+1))) + 2;
    printf("audio type      : %d \n", xpcm_param.audioType);
    printf("channels        : %d \n", xpcm_param.channels);
    printf("sampling rate   : %d \n", (int)xpcm_param.sampleRate);
    printf("bitsPerSample   : %d \n", xpcm_param.bitsPerSample);
    printf("blockSize       : %d \n", xpcm_param.blockSize);
    printf("samplePerBlock  : %d \n", xpcm_param.samplePerBlock);

    API_AUDIO_CUSTOMER_XPCM_PARAM Param;
    memset(&Param, 0, sizeof(Param));

    void *pParam = &Param;
    Param.audioType      = xpcm_param.audioType;
    Param.sampleRate     = xpcm_param.sampleRate;
    Param.blockSize      = xpcm_param.blockSize;
    Param.samplePerBlock = xpcm_param.samplePerBlock;
    Param.channels       = xpcm_param.channels;
    Param.bitsPerSample  = xpcm_param.bitsPerSample;
    #if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
    Param.dwchannelMask  = xpcm_param.dwchannelMask;
    #endif //#if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)

    API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_XPCM, pParam);
}
#endif //#if(XPCM_AUDIO_PARSER_ENABLE)

void AU_CUS_AQ_Tuning_MSTAR_SE_Enable(void)
{
    int arg2, arg3;

    AU_nPRINT("MSTAR_SE_TYPE:\n");
    AU_nPRINT("API_AUDIO_CUSTOMER_GEQ     = 0 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_PEQ     = 1 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_HPF     = 2 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DRC     = 3 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_AVC     = 4 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_BALANCE = 5 \n");

    arg2 = AU_CUS_Debug_GetDec();

    AU_nPRINT("Enable  =1\n");
    AU_nPRINT("Disable =0\n");
    arg3 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_TYPE seType = (API_AUDIO_CUSTOMER_MSTAR_SE_TYPE)arg2;
    MS_BOOL bOnOff = (MS_BOOL)arg3;
    API_AUDIO_CUSTOMER_MSTAR_SE_Enable(seType, bOnOff);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_GEQ(void)
{
    int arg2, arg3;

    AU_nPRINT("MStar GEQ:            \n");
    AU_nPRINT("select GEQ band = 0~4 \n");
    arg2 = AU_CUS_Debug_GetDec();

    AU_nPRINT("set GEQ band level = -48 ~ 48(-12dB ~ 12dB, step 0.25dB) \n");
    arg3 = AU_CUS_Debug_GetDec();

    MS_U8 u8band = (MS_U8)arg2;
    MS_S8 s8level = (MS_U8)arg3;
    API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ(u8band, s8level);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_PEQCoef(void)
{
    int arg2;
    API_AUDIO_CUSTOMER_MSTAR_PEQ_COEF peq_coef;

    AU_nPRINT("MStar PEQ:            \n");
    AU_nPRINT("select PEQ band = 0~7 \n");
    arg2 = AU_CUS_Debug_GetDec();
    peq_coef.band = (MS_U8)arg2;

    AU_nPRINT("1:enable/0:disable peq band\n");
    arg2 = AU_CUS_Debug_GetDec();
    peq_coef.enable = (MS_BOOL)arg2;

    AU_nPRINT("set peq coefficent a0: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    peq_coef.a0 = (MS_U32)arg2;

    AU_nPRINT("set peq coefficent a1: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    peq_coef.a1 = (MS_U32)arg2;

    AU_nPRINT("set peq coefficent a2: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    peq_coef.a2 = (MS_U32)arg2;

    AU_nPRINT("set peq coefficent b1: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    peq_coef.b1 = (MS_U32)arg2;

    AU_nPRINT("set peq coefficent b2: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    peq_coef.b2 = (MS_U32)arg2;

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef(&peq_coef);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_HPFCoef(void)
{
    int arg2;
    API_AUDIO_CUSTOMER_MSTAR_HPF_COEF hpf_coef;

    AU_nPRINT("MStar HPF:             \n");
    AU_nPRINT("set hpf coefficent a0: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    hpf_coef.a0 = (MS_U32)arg2;

    AU_nPRINT("set hpf coefficent a1: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    hpf_coef.a1 = (MS_U32)arg2;

    AU_nPRINT("set hpf coefficent a2: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    hpf_coef.a2 = (MS_U32)arg2;

    AU_nPRINT("set hpfcoefficent b1: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    hpf_coef.b1 = (MS_U32)arg2;

    AU_nPRINT("set hpf coefficent b2: \n");
    arg2 = AU_CUS_Debug_GetHex("");
    hpf_coef.b2 = (MS_U32)arg2;

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef(&hpf_coef);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_MODE(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_MODE:  \n");
    AU_nPRINT("AVC_LINEAR = 0   \n");
    AU_nPRINT("AVC_SHIFT  = 1   \n");
    AU_nPRINT("AVC_NORMAL = 2   \n");
    AU_nPRINT("AVC_R      = 3   \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE((API_AUDIO_CUSTOMER_MSTAR_AVC_MODE)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_LEVEL(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_LEVEL:     \n");
    AU_nPRINT("0x00--  +0     dBFS  \n");
    AU_nPRINT("0x01--  -0.5   dBFS  \n");
    AU_nPRINT("0x20--  -16    dBFS  \n");
    AU_nPRINT("0x50--  -40    dBFS  \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL((MS_U16)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_S_MODE_OFFSET(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_S_MODE_OFFSET: \n");
    AU_nPRINT("range: +0 ~ +12 dB       \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET((MS_U16)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Begin(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_R_MODE_Begin: \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin((MS_U16)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_End(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_R_MODE_End: \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End((MS_U16)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Slope(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_R_MODE_Slope: \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Slope((MS_U16)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_AttackTime(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_AttackTime:    \n");
    AU_nPRINT("AvcAT = 0 --> 20  ms     \n");
    AU_nPRINT("AvcAT = 1 --> 100 ms     \n");
    AU_nPRINT("AvcAT = 2 --> 200 ms     \n");
    AU_nPRINT("AvcAT = 3 --> 1 sec      \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime((MS_U8)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_ReleaseTime(void)
{
    int arg2;

    AU_nPRINT("MStar AVC_ReleaseTime:   \n");
    AU_nPRINT("AvcRT = 0 --> 1 sec      \n");
    AU_nPRINT("AvcRT = 1 --> 2 sec      \n");
    AU_nPRINT("AvcRT = 2 --> 100 ms     \n");
    AU_nPRINT("AvcRT = 3 --> 200 ms     \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime((MS_U8)arg2);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_DRC_LEVEL(void)
{
    int arg2;

    AU_nPRINT("MStar DRC level:\n");

    AU_nPRINT("set DRC level = -48~48(-12dB~12dB, step 0.25dB) \n");
    arg2 = AU_CUS_Debug_GetDec();

    MS_S8 s8level = (MS_U8)arg2;
    API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL(s8level);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_BALANCE(void)
{
    int arg2, arg3;

    AU_nPRINT("Lbalance:\n");
    arg2 = (MS_U16)AU_CUS_Debug_GetDec();

    AU_nPRINT("Rbalance:\n");
    arg3 = (MS_U16)AU_CUS_Debug_GetDec();

    MS_U16 Lbalance = (MS_U16)arg2;
    MS_U16 Rbalance = (MS_U16)arg3;

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE(Lbalance, Rbalance);
}

void AU_CUS_AQ_Tuning_MSTAR_SE_SET_NR_Threshold(void)
{
    int arg2;

    AU_nPRINT("u16level:\n");
    arg2 = AU_CUS_Debug_GetHex("");

    MS_U16 u16level = (MS_U16)arg2;

    API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold(u16level);
}

void AU_CUS_AQ_Dump_Data_MSTAR_SE_Upper(void)
{
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                       MSTAR_SE_Enable                          |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MStar_SE_Enable[GEQ]                                            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_GEQ]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_GEQ] );
    AU_nPRINT("|MStar_SE_Enable[PEQ]                                            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_PEQ]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_PEQ] );
    AU_nPRINT("|MStar_SE_Enable[HPF]                                            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_HPF]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_HPF] );
    AU_nPRINT("|MStar_SE_Enable[DRC]                                            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_DRC]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DRC] );
    AU_nPRINT("|MStar_SE_Enable[AVC]                                            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_AVC]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_AVC] );
    AU_nPRINT("|MStar_SE_Enable[BALANCE]                                        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[API_AUDIO_CUSTOMER_BALANCE]    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_BALANCE] );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                      MSTAR_SE_SET_GEQ                          |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_GEQ[0]                                             | = 0x%-8X| UpperSetCnt: %d     \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[0]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_GEQ[1]                                             | = 0x%-8X| UpperSetCnt: %d     \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[1]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_GEQ[2]                                             | = 0x%-8X| UpperSetCnt: %d     \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[2]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_GEQ[3]                                             | = 0x%-8X| UpperSetCnt: %d     \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[3]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_GEQ[4]                                             | = 0x%-8X| UpperSetCnt: %d     \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[4]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[4] );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                      MSTAR_SE_SET_PEQCoef                      |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[0].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[0].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[0] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[1].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[1].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[1] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[2].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[2].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[2] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[3].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[3].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[3] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[4].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[4].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[4] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[5].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[5].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[5] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[6].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[6].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[6] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].band                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].band   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].a0                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].a0     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].a1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].a1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].a2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].a2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].b1                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].b1     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].b2                                      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].b2     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].enable                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].enable , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|MSTAR_SE_SET_PEQCoef[7].scale                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[7].scale  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[7] );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                     MSTAR_SE_SET_HPFCoef                       |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_HPFCoef.a0                                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a0        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_HPFCoef.a1                                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a1        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_HPFCoef.a2                                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a2        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_HPFCoef.b1                                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.b1        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_HPFCoef.b2                                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.b2        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                   MSTAR_SE_SET_AVC_MODE                        |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_MODE                                           | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                   MSTAR_SE_SET_AVC_LEVEL                       |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_LEVEL                                          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|                   MSTAR_SE_SET_AVC_R_Mode                      |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_R_Mode_Begin                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_AVC_R_Mode_End                                     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_AVC_R_Mode_Slope                                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope_UpperSetCnt );
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                MSTAR_SE_SET_AVC_S_MODE_OFFSET                  |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_S_MODE_OFFSET                                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                 MSTAR_SE_SET_AVC_AttackTime                    |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_AttackTime                                     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                 MSTAR_SE_SET_AVC_ReleaseTime                   |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_AVC_ReleaseTime                                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                  MSTAR_SE_SET_DRC_LEVEL                        |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_DRC_LEVEL                                          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                  MSTAR_SE_SET_BALANCE                          |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_BALANCE_L                                          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_L         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_SET_BALANCE_R                                          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_R         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_UpperSetCnt );
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                  MSTAR_SE_NR                                   |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|MSTAR_SE_SET_NR_Threshold                                       | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold_UpperSetCnt );
    AU_nPRINT("|MSTAR_SE_GET_NR_Status                                          | = 0x%-8X                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold      );
    AU_nPRINT("|________________________________________________________________|                               \n");
}

void AU_CUS_AQ_Tuning_DTS_SE_Enable(void)
{
    unsigned int arg2;

    AU_nPRINT("DTS_SE_TYPE:\n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_TSXT           = 0 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_TSHD           = 1 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_THEATERSOUND   = 2 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PURESND        = 3 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_STUDIOSOUND_3D = 4 \n");

    AU_nPRINT("Enter Option: \n");
    arg2 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_DTS_SE_TYPE seType = (API_AUDIO_CUSTOMER_DTS_SE_TYPE)arg2;
    API_AUDIO_CUSTOMER_DTS_SE_Enable(seType);
}

void AU_CUS_AQ_Tuning_DTS_SE_ProcessUnit_Enable(void)
{
    unsigned int arg2, arg3;

    AU_nPRINT("DTS_SE_UNIT_TYPE:\n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TOTAL                            = 0    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD                             = 1    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DEFINITION                  = 2    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DC                          = 3    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_SURR                        = 4    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS                     = 5    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS_LVL_INDPT           = 6    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D                             = 7    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_DEPTH_PROCESS               = 8    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME                        = 9    \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME_NORMALIZER             = 10   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUDIALOG                        = 11   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_TBHDX                       = 12   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_GEQ                              = 13   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HL                                  = 14   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_AEQ                                 = 15   \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HPF                                 = 16   \n");

    AU_nPRINT("Enter Option: \n");
    arg2 = AU_CUS_Debug_GetDec();

    AU_nPRINT("1: Enable, 0: Disable:\n");
    arg3 = AU_CUS_Debug_GetDec();

    API_AUDIO_CUSTOMER_DTS_SE_UNIT_TYPE seUnit = (API_AUDIO_CUSTOMER_DTS_SE_UNIT_TYPE)arg2;
    MS_BOOL bEn = (MS_BOOL)arg3;
    API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable(seUnit, bEn);
}

void AU_CUS_AQ_Tuning_DTS_SE_SetParam(void)
{
    unsigned int arg2, arg3;

    AU_nPRINT("DTS_SE_PARAM_TYPE:\n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_INPUT_GAIN_FXP24                  = 0  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DEFINITION_CTRL_FXP24             = 1  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DC_LEVEL_CTRL_FXP24               = 2  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_SURR_LEVEL_CTRL_FXP24             = 3  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CTRL_FXP24                = 4  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_COMPR_CTRL_FXP24          = 5  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE              = 6  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_SPKSIZE                   = 7  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE               = 8  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS      = 9  \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_HEADROOM_GAIN_FXP24          = 10 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_BYPASS_GAIN_FXP24            = 11 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_CC3D_PROCESS_PATH            = 12 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_INPUT_GAIN_FXP24                  = 13 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MODE                         = 14 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_REF_LEVEL_FXP24              = 15 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MAX_GAIN_FXP24               = 16 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH_FXP24       = 17 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_INPUT_GAIN_FXP24             = 18 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_CLARITY_GAIN_FXP24           = 19 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_PROCESS_GAIN_FXP24           = 20 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_INPUT_GAIN_FXP24            = 21 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_BASSLEVEL_FXP24             = 22 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE                 = 23 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_HP_ORDER                    = 24 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_DYNAMICS_FXP24              = 25 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_MODE                        = 26 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_INPUT_GAIN_FXP24                    = 27 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_PROCESS_MODE                        = 28 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LR_OUTPUT_GAIN_FXP24                = 29 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LsRs_OUTPUT_GAIN_FXP24              = 30 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_Center_OUTPUT_GAIN_FXP24            = 31 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_INPUT_GAIN_FXP24                   = 32 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND0_GAIN_FXP24                   = 33 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND1_GAIN_FXP24                   = 34 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND2_GAIN_FXP24                   = 35 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND3_GAIN_FXP24                   = 36 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND4_GAIN_FXP24                   = 37 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_INPUT_GAIN_FXP24                       = 38 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_OUTPUT_GAIN_FXP24                      = 39 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_BYPASS_GAIN_FXP24                      = 40 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_LIMITERBOOST_FXP24                     = 41 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_HARDLIMIT_CTRL_FXP24                   = 42 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_DELAY                                  = 43 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_INPUT_GAIN_FXP24                      = 44 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_OUTPUT_GAIN_FXP24                     = 45 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_BYPASS_GAIN_FXP24                     = 46 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HPF_FREQUENCY                             = 47 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_INPUT_GAIN_FXP24                          = 48 \n");
    AU_nPRINT("API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_OUTPUT_GAIN_FXP24                         = 49 \n");

    AU_nPRINT("Enter Option: \n");
    arg2 = AU_CUS_Debug_GetDec();

    AU_nPRINT("if upper layer need to set 0.5: u32value should be 0.5*8388607 = 0x3FFFFF \n");
    AU_nPRINT("if upper layer need to set 2.0: u32value should be 2.0*8388607 = 0xFFFFFE \n");
    AU_nPRINT("Enter Param (u32value): \n");
    arg3 = AU_CUS_Debug_GetHex("");

    API_AUDIO_CUSTOMER_DTS_SE_PARAM_TYPE param = (API_AUDIO_CUSTOMER_DTS_SE_PARAM_TYPE)arg2;
    MS_U32 u32value = (MS_U32)arg3;

    API_AUDIO_CUSTOMER_DTS_SE_SetParam(param, u32value);
}

void AU_CUS_AQ_Tuning_Dolby_DAP_Enable(void)
{
    unsigned int arg2;

    AU_nPRINT("bOnOff:\n");
    arg2 = AU_CUS_Debug_GetDec();

    MS_BOOL bOnOff = (MS_BOOL)arg2;
    API_AUDIO_CUSTOMER_Dolby_DAP_Enable(bOnOff);
}

void AU_CUS_AQ_Tuning_Dolby_DAP_ProcessUnit_Enable(void)
{
    unsigned int arg2;

    AU_nPRINT("bOnOff:\n");
    arg2 = AU_CUS_Debug_GetDec();

    MS_BOOL bOnOff = (MS_BOOL)arg2;
    API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable(bOnOff);
}

void AU_CUS_AQ_Tuning_Dolby_DAP_SetParam(void)
{
    //Demo of Dolby DAP Default params
    API_AUDIO_CUSTOMER_DOLBY_DAP_PARAM DolbyDap_default_params =
    {
        0,      // int pregain;                 -> dap_cpdp_pregain_set
        0,      // int postgain;                -> dap_cpdp_postgain_set
        0,      // int systemgain;              -> dap_cpdp_system_gain_set
        1,      // int surround_decoder_enable; -> dap_cpdp_surround_decoder_enable_set
        1,      // int virtualizer_enable;      -> dap_cpdp_output_mode_set(DAP_CPDP_OUTPUT_2_SPEAKER)
        0,      // headphone_reverb;            -> dap_cpdp_virtualizer_headphone_reverb_gain_set
        5,      // int speaker_angle;           -> dap_cpdp_virtualizer_speaker_angle_set
        200,    // int speaker_start;           -> dap_cpdp_virtualizer_speaker_start_freq_set
        96,     // int surround_boost;          -> dap_cpdp_surround_boost_set
        0,      // int mi_ieq_enable;           -> dap_cpdp_mi2ieq_steering_enable_set
        0,      // int mi_dv_enable;            -> dap_cpdp_mi2dv_leveler_steering_enable_set
        0,      // int mi_de_enable;            -> dap_cpdp_mi2dialog_enhancer_steering_enable_set
        0,      // int mi_surround_enable;      -> dap_cpdp_mi2surround_compressor_steering_enable_set
        0,      // int calibration_boost;       -> dap_cpdp_calibration_boost_set
        7,      // int leveler_amount;          -> dap_cpdp_volume_leveler_amount_set
        -496,   // int leveler_input;           -> dap_cpdp_volume_leveler_in_target_set
        -496,   // int leveler_output;          -> dap_cpdp_volume_leveler_out_target_set
        0,      // int leveler_enable;          -> dap_cpdp_volume_leveler_enable_set
        0,      // int modeler_enable;          -> dap_cpdp_volume_modeler_enable_set
        0,      // int modeler_calibration;     -> dap_cpdp_volume_modeler_calibration_set
        0,      // int ieq_enable;              -> dap_cpdp_ieq_enable_set
        10,     // int ieq_amount;              -> dap_cpdp_ieq_amount_set
        20,     // int ieq_nb_bands;            -> dap_cpdp_ieq_bands_set
        {       // int a_ieq_band_center[DAP_IEQ_MAX_BANDS];
            65,   136,  223,  332,  467,  634,  841,  1098,  1416,  1812,
            2302, 2909, 3663, 4598, 5756, 7194, 8976, 11186, 13927, 17326
        },
        {       // int a_ieq_band_target[DAP_IEQ_MAX_BANDS];
            117, 133, 188, 176, 141, 149, 175, 185, 185, 200,
            236, 242, 228, 213, 182, 132, 110, 68,  -27, -240
        },
        1,      // int de_enable;       -> dap_cpdp_de_enable_set
        9,      // int de_amount;       -> dap_cpdp_de_amount_set
        0,      // int de_ducking;      -> dap_cpdp_de_ducking_set
        0,      // int volmax_boost;    -> dap_cpdp_volmax_boost_set
        0,      // int geq_enable;      -> dap_cpdp_graphic_equalizer_enable_set
        0,      // int geq_nb_bands;    -> dap_cpdp_graphic_equalizer_bands_set
        {       // int a_geq_band_center[DAP_GEQ_MAX_BANDS];
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        {       // int a_geq_band_target[DAP_GEQ_MAX_BANDS];
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        1,      // int optimizer_enable;    -> dap_cpdp_audio_optimizer_enable_set
        20,     // int ao_bands;            -> dap_cpdp_audio_optimizer_bands_set
        {       // int ao_band_center_freq[DAP_OPT_MAX_BANDS];
            47,   141,  234,  328,  469,  656,  844,  1031,  1313,  1688,
            2250, 3000, 3750, 4688, 5813, 7125, 9000, 11250, 13875, 19688
        },
        {       // int ao_band_gains[DAP_MAX_CHANNELS][DAP_OPT_MAX_BANDS];
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 192, 192, 185
            },
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 165, 187, 192
            },
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 192, 192, 185
            },
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 192, 192, 185
            },
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 192, 192, 185
            },
            {
                0,  48, 159, 55,  53, 41, 2,   26,  25,  60,
                68, 51, 69,  -21, 54, 99, 176, 192, 192, 185
            },
        },
        1,      // int bass_enable; -> dap_cpdp_bass_enhancer_enable_set
        177,    // int bass_boost;  -> dap_cpdp_bass_enhancer_boost_set
        140,    // int bass_cutoff; -> dap_cpdp_bass_enhancer_cutoff_frequency_set
        9,      // int bass_width;  -> dap_cpdp_bass_enhancer_width_set
        20,     // int ar_bands;    -> dap_cpdp_regulator_tuning_set
        {       // int ar_band_center_freq[DAP_REG_MAX_BANDS];
            47,   141,  234,  328,  469,  656,  844,  1031,  1313,  1688,
            2250, 3000, 3750, 4688, 5813, 7125, 9000, 11250, 13875, 19688
        },
        {       // int ar_low_thresholds[DAP_REG_MAX_BANDS];
            -496, -192, -448, -384, -192, -192, -192, -192, -192, -192,
            -192, -192, -192, -192, -192, -192, -192, -192, -192, -192
        },
        {       // int ar_high_thresholds[DAP_REG_MAX_BANDS];
            -304, 0, -256, -192, 0, 0, 0, 0, 0, 0,
            0,    0, 0,    0,    0, 0, 0, 0, 0, 0
        },
        {       // int ar_isolated_bands[DAP_REG_MAX_BANDS];
            1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        },
        0,      // int regulator_overdrive;     -> dap_cpdp_regulator_overdrive_set
        12,     // int regulator_timbre;        -> dap_cpdp_regulator_timbre_preservation_set
        96,     // int regulator_distortion;    -> dap_cpdp_regulator_relaxation_amount_set
        1,      // int regulator_mode;          -> dap_cpdp_regulator_speaker_distortion_enable_set
        1,      // int regulator_enable;        -> dap_cpdp_regulator_enable_set
        3,      // int virtual_bass_mode;
        55,     // int virtual_bass_low_src_freq;
        110,    // int virtual_bass_high_src_freq;
        0,      // int virtual_bass_overall_gain;
        -2,     // int virtual_bass_slope_gain;
        {       // int virtual_bass_subgain[3];
            -80, -240, -400
        },
        110,    //int virtual_bass_mix_low_freq;
        281,    //int virtual_bass_mix_high_freq;
    };

    API_AUDIO_CUSTOMER_Dolby_DAP_SetParam(DolbyDap_default_params);
}

void AU_CUS_AQ_Dump_Data_DTS_SE_Upper(void)
{
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [01] DTS_SE_Enable **                                                                                                                 \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                       DTS_SE_Enable                            |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_TSXT]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_TSXT]            , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_TSXT] );
    AU_nPRINT("|DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_TSHD]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_TSHD]            , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_TSHD] );
    AU_nPRINT("|DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_THEATERSOUND]           | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_THEATERSOUND]    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_THEATERSOUND] );
    AU_nPRINT("|DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_PURESND]                | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_PURESND]         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PURESND] );
    AU_nPRINT("|DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_STUDIOSOUND_3D]         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[API_AUDIO_CUSTOMER_DTS_SE_STUDIOSOUND_3D]  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_STUDIOSOUND_3D] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [02] DTS_SE_ProcessUnit_Enable  **                                                                                                    \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                       TSHD                                     |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TOTAL]                   | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TOTAL]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TOTAL] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD]                    | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD]                      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD_DEFINITION]         | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DEFINITION]           , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DEFINITION] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD_DC]                 | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DC]                   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_DC] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD_SURR]               | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_SURR]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_SURR] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD_TRUBASS]            | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS]              , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TSHD_TRUBASS_LVL_INDPT]  | = 0x%-8X| UpperSetCnt:%d      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS_LVL_INDPT]    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TSHD_TRUBASS_LVL_INDPT] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    CC3D Controls (CC3D must enable)            |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_CC3D]                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D]                      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_CC3D_DEPTH_PROCESS]      | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_DEPTH_PROCESS]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_DEPTH_PROCESS] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    TRUVOLUME HD                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TRUVOLUME]               | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME] );
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TRUVOLUME_NORMALIZER]    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME_NORMALIZER]      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUVOLUME_NORMALIZER] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                      TRUDIALOG                                 |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_TRUDIALOG]               | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUDIALOG]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_TRUDIALOG] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                       TBHDX                                    |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_CC3D_TBHDX]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_TBHDX]                , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_CC3D_TBHDX] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                        GEQ                                     |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[THEATERSOUND_GEQ]                     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_GEQ]                       , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_THEATERSOUND_GEQ] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                 PURESOUND HRADLIMITER                          |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[PURESOUND_HL]                         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HL]                           , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HL] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    PURESOUND AEQ                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[PURESOUND_AEQ]                        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_AEQ]                          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_AEQ] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    PURESOUND HPF                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_ProcessUnit_Enable[PURESOUND_HPF]                        | = 0x-8%X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HPF]                          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_UNIT_PURESOUND_HPF] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("                                                                                                 \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [03] DTS_SE_SetParam **                                                                                                               \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                       TSHD                                     |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_INPUT_GAIN_FXP24]             | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_INPUT_GAIN_FXP24]              , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_DEFINITION_CTRL_FXP24]        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DEFINITION_CTRL_FXP24]         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DEFINITION_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_DC_LEVEL_CTRL_FXP24]          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DC_LEVEL_CTRL_FXP24]           , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_DC_LEVEL_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_SURR_LEVEL_CTRL_FXP24]        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_SURR_LEVEL_CTRL_FXP24]         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_SURR_LEVEL_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_CTRL_FXP24]           | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CTRL_FXP24]            , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_COMPR_CTRL_FXP24]     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_COMPR_CTRL_FXP24]      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_COMPR_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE]         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE]          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_PROCESS_MODE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_SPKSIZE]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_SPKSIZE]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_SPKSIZE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE]          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE]           , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS] | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS]  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TSHD_TRUBASS_CUS_SPKSIZE_ANALYSIS] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    Main Controls                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_MAIN_CTRL_HEADROOM_GAIN_FXP24]     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_HEADROOM_GAIN_FXP24]      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_HEADROOM_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_MAIN_CTRL_BYPASS_GAIN_FXP24]       | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_BYPASS_GAIN_FXP24]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_BYPASS_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_MAIN_CTRL_CC3D_PROCESS_PATH]       | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_CC3D_PROCESS_PATH]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_MAIN_CTRL_CC3D_PROCESS_PATH] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    CC3D Controls                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_INPUT_GAIN_FXP24]             | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_INPUT_GAIN_FXP24]              , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_INPUT_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    TRUVOLUME HD                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TRUVOLUME_MODE]                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MODE]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MODE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TRUVOLUME_REF_LEVEL_FXP24]         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_REF_LEVEL_FXP24]          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_REF_LEVEL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TRUVOLUME_MAX_GAIN_FXP24]          | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MAX_GAIN_FXP24]           , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_MAX_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH_FXP24]  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH_FXP24]   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUVOLUME_NORMALIZE_THRESH_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    TRUDIALOG                                   |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[TRUDIALOG_INPUT_GAIN_FXP24]                     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_INPUT_GAIN_FXP24]         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[TRUDIALOG_CLARITY_GAIN_FXP24]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_CLARITY_GAIN_FXP24]       , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_CLARITY_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[TRUDIALOG_PROCESS_GAIN_FXP24]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_PROCESS_GAIN_FXP24]       , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_TRUDIALOG_PROCESS_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                      TBHDX                                     |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_INPUT_GAIN_FXP24]       | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_INPUT_GAIN_FXP24]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_BASSLEVEL_FXP24]        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_BASSLEVEL_FXP24]         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_BASSLEVEL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE]            | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE]             , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_SPEAKERSIZE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_HP_ORDER]               | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_HP_ORDER]                , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_HP_ORDER] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_DYNAMICS_FXP24]         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_DYNAMICS_FXP24]          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_DYNAMICS_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CC3D_TBHDX_MODE]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_MODE]                    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CC3D_TBHDX_MODE] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                   CS DECODER                                   |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CS_INPUT_GAIN_FXP24]               | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_INPUT_GAIN_FXP24]                , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CS_PROCESS_MODE]                   | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_PROCESS_MODE]                    , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_PROCESS_MODE] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CS_LR_OUTPUT_GAIN_FXP24]           | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LR_OUTPUT_GAIN_FXP24]            , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LR_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CS_LsRs_OUTPUT_GAIN_FXP24]         | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LsRs_OUTPUT_GAIN_FXP24]          , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_LsRs_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_CS_Center_OUTPUT_GAIN_FXP24]       | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_Center_OUTPUT_GAIN_FXP24]        , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_CS_Center_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                        GEQ                                     |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_INPUT_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_INPUT_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_BAND0_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND0_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND0_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_BAND1_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND1_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND1_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_BAND2_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND2_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND2_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_BAND3_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND3_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND3_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[THEATERSOUND_GEQ_BAND4_GAIN_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND4_GAIN_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_THEATERSOUND_GEQ_BAND4_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|              PURESOUND HRADLIMITER                             |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_INPUT_GAIN_FXP24]                  | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_INPUT_GAIN_FXP24]                   , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_OUTPUT_GAIN_FXP24]                 | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_OUTPUT_GAIN_FXP24]                  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_BYPASS_GAIN_FXP24]                 | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_BYPASS_GAIN_FXP24]                  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_BYPASS_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_LIMITERBOOST_FXP24]                | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_LIMITERBOOST_FXP24]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_LIMITERBOOST_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_HARDLIMIT_CTRL_FXP24]              | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_HARDLIMIT_CTRL_FXP24]               , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_HARDLIMIT_CTRL_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HL_DELAY]                             | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_DELAY]                              , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HL_DELAY] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    PURESOUND AEQ                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_AEQ_INPUT_GAIN_FXP24]                 | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_INPUT_GAIN_FXP24]                  , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_AEQ_OUTPUT_GAIN_FXP24]                | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_OUTPUT_GAIN_FXP24]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_AEQ_BYPASS_GAIN_FXP24]                | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_BYPASS_GAIN_FXP24]                 , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_AEQ_BYPASS_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                    PURESOUND HPF                               |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_HPF_FREQUENCY]                        | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HPF_FREQUENCY]                         , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_HPF_FREQUENCY] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT(" ________________________________________________________________                                \n");
    AU_nPRINT("|                  PURESOUND hash only                           |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_INPUT_GAIN_FXP24]                     | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_INPUT_GAIN_FXP24]                      , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_INPUT_GAIN_FXP24] );
    AU_nPRINT("|DTS_SE_SetParam[PURESOUND_OUTPUT_GAIN_FXP24]                    | = 0x%-8X| UpperSetCnt: %d     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_OUTPUT_GAIN_FXP24]                     , (unsigned int)pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[API_AUDIO_CUSTOMER_DTS_SE_PARAM_PURESOUND_OUTPUT_GAIN_FXP24] );
    AU_nPRINT("|                                                                |                               \n");
    AU_nPRINT("|________________________________________________________________|                               \n");
    AU_nPRINT("=======================================================================================================================================  \n");
}

void AU_CUS_AQ_Dump_Data_DTS_SE_R2(int sleepTime)
{
    MS_U16 orignal_REG_BANK_R2_LOG_DBG;
    MS_U16 orignal_REG_BANK_R2_UART;

    orignal_REG_BANK_R2_LOG_DBG = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_LOG_DBG);
    orignal_REG_BANK_R2_UART    = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_UART);

    AU_nPRINT("orignal_REG_BANK_R2_LOG_DBG = 0x%-4X,\n", orignal_REG_BANK_R2_LOG_DBG);
    AU_nPRINT("orignal_REG_BANK_R2_UART    = 0x%-4X,\n", orignal_REG_BANK_R2_UART);

    //Set R2
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART, (MS_U16)REG_BANK_R2_SND_UART_ENABLE);
    AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_SND_R2_SRS, 0x80, 0x80); // SRS print msg
    sleep(sleepTime);

    //Recover
    AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_SND_R2_SRS, 0x80, 0x00); // SRS print msg
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART, (MS_U16)orignal_REG_BANK_R2_UART);
}

void AU_CUS_AQ_Dump_Data_DAP_Upper(void)
{
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [01] Dolby_DAP_Enable **                                                                                                              \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                    \n");
    AU_nPRINT("|                   Dolby_DAP_Enable                             |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("|g_audio_customer_Dolby_DAP_Enable                               | = 0x%-8X| UpperSetCnt: %d         \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable, (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable_UpperSetCnt );
    AU_nPRINT("|                                                                |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [02] Dolby_DAP_ProcessUnit_Enable **                                                                                                  \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                    \n");
    AU_nPRINT("|               Dolby_DAP_ProcessUnit_Enable                     |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("|g_audio_customer_Dolby_DAP_ProcessUnit_Enable                   | = 0x%-8X| UpperSetCnt: %d         \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable, (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable_UpperSetCnt );
    AU_nPRINT("|                                                                |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT("** [03] Dolby_DAP_SetParam **                                                                                                            \n");
    AU_nPRINT("=======================================================================================================================================  \n");
    AU_nPRINT(" ________________________________________________________________                                    \n");
    AU_nPRINT("|                 Dolby_DAP_SetParam                             |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("|g_audio_customer_Dolby_DAP_ProcessUnit_Enable                   | = 0x%-8X| UpperSetCnt: %d         \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable, (unsigned int)pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam_UpperSetCnt );
    AU_nPRINT("|                                                                |                                   \n");
    AU_nPRINT("|________________________________________________________________|                                   \n");
    AU_nPRINT("    %-8d, pregain                                                          \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.pregain                     );
    AU_nPRINT("    %-8d, postgain                                                         \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.postgain                    );
    AU_nPRINT("    %-8d, systemgain                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.systemgain                  );
    AU_nPRINT("    %-8d, surround_decoder_enable                                          \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.surround_decoder_enable     );
    AU_nPRINT("    %-8d, virtualizer_enable                                               \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtualizer_enable          );
    AU_nPRINT("    %-8d, headphone_reverb                                                 \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.headphone_reverb            );
    AU_nPRINT("    %-8d, speaker_angle                                                    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.speaker_angle               );
    AU_nPRINT("    %-8d, speaker_start                                                    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.speaker_start               );
    AU_nPRINT("    %-8d, surround_boost                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.surround_boost              );
    AU_nPRINT("    %-8d, mi_ieq_enable                                                    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_ieq_enable               );
    AU_nPRINT("    %-8d, mi_dv_enable                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_dv_enable                );
    AU_nPRINT("    %-8d, mi_de_enable                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_de_enable                );
    AU_nPRINT("    %-8d, mi_surround_enable                                               \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_surround_enable          );
    AU_nPRINT("    %-8d, calibration_boost                                                \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.calibration_boost           );
    AU_nPRINT("    %-8d, leveler_amount                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_amount              );
    AU_nPRINT("    %-8d, leveler_input                                                    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_input               );
    AU_nPRINT("    %-8d, leveler_output                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_output              );
    AU_nPRINT("    %-8d, leveler_enable                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_enable              );
    AU_nPRINT("    %-8d, modeler_enable                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.modeler_enable              );
    AU_nPRINT("    %-8d, modeler_calibration                                              \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.modeler_calibration         );
    AU_nPRINT("    %-8d, ieq_enable                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_enable                  );
    AU_nPRINT("    %-8d, ieq_amount                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_amount                  );
    AU_nPRINT("    %-8d, ieq_nb_bands                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_nb_bands                );
    AU_nPRINT("    {   a_ieq_band_center[DOLBY_DAP_IEQ_MAX_BANDS]                         \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_ieq_band_target[DOLBY_DAP_IEQ_MAX_BANDS]                         \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    %-8d, de_enable                                                        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_enable                   );
    AU_nPRINT("    %-8d, de_amount                                                        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_amount                   );
    AU_nPRINT("    %-8d, de_ducking                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_ducking                  );
    AU_nPRINT("    %-8d, volmax_boost                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.volmax_boost                );
    AU_nPRINT("    %-8d, geq_enable                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.geq_enable                  );
    AU_nPRINT("    %-8d, geq_nb_bands                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.geq_nb_bands                );
    AU_nPRINT("    {   a_geq_band_center[DOLBY_DAP_GEQ_MAX_BANDS]                         \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_geq_band_target[DOLBY_DAP_GEQ_MAX_BANDS]                         \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    %-8d, optimizer_enable                                                 \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.optimizer_enable            );
    AU_nPRINT("    %-8d, optimizer_nb_bands                                               \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.optimizer_nb_bands          );
    AU_nPRINT("    {   a_opt_band_center_freq[DOLBY_DAP_OPT_MAX_BANDS]                    \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_opt_band_gain[DOLBY_DAP_MAX_CHANNELS][DOLBY_DAP_OPT_MAX_BANDS]   \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[0][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[1][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[2][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[3][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[4][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("        {                                                                  \n");
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][9]);
    AU_nPRINT("            %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,    \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[5][19]);
    AU_nPRINT("        },                                                                 \n");
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    %-8d, bass_enable                                                      \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_enable                 );
    AU_nPRINT("    %-8d, bass_boost                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_boost                  );
    AU_nPRINT("    %-8d, bass_cutoff                                                      \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_cutoff                 );
    AU_nPRINT("    %-8d, bass_width                                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_width                  );
    AU_nPRINT("    %-8d, reg_nb_bands                                                     \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.reg_nb_bands                );
    AU_nPRINT("    {   a_reg_band_center[DOLBY_DAP_REG_MAX_BANDS]                         \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_reg_low_thresholds[DOLBY_DAP_REG_MAX_BANDS]                      \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_reg_high_thresholds[DOLBY_DAP_REG_MAX_BANDS]                     \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    {   a_reg_isolated_bands[DOLBY_DAP_REG_MAX_BANDS]                      \n");
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[0],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[1],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[2],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[3],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[4],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[5],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[6],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[7],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[8],  pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[9]);
    AU_nPRINT("        %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d, %-8d,        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[10], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[11], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[12], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[13], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[14], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[15], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[16], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[17], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[18], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[19]);
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    %-8d, regulator_overdrive                                              \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_overdrive         );
    AU_nPRINT("    %-8d, regulator_timbre                                                 \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_timbre            );
    AU_nPRINT("    %-8d, regulator_distortion                                             \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_distortion        );
    AU_nPRINT("    %-8d, regulator_mode                                                   \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_mode              );
    AU_nPRINT("    %-8d, regulator_enable                                                 \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_enable            );
    AU_nPRINT("    %-8d, virtual_bass_mode                                                \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mode           );
    AU_nPRINT("    %-8d, virtual_bass_low_src_freq                                        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_low_src_freq   );
    AU_nPRINT("    %-8d, virtual_bass_high_src_freq                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_high_src_freq  );
    AU_nPRINT("    %-8d, virtual_bass_overall_gain                                        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_overall_gain   );
    AU_nPRINT("    %-8d, virtual_bass_slope_gain                                          \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_slope_gain     );
    AU_nPRINT("    {   virtual_bass_subgain[3]                                            \n");
    AU_nPRINT("        %-8d, %-8d, %-8d,                                                  \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_subgain[0], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_subgain[1], pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_subgain[2] );
    AU_nPRINT("    }                                                                      \n");
    AU_nPRINT("    %-8d, virtual_bass_mix_low_freq                                        \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mix_low_freq   );
    AU_nPRINT("    %-8d, virtual_bass_mix_high_freq                                       \n", pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mix_high_freq  );
    AU_nPRINT("                                                                           \n");
}

void AU_CUS_AQ_Dump_All_Related_Param(void)
{
    AU_nPRINT("\n\n\n\n\n");
    AU_CUS_Dump_RegBank(0x112C00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112D00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112E00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x160300);  AU_nPRINT("\n");
    AU_nPRINT("\n\n\n\n\n");

    AU_CUS_AQ_Dump_Data_MSTAR_SE_Upper();
    AU_CUS_AQ_Dump_Data_DTS_SE_Upper();
    AU_CUS_Delay1MS(1000);

    AU_nPRINT("\n\n\n\n\n");
    AU_CUS_AQ_Dump_Data_DTS_SE_R2(4);
    AU_nPRINT("\n\n\n\n\n");
}

//0x9990
void AU_CUS_Show_HashKey_Support(void)
{
    //use ADEC0 to show hash key support

    if(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect != API_AUDIO_CUSTOMER_ADEC_INPUT_INVALID)
    {
        API_AUDIO_CUSTOMER_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
    }
    else
    {
        API_AUDIO_CUSTOMER_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_INPUT_MM);
    }

    if(pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec != API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID)
    {
        API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec);
    }
    else
    {
        API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG);
    }
}

//0x9991
void AU_CUS_AQ_Tuning_and_Dump_Data(void)
{
    int selNum = 0;

    while(selNum != 0x9999)
    {
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("**            (MStar Sound Effect) AQ Tuning              **         \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("(0x0000) AU_CUS_AQ_Tuning_MSTAR_SE_Enable(void)                      \n");
        AU_nPRINT("(0x0001) AU_CUS_AQ_Tuning_MSTAR_SE_SET_GEQ(void)                     \n");
        AU_nPRINT("(0x0002) AU_CUS_AQ_Tuning_MSTAR_SE_SET_PEQCoef(void)                 \n");
        AU_nPRINT("(0x0003) AU_CUS_AQ_Tuning_MSTAR_SE_SET_HPFCoef(void)                 \n");
        AU_nPRINT("(0x0004) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_MODE(void)                \n");
        AU_nPRINT("(0x0005) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_LEVEL(void)               \n");
        AU_nPRINT("(0x0006) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Begin(void)        \n");
        AU_nPRINT("(0x0007) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_End(void)          \n");
        AU_nPRINT("(0x0008) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Slope(void)        \n");
        AU_nPRINT("(0x0009) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_S_MODE_OFFSET(void)       \n");
        AU_nPRINT("(0x000A) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_AttackTime(void)          \n");
        AU_nPRINT("(0x000B) AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_ReleaseTime(void)         \n");
        AU_nPRINT("(0x000C) AU_CUS_AQ_Tuning_MSTAR_SE_SET_DRC_LEVEL(void)               \n");
        AU_nPRINT("(0x000D) AU_CUS_AQ_Tuning_MSTAR_SE_SET_BALANCE(void)                 \n");
        AU_nPRINT("(0x000E) AU_CUS_AQ_Tuning_MSTAR_SE_SET_NR_Threshold(void)            \n");
        AU_nPRINT("                                                                     \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("**            (MStar Sound Effect) AQ Dump                **         \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("(0x0100) AU_CUS_AQ_Dump_Data_MSTAR_SE_Upper(void)                    \n");
        AU_nPRINT("                                                                     \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("**            (Advanced Sound Effect) AQ Tuning           **         \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("(0x0200) AU_CUS_AQ_Tuning_DTS_SE_Enable(void)                        \n");
        AU_nPRINT("(0x0201) AU_CUS_AQ_Tuning_DTS_SE_ProcessUnit_Enable(void)            \n");
        AU_nPRINT("(0x0202) AU_CUS_AQ_Tuning_DTS_SE_SetParam(void)                      \n");
        AU_nPRINT("(0x0203) AU_CUS_AQ_Tuning_Dolby_DAP_Enable(void)                     \n");
        AU_nPRINT("(0x0204) AU_CUS_AQ_Tuning_Dolby_DAP_ProcessUnit_Enable(void)         \n");
        AU_nPRINT("(0x0205) AU_CUS_AQ_Tuning_Dolby_DAP_SetParam(void)                   \n");
        AU_nPRINT("                                                                     \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("**            (Advanced Sound Effect) AQ Dump             **         \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("(0x0300) AU_CUS_AQ_Dump_Data_DTS_SE_Upper(void)                      \n");
        AU_nPRINT("(0x0301) AU_CUS_AQ_Dump_Data_DTS_SE_R2(int sleepTime)                \n");
        AU_nPRINT("(0x0302) AU_CUS_AQ_Dump_Data_DAP_Upper(void)                         \n");
        AU_nPRINT("                                                                     \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("**            Dump ALL                                   **          \n");
        AU_nPRINT("============================================================         \n");
        AU_nPRINT("(0x0400) AU_CUS_AQ_Dump_All_Related_Param(void)                      \n");
        AU_nPRINT("(9999) Exit                                                          \n");

        selNum = AU_CUS_Debug_GetHex("");

        switch(selNum)
        {
            case 0x0000:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_Enable();
            }
            break;

            case 0x0001:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_GEQ();
            }
            break;

            case 0x0002:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_PEQCoef();
            }
            break;

            case 0x0003:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_HPFCoef();
            }
            break;

            case 0x0004:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_MODE();
            }
            break;

            case 0x0005:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_LEVEL();
            }
            break;

            case 0x0006:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Begin();
            }
            break;

            case 0x0007:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_End();
            }
            break;

            case 0x0008:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Slope();
            }
            break;

            case 0x0009:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_S_MODE_OFFSET();
            }
            break;

            case 0x000A:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_AttackTime();
            }
            break;

            case 0x000B:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_ReleaseTime();
            }
            break;

            case 0x000C:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_DRC_LEVEL();
            }
            break;

            case 0x000D:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_BALANCE();
            }
            break;

            case 0x000E:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_NR_Threshold();
            }
            break;

            case 0x0100:
            {
                AU_CUS_AQ_Dump_Data_MSTAR_SE_Upper();
            }
            break;

            case 0x0200:
            {
                AU_CUS_AQ_Tuning_DTS_SE_Enable();
            }
            break;

            case 0x0201:
            {
                AU_CUS_AQ_Tuning_DTS_SE_ProcessUnit_Enable();
            }
            break;

            case 0x0202:
            {
                AU_CUS_AQ_Tuning_DTS_SE_SetParam();
            }
            break;

            case 0x0203:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_Enable();
            }
            break;

            case 0x0204:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_ProcessUnit_Enable();
            }
            break;

            case 0x0205:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_SetParam();
            }
            break;

            case 0x0300:
            {
                AU_CUS_AQ_Dump_Data_DTS_SE_Upper();
            }
            break;

            case 0x0301:
            {
                int sleepTime;
                sleepTime = AU_CUS_Debug_GetHex("======= Sleep time: ============ \n");
                AU_CUS_AQ_Dump_Data_DTS_SE_R2(sleepTime);
            }
            break;

            case 0x0302:
            {
                AU_CUS_AQ_Dump_Data_DAP_Upper();
            }
            break;

            case 0x0400:
            {
                AU_CUS_AQ_Dump_All_Related_Param();
            }
            break;

            case 0x9999:
            {
                //Exit
            }
            break;

            default:
                break;
        }
    }

    return;
}

//0x9992
void AU_CUS_MCU_DUMP_R2_LOG(void)
{
    int selNum = 0;
    int r2_log_option = 0;
    int interval = 0;

    while(selNum != 0x9999)
    {
        AU_nPRINT("=============================================                        \n");
        AU_nPRINT("**             Dump R2 Log                 **                        \n");
        AU_nPRINT("=============================================                        \n");
        AU_nPRINT("(Show) r2_log_option(0x%x)                                           \n", r2_log_option);
        AU_nPRINT("(0x01) Start                                                         \n");
        AU_nPRINT("(0x02) Stop                                                          \n");
        AU_nPRINT("(0x03) g_audio_customer_patch_Dump_R2_Log_Monitor_Interval(%d)       \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_Dump_R2_Log_Monitor_Interval);
        AU_nPRINT("(9999) Exit                                                          \n");
        selNum = AU_CUS_Debug_GetHex("");

        switch(selNum)
        {
            case 0x01:
            {
                AU_CUS_Show_R2_Debug_Option();
                AU_nPRINT("Please input R2 Debug Option: \n");
                r2_log_option = AU_CUS_Debug_GetHex("");

                //Step1: set R2 Dbg option
                API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG_OPTION, &r2_log_option);

                //Step2: Open a debug file (just for demo)
                pAU_R2LogBufferDumpFile = AU_CUS_FileOpen(AU_R2_LOG_TO_FILE_PATH, "wb");
                if (pAU_R2LogBufferDumpFile == NULL)
                {
                    AU_nPRINT("Open file FAIL!!\n");
                    break;
                }

                //Step3: Enable R2 logging to file (just for demo)
                #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
                {
                    pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable = TRUE;
                }
                #endif

                //Step4: Set WFI for R2 log.
                MS_BOOL enable = TRUE;
                API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG_ENABLE, &enable);
            }
            break;

            case 0x02:
            {
                #if(CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG)
                {
                    pstAudioCustomerShmData->g_audio_customer_patch_MCU_Dump_R2_Log_Moitor_bEnable = FALSE;
                }
                #endif

                MS_BOOL enable = FALSE;
                AU_CUS_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_MCU_DUMP_R2_LOG_ENABLE, &enable);

                if(pAU_R2LogBufferDumpFile != NULL)
                {
                    AU_CUS_FileClose(pAU_R2LogBufferDumpFile);
                    pAU_R2LogBufferDumpFile = NULL;
                }
            }
            break;

            case 0x03:
            {
                AU_nPRINT("interval: \n");
                interval = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_patch_Dump_R2_Log_Monitor_Interval = interval;
            }
            break;

            case 0x9999:
            {
                //Exit
            }
            break;

            default:
                break;
        }
    }

    return;
}

//0x9994
void AU_CUS_DDR_Dump_Debug(void)
{
    MS_U32 Addr_V = 0;
    MS_U32 Address = 0;
    MS_U32 Size = 0;
    MS_U16 tmpReg1 = 0;
    MS_U16 tmpReg2 = 0;

    MS_U32 u32_DEC_Addr = 0;
    MS_U32 u32_SE_Addr = 0;
    MS_U32 u32_R2_Addr = 0;
    MS_U32 u32ES1BufStartAddr_P = 0;
    MS_U32 u32ES1BufTotalSize = 0;
    MS_U32 u32ES3BufStartAddr_P = 0;
    MS_U32 u32ES3BufTotalSize = 0;

    pAU_DDR_BIN_File = AU_CUS_FileOpen(AU_DDR_BIN_PATH, "wb");

    tmpReg1 = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ADEC1_PLAY);
    tmpReg2 = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_ADEC2_PLAY);
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ADEC1_PLAY, 0);
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ADEC2_PLAY, 0);

    u32_DEC_Addr = MApi_AUDIO_GetDspMadBaseAddr(0);
    u32_SE_Addr = MApi_AUDIO_GetDspMadBaseAddr(1);
    u32_R2_Addr = MApi_AUDIO_GetDspMadBaseAddr(2);

    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID1, Audio_infoType_UNI_ES_Base, &u32ES1BufStartAddr_P);
    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID1, Audio_infoType_UNI_ES_Size, &u32ES1BufTotalSize);
    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID3, Audio_infoType_UNI_ES_Base, &u32ES3BufStartAddr_P);
    MApi_AUDIO_GetAudioInfo2(AU_DEC_ID3, Audio_infoType_UNI_ES_Size, &u32ES3BufTotalSize);

    AU_nPRINT("\n\n\n");
    AU_nPRINT("----------------------------------------------  \n");
    AU_nPRINT("-----------  DDR DUMP debug ------------------  \n");
    AU_nPRINT("----------------------------------------------  \n");
    AU_nPRINT("AUDIO R2  DDR base address [0x%X] \n", (unsigned int)u32_R2_Addr);
    AU_nPRINT("AUDIO DEC DDR base address [0x%X] \n", (unsigned int)u32_DEC_Addr);
    AU_nPRINT("AUDIO SE  DDR base address [0x%X] \n", (unsigned int)u32_SE_Addr);
    AU_nPRINT("AUDIO ES1 DDR base address / size => [0x%X] / [0x%X] \n", (unsigned int)u32ES1BufStartAddr_P, (unsigned int)u32ES1BufTotalSize);
    AU_nPRINT("AUDIO ES3 DDR base address / size => [0x%X] / [0x%X] \n", (unsigned int)u32ES3BufStartAddr_P, (unsigned int)u32ES3BufTotalSize);
    AU_nPRINT("\n\n\n");
    AU_nPRINT("======= Read DDR address ex:R2 address is 0x%X -> Enter 0x%X ============ \n", (unsigned int)u32_R2_Addr, (unsigned int)u32_R2_Addr);
    Address = (MS_U32)AU_CUS_Debug_GetHex("");

    Addr_V = MsOS_MPool_PA2KSEG1(Address);

    AU_nPRINT("======= Read DDR Size ex:R2 size is 0x20000 -> Enter 0x20000 ============ \n");
    Size = (MS_U32)AU_CUS_Debug_GetHex("");

    AU_CUS_FileWrite((void*)Addr_V, 1, Size, pAU_DDR_BIN_File);
    fflush(pAU_DDR_BIN_File);
    if (pAU_DDR_BIN_File != NULL)
    {
        fclose(pAU_DDR_BIN_File);
        pAU_DDR_BIN_File = NULL;
    }
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ADEC1_PLAY, tmpReg1);
    AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ADEC2_PLAY, tmpReg2);

    AU_nPRINT("\n\n\n");
    AU_nPRINT("======= Read DDR address 0x%X with size 0x%X Done ============ \n", (unsigned int)Address, (unsigned int)Size);
    AU_nPRINT("\n\n\n");
}

//0x9995
void AU_CUS_Dump_Audio_Related_Bank(void)
{
    AU_nPRINT("\n\n\n\n");

    //---[HDMI Tx (2.0)] Curry---
    AU_CUS_Dump_RegBank(0x172A00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x172B00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x172C00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x172D00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x172E00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x173000);  AU_nPRINT("\n");

    //---[HDMI Tx (1.4)] Kiwi---
    AU_CUS_Dump_RegBank(0x113000);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x113100);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x113200);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x113300);  AU_nPRINT("\n");

    //---[HDMI Rx (2.0)] Macan---
    AU_CUS_Dump_RegBank(0x173000);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x173900);  AU_nPRINT("\n");

    //---[Audio]---
    AU_CUS_Dump_RegBank(0x112A00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112B00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112C00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112D00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x112E00);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x113000);  AU_nPRINT("\n");
    AU_CUS_Dump_RegBank(0x160300);  AU_nPRINT("\n");

    AU_nPRINT("\n\n\n\n");

    return;
}

void AU_CUS_DumpSIFInfo(void)
{
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DC0h SIF_STD_SEL             15:0    Default : 0x00  Access : R/W                                                                \n");
AU_nPRINT("        RESERVED                15:8    Reserved                                                                                    \n");
AU_nPRINT("        STD_SEL_SET             7:4     For SIF Pal-sum DSP code                                                                    \n");
AU_nPRINT("                                        PAL Sound Standard Mode selection                                                           \n");
AU_nPRINT("                                        1110 = Standard detection command                                                           \n");
AU_nPRINT("                                        0000 = FM mono mode                                                                         \n");
AU_nPRINT("                                        0001 = Hi-dev mode                                                                          \n");
AU_nPRINT("                                        0010 = A2 mode                                                                              \n");
AU_nPRINT("                                        0100 = NICAM mode                                                                           \n");
AU_nPRINT("        STD_SEL                 3:0     SIF audio standard selection                                                                \n");
AU_nPRINT("                                        0000 = Standard not found                                                                   \n");
AU_nPRINT("                                        0001 = AU_SYS_M_BTSC                                                                        \n");
AU_nPRINT("                                        For BTSC, bit[1]: M/N system identification control bit                                     \n");
AU_nPRINT("                                        0 = NTSC_M or PAL_M;                                                                        \n");
AU_nPRINT("                                        1 = PAL_N                                                                                   \n");
AU_nPRINT("                                        0010 = AU_SYS_M_EIAJ                                                                        \n");
AU_nPRINT("                                        0011 = AU_SYS_M_A2                                                                          \n");
AU_nPRINT("                                        0100 = AU_SYS_BG_A2                                                                         \n");
AU_nPRINT("                                        0101 = AU_SYS_DK1_A2                                                                        \n");
AU_nPRINT("                                        0110 = AU_SYS_DK2_A2                                                                        \n");
AU_nPRINT("                                        0111 = AU_SYS_DK3_A2                                                                        \n");
AU_nPRINT("                                        1000 = AU_SYS_BG_NICAM                                                                      \n");
AU_nPRINT("                                        1001 = AU_SYS_DK_NICAM                                                                      \n");
AU_nPRINT("                                        1010 = AU_SYS_I_NICAM                                                                       \n");
AU_nPRINT("                                        1011 = AU_SYS_L_NICAM                                                                       \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DC2h SIF_PFIR_AGC            15:0    Default : 0x00 Access : R/W                                                                 \n");
AU_nPRINT("        RESERVED                15:10   Reserved                                                                                    \n");
AU_nPRINT("        SIF_AGC_RESET                                                                                                               \n");
AU_nPRINT("        (Non VIF mode)          9       1: SIF AGC reset                                                                            \n");
AU_nPRINT("        SIF_AGC_ENABLE                                                                                                              \n");
AU_nPRINT("        (Non VIF mode)          8       0: SIF AGC Disable                                                                          \n");
AU_nPRINT("                                        1: SIF AGC Enable                                                                           \n");
AU_nPRINT("        SIF_CARRIER_DEBOUNCE    7       SIF Carrier Status De-bounce                                                                \n");
AU_nPRINT("                                        0: Check carrier 0x10 times. If carrier changes > 0x08 times, carrier status changes.       \n");
AU_nPRINT("                                        1: Check carrier 0x200 times. If carrier changes > 0x190 times, carrier status changes.     \n");
AU_nPRINT("        HI-DEV_SEL              5:4     HIDEV CH1 PFIR Bandwidth Selection                                                          \n");
AU_nPRINT("                                        01= mode 1 (narrow bandwidth, 130k~260k)                                                    \n");
AU_nPRINT("                                        02= mode 2 (middle bandwidth, 165k~295K)                                                    \n");
AU_nPRINT("                                        03= mode 3 (huge bandwidth, 200k~330k)                                                      \n");
AU_nPRINT("                                        Others = mode 2                                                                             \n");
AU_nPRINT("        A2_CH2_PFIR             1:0     A2 CH2 PFIR Bandwidth Selection                                                             \n");
AU_nPRINT("                                        01= mode 1 (narrow bandwidth, 80k~130k)                                                     \n");
AU_nPRINT("                                        02= mode 2 (middle bandwidth, 100k~150K)                                                    \n");
AU_nPRINT("                                        03= mode 3 (huge bandwidth, 130k~180k)                                                      \n");
AU_nPRINT("                                        Others = mode 2                                                                             \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DC4h SIF_BTSC_A2_SEL         15:0    Default : 0x00  Access : R/W                                                                \n");
AU_nPRINT("        RESERVED                15:8    Reserved                                                                                    \n");
AU_nPRINT("        SIF_SOUND_MOD1[7:0]     7:0     SIF BTSC/A2 demodulator automatic/manual sound mode output select.                          \n");
AU_nPRINT("                                        0xxxxxxx = manual sound select                                                              \n");
AU_nPRINT("                                        00000000 = BTSC Mono                                                                        \n");
AU_nPRINT("                                        00000001 = BTSC Stereo                                                                      \n");
AU_nPRINT("                                        00000010 = BTSC SAP                                                                         \n");
AU_nPRINT("                                        00000000 = A2 Mono                                                                          \n");
AU_nPRINT("                                        00000001 = A2 Stereo                                                                        \n");
AU_nPRINT("                                        00000010 = A2 Dual B                                                                        \n");
AU_nPRINT("                                        00000011 = A2 Dual A+B                                                                      \n");
AU_nPRINT("                                        1xxxxxxx = auto sound select                                                                \n");
AU_nPRINT("                                        10000000 = BTSC Mono <-> Mute                                                               \n");
AU_nPRINT("                                        10000001 = BTSC Stereo <-> Mono <-> Mute                                                    \n");
AU_nPRINT("                                        10000010 = BTSC SAP<-> Mono <-> Mute                                                        \n");
AU_nPRINT("                                        10000000 = A2 Mono <-> Mute                                                                 \n");
AU_nPRINT("                                        10000001 = A2 Stereo <->Mono <-> Mute                                                       \n");
AU_nPRINT("                                        10000010 = A2 Dual B <->Mono <-> Mute                                                       \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DC6h SIF_NICAM_SEL           15:0    Default : 0x00  Access : R/W                                                                \n");
AU_nPRINT("        RESERVED                15:8    Reserved                                                                                    \n");
AU_nPRINT("        SIF_SOUND_MOD2[7:0]     7:0     SIF NICAM demodulator automatic sound mode output select.                                   \n");
AU_nPRINT("                                        00000000 = NICAM Auto Mode                                                                  \n");
AU_nPRINT("                                            Nicam Sound (auto) <-> FM/AM Mono <-> Mute                                              \n");
AU_nPRINT("                                            0x01 = FM/AM Mono                                                                       \n");
AU_nPRINT("                                            0x02 = Stereo L / R <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x03 = Stereo L / L <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x04 = Stereo R / R <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x05 = Dual A/ B    <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x06 = Dual A / A   <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x07 = Dual B / B   <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x08 = Nicam Mono   <-> FM/AM Mono                                                      \n");
AU_nPRINT("                                            0x80 = Force NICAM SOUND                                                                \n");
AU_nPRINT("                                            0x82 = Force Stereo L / R                                                               \n");
AU_nPRINT("                                            0x83 = Force Stereo L / L                                                               \n");
AU_nPRINT("                                            0x84 = Force Stereo R / R                                                               \n");
AU_nPRINT("                                            0x85 = Force Dual A/ B                                                                  \n");
AU_nPRINT("                                            0x86 = Force Dual A / A                                                                 \n");
AU_nPRINT("                                            0x87 = Force Dual B / B                                                                 \n");
AU_nPRINT("                                            0x88 = Force Nicam Mono                                                                 \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DE0h SIF_PAL_DEC_RESULT      15:0    Default : 0x00  Access : R                                                                  \n");
AU_nPRINT("        RESERVED                15:8    Reserved                                                                                    \n");
AU_nPRINT("        BUSY                    7       Audio SIF Standard Detection Flag                                                           \n");
AU_nPRINT("                                        0 = standard detection finished                                                             \n");
AU_nPRINT("                                        1 = standard detection not finished                                                         \n");
AU_nPRINT("        SIF_STD_CODE            6:0     SIF Standard Detect Result                                                                  \n");
AU_nPRINT("                                                                                                                                    \n");
AU_nPRINT("                                        00h = standard not found                                                                    \n");
AU_nPRINT("                                        03h = AU_SYS_M                                                                              \n");
AU_nPRINT("                                        04h = AU_SYS_BG_A2                                                                          \n");
AU_nPRINT("                                        05h = AU_SYS_DK1_A2                                                                         \n");
AU_nPRINT("                                        06h = AU_SYS_DK2_A2                                                                         \n");
AU_nPRINT("                                        07h = AU_SYS_DK3_A2                                                                         \n");
AU_nPRINT("                                        08h = AU_SYS_BG_NICAM                                                                       \n");
AU_nPRINT("                                        09h = AU_SYS_DK_NICAM                                                                       \n");
AU_nPRINT("                                        0ah = AU_SYS_I_NICAM                                                                        \n");
AU_nPRINT("                                        0bh = AU_SYS_L_NICAM                                                                        \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DE4h SIF_BTSC_A2_CARRIER     15:0    Default : 0x00  Access : R                                                                  \n");
AU_nPRINT("        RESERVED                15:8    Reserved                                                                                    \n");
AU_nPRINT("        DK3_STATUS              7       If enable DK123_AUTO_CTRL (0x2DCA[7]=1)                                                     \n");
AU_nPRINT("                                        0: Sound Standard is not DK3                                                                \n");
AU_nPRINT("                                        1: Sound Standard is DK3                                                                    \n");
AU_nPRINT("        DK2_STATUS              6       If enable DK123_AUTO_CTRL (0x2DCA[7]=1)                                                     \n");
AU_nPRINT("                                        0: Sound Standard is not DK2                                                                \n");
AU_nPRINT("                                        1: Sound Standard is DK2                                                                    \n");
AU_nPRINT("        SOUND_MOD_STATUS1       5:0     Sound Mod Status1:                                                                          \n");
AU_nPRINT("                                        Bit 0 = BTSC/A2 Mono exist                                                                  \n");
AU_nPRINT("                                        Bit 1 = BTSC/A2 Stereo exist                                                                \n");
AU_nPRINT("                                        Bit 2 = BTSC/A2 Sap/Dual exist                                                              \n");
AU_nPRINT("                                        Bit 3 = A2 Pilot exist                                                                      \n");
AU_nPRINT("                                        Bit 4 = A2 Carrier 1 exis                                                                   \n");
AU_nPRINT("                                        Bit 5 = A2 Carrier 2 exist                                                                  \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT("112DE6h SIF_NICAM_STATUS        15:0    Default : 0x00  Access : R                                                                  \n");
AU_nPRINT("                RESERVED        15:8    Reserved                                                                                    \n");
AU_nPRINT("        SOUND_MOD_STATUS2       7:0     SIF NICAM demodulator automatic sound mode output select                                    \n");
AU_nPRINT("                                        Low 4 bits: NICAM state info                                                                \n");
AU_nPRINT("                                        Bit[3:0] : NICAM Standard MOD Info                                                          \n");
AU_nPRINT("                                        Bit[3:0] = 0x0 = NICAM FRAME_SEARCH State                                                   \n");
AU_nPRINT("                                        Bit[3:0] = 0x1 = NICAM FRAME_PRESYNC0 State                                                 \n");
AU_nPRINT("                                        Bit[3:0] = 0x2 = NICAM FRAME_PRESYNC1 State                                                 \n");
AU_nPRINT("                                        Bit[3:0] = 0x3 = NICAM FRAME_PRESYNC2 State                                                 \n");
AU_nPRINT("                                        Bit[3:0] = 0x4 = NICAM FRAME_PRESYNC3 State                                                 \n");
AU_nPRINT("                                        Bit[3:0] = 0x5 = NICAM LOCK State                                                           \n");
AU_nPRINT("                                                                                                                                    \n");
AU_nPRINT("                                        Bit[6:4]: sound mode info                                                                   \n");
AU_nPRINT("                                                                                                                                    \n");
AU_nPRINT("                                        Bit[6:4] = 0x1 = NICAM Mono                                                                 \n");
AU_nPRINT("                                        Bit[6:4] = 0x2 = NICAM Stereo                                                               \n");
AU_nPRINT("                                        Bit[6:4] = 0x3 = NICAM Dual                                                                 \n");
AU_nPRINT("                                        Bit[6:4] = 0x4 = NICAM Data                                                                 \n");
AU_nPRINT("                                        Bit[7]: Reserved.                                                                           \n");
AU_nPRINT("====================================================================================================================================\n");
AU_nPRINT(" ___________________________________________________                                                                                \n");
AU_nPRINT("|               |           |112D_C0|112D_E4|112D_E6|                                                                               \n");
AU_nPRINT("|  PAL_Type     | Standard  |       |       |       |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("| Mono          |   BG      |04     |10     |       |                                                                               \n");
AU_nPRINT("| A2 Stereo     |   BG      |24     |3B     |       |                                                                               \n");
AU_nPRINT("| A2 Dual       |   BG      |24     |3D     |       |                                                                               \n");
AU_nPRINT("| Hi Dev        |   BG      |14     |10     |       |                                                                               \n");
AU_nPRINT("| Nicam Stereo  |   BG      |48     |       |25     |                                                                               \n");
AU_nPRINT("| Nicam Dual    |   BG      |48     |       |35     |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("| Mono          |   DK1     |05     |10     |       |                                                                               \n");
AU_nPRINT("| A2 Stereo     |   DK1     |25     |3B     |       |                                                                               \n");
AU_nPRINT("| A2 Dual       |   DK1     |25     |3D     |       |                                                                               \n");
AU_nPRINT("| Hi Dev        |   DK1     |15     |10     |       |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("|               | (China)   |       |       |       |                                                                               \n");
AU_nPRINT("| A2 Stereo     |   DK2     |26     |7B     |       |                                                                               \n");
AU_nPRINT("| A2 Dual       |   DK2     |26     |7D     |       |                                                                               \n");
AU_nPRINT("| Nicam Stereo  |   DK1     |49     |       |25     |                                                                               \n");
AU_nPRINT("| Nicam Dual    |   DK1     |49     |       |35     |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("|               | (Factory) |       |       |       |                                                                               \n");
AU_nPRINT("| A2 Stereo:    |   DK3     |27     |BB     |       |                                                                               \n");
AU_nPRINT("| A2 Dual       |   DK3     |27     |BD     |       |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("| Mono          |   I       |0A     |10     |       |                                                                               \n");
AU_nPRINT("| Nicam stereo  |   I       |4A     |       |25     |                                                                               \n");
AU_nPRINT("| Nicam Dual    |   I       |4A     |       |35     |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("| Mono          |   L       |0B     |10     |       |                                                                               \n");
AU_nPRINT("| Nicam stereo  |   L       |4B     |       |25     |                                                                               \n");
AU_nPRINT("| Nicam Dual    |   L       |4B     |       |35     |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("| Mono          |   M       |03     |10     |       |                                                                               \n");
AU_nPRINT("| A2 Stereo     |   M       |23     |3B     |       |                                                                               \n");
AU_nPRINT("| Hidev         |   M       |13     |10     |       |                                                                               \n");
AU_nPRINT("|_______________|___________|_______|_______|_______|                                                                               \n");
AU_nPRINT("====================================================================================================================================\n");
}

//0x9997
void AU_CUS_SIF_Debug(void)
{
    int selNum = 0;
    int i = 0;
    int nUnused = 0;
    nUnused = nUnused;

    while(1)
    {
        AU_nPRINT("\n\n\n");
        AU_nPRINT("----------------------------------------------  \n");
        AU_nPRINT("-----------  SIF debug      ------------------  \n");
        AU_nPRINT("----------------------------------------------  \n");
        AU_nPRINT("(01) Read AMP & NSR & nicam phase error rate    \n");
        AU_nPRINT("(02) MApi_AUDIO_TriggerSifPLL()                 \n");
        AU_nPRINT("(03) AU_CUS_DumpSIFInfo()                       \n");
        AU_nPRINT("----------------------------------------------  \n");
        AU_nPRINT("(9999) Exit                                     \n");
        AU_nPRINT("----------------------------------------------  \n");
        AU_nPRINT("Please input the item number:                   \n");

        selNum = AU_CUS_Debug_GetDec();
        switch(selNum)
        {
            case 9999:
                return;

            case 01:
            {
                selNum = AU_CUS_Debug_GetHex("======= Endless loop? N(0) Y(1) ============ \n");

                if(selNum == 0)
                {
                    int readingTimes;
                    readingTimes = AU_CUS_Debug_GetHex("======= Reding Times? ============ \n");

                    #if 0
                    PAL:   30: AMP
                           3C: NSR
                    NICAM: 41: nicam phase error rate
                    #endif

                    for (i = 0; i < readingTimes; i++)
                    {
                        AU_nPRINT("------------------------------------------------------\n");

                        //PAL AMP
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x3000);
                        usleep(2 * 1000);
                        AU_nPRINT("             [PAL AMP] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));

                        //PAL NSR
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x3C00);
                        usleep(2 * 1000);
                        AU_nPRINT("             [PAL NSR] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));

                        //NICAM Phase error rate
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x4100);
                        usleep(2 * 1000);
                        AU_nPRINT("[NICAM Phase Err Rate] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));
                    }

                }
                else if(selNum == 1)
                {
                    #if 0
                    PAL:   30: AMP
                           3C: NSR
                    NICAM: 41: nicam phase error rate
                    #endif

                    while(1)
                    {
                        AU_nPRINT("------------------------------------------------------\n");

                        //PAL AMP
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x3000);
                        usleep(2 * 1000);
                        AU_nPRINT("             [PAL AMP] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));

                        //PAL NSR
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x3C00);
                        usleep(2 * 1000);
                        AU_nPRINT("             [PAL NSR] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));

                        //NICAM Phase error rate
                        AU_CUS_WriteAbsReg((MS_U32)REG_BANK_ASND_DSP_DBG, (MS_U16)0x4100);
                        usleep(2 * 1000);
                        AU_nPRINT("[NICAM Phase Err Rate] [112DFC]=0x%-4X,[112DFE]=0x%-4X\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2));
                    }
                }
            }
            break;

            case 02:
            {
                MApi_AUDIO_TriggerSifPLL();
            }
            break;

            case 03:
            {
                AU_CUS_DumpSIFInfo();
            }
            break;

            default:
                break;
        }
    }
}

void AU_CUS_Show_R2_Debug_Option(void)
{
    AU_nPRINT("------------------------------------------------------------------ \n");
    AU_nPRINT("-----------  R2 Debug       -------------------------------------- \n");
    AU_nPRINT("------------------------------------------------------------------ \n");
    AU_nPRINT("case 0x10:    print_es_info(R2_ES_ID1);                     break; \n");
    AU_nPRINT("case 0x11:    print_es_info(R2_ES_ID2);                     break; \n");
    AU_nPRINT("case 0x12:    print_pcm_info(R2_ADEC_ID1);                  break; \n");
    AU_nPRINT("case 0x13:    print_pcm_info(R2_ADEC_ID2);                  break; \n");
    AU_nPRINT("case 0x14:    print_dec_info(R2_ADEC_ID1);                  break; \n");
    AU_nPRINT("case 0x15:    print_dec_info(R2_ADEC_ID2);                  break; \n");
    AU_nPRINT("case 0x16:    print_avSync_info(R2_ADEC_ID1);               break; \n");
    AU_nPRINT("case 0x17:    print_avSync_info(R2_ADEC_ID2);               break; \n");
    AU_nPRINT("case 0x18:    printf_PTS_table(R2_ADEC_ID1);                break; \n");
    AU_nPRINT("case 0x19:    printf_PTS_table(R2_ADEC_ID2);                break; \n");
    AU_nPRINT("case 0x1a:    enable_dec_dbgMsg( R2_ADEC_ID1, MS_TRUE );    break; \n");
    AU_nPRINT("case 0x1b:    enable_dec_dbgMsg( R2_ADEC_ID1, MS_FALSE );   break; \n");
    AU_nPRINT("case 0x1c:    enable_dec_dbgMsg( R2_ADEC_ID2, MS_TRUE );    break; \n");
    AU_nPRINT("case 0x1d:    enable_dec_dbgMsg( R2_ADEC_ID2, MS_FALSE );   break; \n");
    AU_nPRINT("case 0x1e:    print_decoder_instance(R2_ADEC_ID1);          break; \n");
    AU_nPRINT("case 0x1f:    print_decoder_instance(R2_ADEC_ID2);          break; \n");
    AU_nPRINT("case 0x20:    printf_spdif_info();                          break; \n");
    AU_nPRINT("case 0x21:    printf_dmaReader_config();                    break; \n");
    AU_nPRINT("case 0x22:    printf_DPGA_config();                         break; \n");
    AU_nPRINT("case 0x23:    printf_security();                            break; \n");
    AU_nPRINT("case 0x24:    print_omx_info(R2_ADEC_ID1);                  break; \n");
    AU_nPRINT("case 0x25:    print_omx_info(R2_ADEC_ID2);                  break; \n");
    AU_nPRINT("case 0x26:    print_es_info(R2_ES_ID3);                     break; \n");
    AU_nPRINT("case 0x27:    print_es_info(R2_ES_ID4);                     break; \n");
    AU_nPRINT("case 0x28:    print_decoder_shmParam(R2_ADEC_ID1);          break; \n");
    AU_nPRINT("case 0x29:    print_decoder_shmParam(R2_ADEC_ID2);          break; \n");
    AU_nPRINT("case 0x30:    print_newMM_info(R2_ADEC_ID1);                break; \n");
    AU_nPRINT("case 0x31:    print_newMM_info(R2_ADEC_ID2);                break; \n");
    AU_nPRINT("case 0x32:    printf_hdmi_info();                           break; \n");
    AU_nPRINT("case 0x33:    printf_wrap_info(R2_ADEC_ID1);                break; \n");
    AU_nPRINT("case 0x34:    printf_wrap_info(R2_ADEC_ID2);                break; \n");
    AU_nPRINT("case 0x36:    printf_AD_avsyncInfo(R2_ADEC_ID1);            break; \n");
    AU_nPRINT("case 0x37:    printf_AD_avsyncInfo(R2_ADEC_ID2);            break; \n");
    AU_nPRINT("case 0x38:    printf_dual_avsyncInfo(R2_ADEC_ID1);          break; \n");
    AU_nPRINT("case 0x39:    printf_dual_avsyncInfo(R2_ADEC_ID2);          break; \n");
    AU_nPRINT("case 0x3A:    printf_pan_fade_Info(R2_ADEC_ID1);            break; \n");
    AU_nPRINT("case 0x3B:    printf_pan_fade_Info(R2_ADEC_ID2);            break; \n");
    AU_nPRINT("case 0x3C:    print_ES_shmInfo(R2_ADEC_ID1);                break; \n");
    AU_nPRINT("case 0x3D:    print_ES_shmInfo(R2_ADEC_ID2);                break; \n");
    AU_nPRINT("case 0x3E:    printf_GST_PTR_NonPCM_Sync_Info();            break; \n");
    AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
    AU_nPRINT("              define MBOX_WORD_R2_SYSTEM_DBG  MBOX_M2D_038A break; \n");
    AU_nPRINT("case 0x8A00:  [ 0] decoder decode frame status              break; \n");
    AU_nPRINT("case 0x8A01:  [ 1] decoder output pcm status                break; \n");
    AU_nPRINT("case 0x8A03:  [ 3] reset measured max AD no signal counter  break; \n");
    AU_nPRINT("case 0x8A04:  [ 4] omx decode done print                    break; \n");
    AU_nPRINT("case 0x8A08:  [ 8] decoder print info                       break; \n");
    AU_nPRINT("case 0x8A09:  [ 9] measure decoder mips                     break; \n");
    AU_nPRINT("case 0x8A10:  [10] measure miu latency                      break; \n");
    AU_nPRINT("case 0x8A12:  [12] disable skip frm when doing AV sync      break; \n");
    AU_nPRINT("case 0x8A13:  [13] disable wait STC when doing AV sync      break; \n");
    AU_nPRINT("case 0x8A14:  [14] disable calculate increase cPTS in timer break; \n");
    AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");

    return;
}

//0x9998
void AU_CUS_RegDebug(void)
{
    int selNum = 0;

    while(1)
    {
        AU_nPRINT("\n\n\n");
        AU_CUS_Show_R2_Debug_Option();
        AU_nPRINT("------------------------------------------------------------------ \n");
        AU_nPRINT("-----------  Register debug -------------------------------------- \n");
        AU_nPRINT("------------------------------------------------------------------ \n");
        AU_nPRINT("(0x0100)   Continuous Read Reg / ASND_DSP DM / ASND_DSP PM / Xbox  \n");
        AU_nPRINT("(0x0101)   Read  Register Bank                                     \n");
        AU_nPRINT("(0x0102)   Read  Register                                          \n");
        AU_nPRINT("(0x0103)   Write Mask Register                                     \n");
        AU_nPRINT("(0x0104)   Read  ASND_DSP DM (ex: 0x40A5)                          \n");
        AU_nPRINT("(0x0105)   Write ASND_DSP DM                                       \n");
        AU_nPRINT("(0x0106)   Read  ASND_DSP PM (ex: 0x1901)                          \n");
        AU_nPRINT("(0x0107)   Write ASND_DSP PM                                       \n");
        AU_nPRINT("(0x0108)   Read  Xbox                                              \n");
        AU_nPRINT("(0x0109)   Write Xbox                                              \n");
        AU_nPRINT("---------------------------------------                            \n");
        AU_nPRINT("(0x9999) Exit                                                      \n");
        AU_nPRINT("---------------------------------------                            \n");
        AU_nPRINT("Please input the item number:                                      \n");

        selNum = AU_CUS_Debug_GetHex("");

        switch(selNum)
        {
            case 0x9999:
                return;

            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1a:
            case 0x1b:
            case 0x1c:
            case 0x1d:
            case 0x1e:
            case 0x1f:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            default:
            {
                MS_U16 orignal_REG_BANK_R2_LOG_DBG;
                MS_U16 orignal_REG_BANK_R2_UART;

                orignal_REG_BANK_R2_LOG_DBG = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_LOG_DBG);
                orignal_REG_BANK_R2_UART    = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_UART);

                AU_nPRINT("orignal_REG_BANK_R2_LOG_DBG = 0x%-4X,\n", orignal_REG_BANK_R2_LOG_DBG);
                AU_nPRINT("orignal_REG_BANK_R2_UART    = 0x%-4X,\n", orignal_REG_BANK_R2_UART);

                REG_BANK_R2_DEC_UART_ENABLE = AU_CUS_Debug_GetHex(AU_R2_UART_ENABLE_MESSAGE);

                int sleepTime;
                sleepTime   = AU_CUS_Debug_GetHex("======= Sleep time: ============ \n");

                //R2 WFI, bit11
                AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_R2_WFI, REG_BANK_R2_WFI_ENABLE, REG_BANK_R2_WFI_ENABLE);

                //Set R2
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART,    (MS_U16)REG_BANK_R2_DEC_UART_ENABLE);
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_LOG_DBG, (MS_U16)selNum); // R2 print msg
                sleep(sleepTime);

                //Recover
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_LOG_DBG, (MS_U16)orignal_REG_BANK_R2_LOG_DBG);
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART,    (MS_U16)orignal_REG_BANK_R2_UART);

            }
            break;

            case 0x8A00:
            case 0x8A01:
            case 0x8A03:
            case 0x8A04:
            case 0x8A08:
            case 0x8A09:
            case 0x8A10:
            case 0x8A12:
            case 0x8A13:
            case 0x8A14:
            {
                switch(selNum)
                {
                    default:
                    case 0x8A00: selNum = 0x0001; break;
                    case 0x8A01: selNum = 0x0002; break;
                    case 0x8A03: selNum = 0x0008; break;
                    case 0x8A04: selNum = 0x0010; break;
                    case 0x8A08: selNum = 0x0100; break;
                    case 0x8A09: selNum = 0x0200; break;
                    case 0x8A10: selNum = 0x0400; break;
                    case 0x8A12: selNum = 0x1000; break;
                    case 0x8A13: selNum = 0x2000; break;
                    case 0x8A14: selNum = 0x4000; break;
                }

                MS_U16 orignal_REG_BANK_R2_SYSTEM_DBG;
                MS_U16 orignal_REG_BANK_R2_UART;

                orignal_REG_BANK_R2_SYSTEM_DBG = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_SYSTEM_DBG);
                orignal_REG_BANK_R2_UART       = AU_CUS_ReadAbsReg((MS_U32)REG_BANK_R2_UART);

                AU_nPRINT("orignal_REG_BANK_R2_SYSTEM_DBG = 0x%-4X,\n", orignal_REG_BANK_R2_SYSTEM_DBG);
                AU_nPRINT("orignal_REG_BANK_R2_UART       = 0x%-4X,\n", orignal_REG_BANK_R2_UART);

                REG_BANK_R2_DEC_UART_ENABLE = AU_CUS_Debug_GetHex(AU_R2_UART_ENABLE_MESSAGE);

                int sleepTime;
                sleepTime   = AU_CUS_Debug_GetHex("======= Sleep time: ============ \n");

                //R2 WFI, bit11
                AU_CUS_WriteAbsMaskReg((MS_U32)REG_BANK_R2_WFI, REG_BANK_R2_WFI_ENABLE, REG_BANK_R2_WFI_ENABLE);

                //Set R2
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART,       (MS_U16)REG_BANK_R2_DEC_UART_ENABLE);
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_SYSTEM_DBG, (MS_U16)selNum); // R2 print msg
                sleep(sleepTime);

                //Recover
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_SYSTEM_DBG, (MS_U16)orignal_REG_BANK_R2_SYSTEM_DBG);
                AU_CUS_WriteAbsReg((MS_U32)REG_BANK_R2_UART,       (MS_U16)orignal_REG_BANK_R2_UART);

            }
            break;

            // Continuous Read
            case 0x0100:
            {
                long int startTime     = 0;
                long int currentTime   = 0;
                long int readingTimeMS = 0;
                int readingTimeSecond  = 0;
                int numberOfItems      = 0;
                int readType           = 0;
                int i                  = 0;
                MS_U32 *readingItems   = NULL;
                MS_BOOL isIDMA = FALSE;

                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("**   Continuous Read                       **                            \n");
                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("(01) Reg                                                                 \n");
                AU_nPRINT("(02) ASND_DSP DM                                                         \n");
                AU_nPRINT("(03) ASND_DSP PM                                                         \n");
                AU_nPRINT("(04) Xbox                                                                \n");

                readType = AU_CUS_Debug_GetDec();
                AU_nPRINT("readType = %d \n", readType);

                AU_nPRINT("======= Number of Items to read: ======= \n");
                numberOfItems = AU_CUS_Debug_GetDec();

                AU_nPRINT("numberOfItems = %d \n", numberOfItems);

                readingItems = (MS_U32 *)AU_CUS_MemoryAlloc(numberOfItems * sizeof(MS_U32));

                for(i = 0; i < numberOfItems; i++)
                {
                    AU_nPRINT("======= Enter Item[%d] (must starts by \"0x\"): ======= \n", i);
                    readingItems[i] = AU_CUS_Debug_GetHex("");
                }

                for(i = 0; i < numberOfItems; i++)
                {
                    AU_nPRINT("Item[%d] = [0x%X] \n", i, (unsigned int)readingItems[i]);
                }

                AU_nPRINT("======= Enter Reading Time (sec): ======= \n");
                readingTimeSecond = AU_CUS_Debug_GetDec();

                AU_nPRINT("readingTimeSecond = %d \n", readingTimeSecond);

                readingTimeMS = (long int)(readingTimeSecond * 1000);

                startTime   = MsOS_GetSystemTime();
                currentTime = startTime;

                AU_nPRINT("======= read by IDMA? (0:FALSE 1: TRUE)  ======= \n");
                selNum = AU_CUS_Debug_GetDec();
                isIDMA = (MS_BOOL)selNum;

                while( ((currentTime - startTime) <= (readingTimeMS)) && (readType <= 4 ) && (readType >= 1 ) )
                {
                    currentTime = MsOS_GetSystemTime();

                    for(i = 0; i < numberOfItems; i++)
                    {
                        switch(readType)
                        {
                            case 1: //Read Reg
                            {
                                AU_nPRINT("Reg[0x%X]=0x%-4X,\n",           (unsigned int)readingItems[i], (unsigned int)AU_CUS_ReadAbsReg((MS_U32)readingItems[i]));
                            }
                            break;

                            case 2: //Read ASND_DSP DM
                            {
                                AU_nPRINT("[ASND_DSP DM][0x%X]=0x%-4X,\n", (unsigned int)readingItems[i], (unsigned int)AU_CUS_ReadDM(AU_DEC_ID3, (MS_U32)readingItems[i], isIDMA));
                            }
                            break;

                            case 3: //Read ASND_DSP PM
                            {
                                AU_nPRINT("[ASND_DSP PM][0x%X]=0x%-4X,\n", (unsigned int)readingItems[i], (unsigned int)AU_CUS_ReadPM(AU_DEC_ID3, (MS_U32) readingItems[i], isIDMA));
                            }
                            break;

                            case 4: //Read Xbox
                            {
                                AU_nPRINT("[Xbox][0x%X]=0x%-4X,\n",        (unsigned int)readingItems[i], (unsigned int)AU_CUS_ReadAbsXbox((MS_U32)readingItems[i]));
                            }
                            break;

                            default:
                                break;

                        }
                    }

                    AU_nPRINT("---------------------------------------------\n");
                    usleep(1 * 1000);
                }
                AU_nPRINT("======= End of Continuous read ======= \n");

            }
            break;

            case 0x0101:
            {
                int intOffset;
                selNum = AU_CUS_Debug_GetHex("======= Read abs bank ex:0x112A bank -> Enter 112A00 ============ \n");
                intOffset = (int)selNum & 0xFFFF00;

                AU_nPRINT("\n\n\n\n");
                AU_CUS_Dump_RegBank(intOffset);
                AU_nPRINT("\n\n\n\n");

            }
            break;

            case 0x0102:
            {
                int intOffset;

                selNum = AU_CUS_Debug_GetHex("======= Read abs register ex:0x112AAC -> Enter 112AAC ============ \n");
                intOffset = (int)selNum;
                                   AU_nPRINT("[0x%X]=0x%-4X,\n", intOffset, AU_CUS_ReadAbsReg((MS_U32)intOffset));

            }
            break;

            case 0x0103:
            {
                int intOffset;
                int Mask;
                selNum = AU_CUS_Debug_GetHex("======= Write abs register ex:0x112AAC -> Enter 0x112AAC ============ \n");
                intOffset = (int)selNum;

                Mask   = AU_CUS_Debug_GetHex("======= Write MASK value: ============ \n");
                selNum = AU_CUS_Debug_GetHex("======= please enter value (0x0 ~ 0xFFFF) ============ \n");
                                   AU_nPRINT("======= Original [0x%X]=0x%-4X,                        \n", intOffset, AU_CUS_ReadAbsReg((MS_U32)intOffset));
                AU_CUS_WriteAbsMaskReg((MS_U32)intOffset, (MS_U16)Mask, (MS_U16)selNum);
                                   AU_nPRINT("======= New      [0x%x]=0x%-4X,                        \n", intOffset, AU_CUS_ReadAbsReg((MS_U32)intOffset));

            }
            break;

            //Read ASND_DSP DM
            case 0x0104:
            {
                int intOffset;
                MS_BOOL isIDMA = FALSE;

                selNum = AU_CUS_Debug_GetHex("======= Read ASND_DSP DM (must starts by \"0x\") =======    \n");
                intOffset = (int)selNum;
                                   AU_nPRINT("======= read by IDMA? (0:FALSE 1: TRUE)  ======= \n");
                selNum = AU_CUS_Debug_GetDec();
                isIDMA = (MS_BOOL)selNum;
                                   AU_nPRINT("[ASND_DSP DM][0x%X]=0x%-4X,\n", intOffset, AU_CUS_ReadDM(AU_DEC_ID3, (MS_U32)intOffset, isIDMA));
            }
            break;

            //Write ASND_DSP DM
            case 0x0105:
            {
                int intOffset, value;
                MS_BOOL isIDMA = FALSE;

                selNum = AU_CUS_Debug_GetHex("======= Write ASND_DSP DM ADDR  (must starts by \"0x\") =======  \n");
                intOffset = (int)selNum;
                selNum = AU_CUS_Debug_GetHex("======= Write ASND_DSP DM Value (must starts by \"0x\") ======= \n");
                value = (int)selNum;
                                   AU_nPRINT("======= write by IDMA? (0:FALSE 1: TRUE)  ======= \n");
                selNum = AU_CUS_Debug_GetDec();
                isIDMA = (MS_BOOL)selNum;
                AU_CUS_WriteDM(AU_DEC_ID3, intOffset, value, isIDMA);
                AU_nPRINT("\n");
            }
            break;

            //Read ASND_DSP PM
            case 0x0106:
            {
                int intOffset;
                MS_BOOL isIDMA = FALSE;

                selNum = AU_CUS_Debug_GetHex("======= Read ASND_DSP PM (must starts by \"0x\") ======= \n");
                intOffset = (int)selNum;
                                   AU_nPRINT("======= read by IDMA? (0:FALSE 1: TRUE)  ======= \n");
                selNum = AU_CUS_Debug_GetDec();
                isIDMA = (MS_BOOL)selNum;
                                   AU_nPRINT("[ASND_DSP PM][0x%X]=0x%-4X,\n", intOffset, AU_CUS_ReadPM(AU_DEC_ID3, (MS_U32)intOffset, isIDMA));
            }
            break;

            //Write ASND_DSP PM
            case 0x0107:
            {
                int intOffset, value;
                MS_BOOL isIDMA = FALSE;

                selNum = AU_CUS_Debug_GetHex("======= Write ASND_DSP PM ADDR  (must starts by \"0x\") =======  \n");
                intOffset = (int)selNum;
                selNum = AU_CUS_Debug_GetHex("======= Write ASND_DSP PM Value (must starts by \"0x\") ======= \n");
                value = (int)selNum;
                                   AU_nPRINT("======= write by IDMA? (0:FALSE 1: TRUE)  ======= \n");
                selNum = AU_CUS_Debug_GetDec();
                isIDMA = (MS_BOOL)selNum;
                AU_CUS_WritePM(AU_DEC_ID3, intOffset, value, isIDMA);
                AU_nPRINT("\n");
            }
            break;

            //Read Xbox
            case 0x0108:
            {
                int intOffset;

                selNum = AU_CUS_Debug_GetHex("======= Read abs Xbox ex:0xB932 -> Enter 0xB932 ============ \n");
                intOffset = (int)selNum;
                                   AU_nPRINT("[Xbox][0x%X]=0x%-4X,\n", intOffset, (unsigned int)AU_CUS_ReadAbsXbox((MS_U32)intOffset));

            }
            break;

            //Write Xbox
            case 0x0109:
            {
                int intOffset;
                selNum = AU_CUS_Debug_GetHex("======= Write abs Xbox ex:0xB932 -> Enter 0xB932 ============ \n");
                intOffset = (int)selNum;
                selNum = AU_CUS_Debug_GetHex("======= please enter value (0x0 ~ 0xFFFF) ============ \n");
                                   AU_nPRINT("======= Original [0x%X]=0x%-4X,                        \n", intOffset, (unsigned int)AU_CUS_ReadAbsXbox((MS_U32)intOffset));
                AU_CUS_WriteAbsXbox((MS_U32)intOffset, (MS_U32)selNum);
                                   AU_nPRINT("======= New      [0x%x]=0x%-4X,                        \n", intOffset, (unsigned int)AU_CUS_ReadAbsXbox((MS_U32)intOffset));

            }
            break;
        }
    }
}

MS_BOOL AU_CUS_SingleFunctionDebugMenu(void)
{
    int arg1=0, arg2=0, arg3=0, arg4=0, arg5=0, arg6=0, arg7=0, arg8=0, arg9=0, arg10=0;

    while(1)
    {
        AU_nPRINT("=========================================== Initialize, STR =====================================================================================================================================                \n");
        AU_nPRINT("(0x0000)API_AUDIO_CUSTOMER_InitializeModule(MS_U32 u32MiuNo, MS_U32 mad_va, API_AUDIO_CUSTOMER_OUTPUT_INFO OutputInfo)                                                                                           \n");
        AU_nPRINT("(0x0001)API_AUDIO_CUSTOMER_InitializeModule_IsFinish(void)                                                                                                                                                       \n");
        AU_nPRINT("(0x0002)API_AUDIO_CUSTOMER_Suspend(void)                                                                                                                                                                         \n");
        AU_nPRINT("(0x0003)API_AUDIO_CUSTOMER_Resume(void)                                                                                                                                                                          \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Connect & Disconnect ================================================================================================================================                \n");
        AU_nPRINT("(0x0100)API_AUDIO_CUSTOMER_SetParserMode(API_AUDIO_CUSTOMER_PARSER_MODE pMode)                                                                                                                                   \n");
        AU_nPRINT("(0x0101)API_AUDIO_CUSTOMER_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect)                                                                                \n");
        AU_nPRINT("(0x0102)API_AUDIO_CUSTOMER_ADEC_Disconnect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect)                                                                                                                         \n");
        AU_nPRINT("(0x0103)API_AUDIO_CUSTOMER_ADC_Connect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)                                                                                      \n");
        AU_nPRINT("(0x0104)API_AUDIO_CUSTOMER_ADC_Disconnect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)                                                                                   \n");
        AU_nPRINT("(0x0105)API_AUDIO_CUSTOMER_PCM_Mixer_Connect(API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect)                                                                 \n");
        AU_nPRINT("(0x0106)API_AUDIO_CUSTOMER_PCM_Mixer_Disconnect(API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect)                                                              \n");
        AU_nPRINT("(0x0107)API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                                \n");
        AU_nPRINT("(0x0108)API_AUDIO_CUSTOMER_CH_Sound_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                             \n");
        AU_nPRINT("(0x0109)API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                                \n");
        AU_nPRINT("(0x010A)API_AUDIO_CUSTOMER_FW_MIXER_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                             \n");
        AU_nPRINT("(0x010B)API_AUDIO_CUSTOMER_SE_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                                      \n");
        AU_nPRINT("(0x010C)API_AUDIO_CUSTOMER_SE_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                                   \n");
        AU_nPRINT("(0x010D)API_AUDIO_CUSTOMER_SNDOUT_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                                  \n");
        AU_nPRINT("(0x010E)API_AUDIO_CUSTOMER_SNDOUT_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                               \n");
        AU_nPRINT("(0x010F)API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                             \n");
        AU_nPRINT("(0x0110)API_AUDIO_CUSTOMER_PCM_CAPTURE_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)                                                                          \n");
        AU_nPRINT("(0x0111)API_AUDIO_CUSTOMER_MP3_ENC_Connect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect)                                                                                                                        \n");
        AU_nPRINT("(0x0112)API_AUDIO_CUSTOMER_MP3_ENC_Disconnect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect)                                                                                                                     \n");
        AU_nPRINT("(0x0113)API_AUDIO_CUSTOMER_AAC_ENC_Connect(API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect)                                                                                                                        \n");
        AU_nPRINT("(0x0114)API_AUDIO_CUSTOMER_AAC_ENC_Disconnect(API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect)                                                                                                                     \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Start & Stop ========================================================================================================================================                \n");
        AU_nPRINT("(0x0200)API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE audioType)                                                                                        \n");
        AU_nPRINT("(0x0201)API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                                \n");
        AU_nPRINT("(0x0202)API_AUDIO_CUSTOMER_StopDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                                 \n");
        AU_nPRINT("(0x0203)API_AUDIO_CUSTOMER_PauseDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                                \n");
        AU_nPRINT("(0x0204)API_AUDIO_CUSTOMER_SetMainDecoderOutput(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                         \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== SPDIF ===============================================================================================================================================                \n");
        AU_nPRINT("(0x0300)API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_MODE eSPDIFMode)                                                                                                                   \n");
        AU_nPRINT("(0x0301)API_AUDIO_CUSTOMER_SPDIF_TX_GetOutputType(void);                                                                                                                                                         \n");
        AU_nPRINT("(0x0302)API_AUDIO_CUSTOMER_SPDIF_TX_SetCopyInfo(API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT copyInfo)                                                                                                                     \n");
        AU_nPRINT("(0x0303)API_AUDIO_CUSTOMER_SPDIF_TX_SetCategoryCode(MS_U8 categoryCode)                                                                                                                                          \n");
        AU_nPRINT("(0x0304)API_AUDIO_CUSTOMER_SPDIF_TX_SetLightOnOff(MS_BOOL bOnOff)                                                                                                                                                \n");
        AU_nPRINT("(0x0305)API_AUDIO_CUSTOMER_SPDIF_TX_SetMonitorOnOff(MS_BOOL bOnOff)                                                                                                                                              \n");
        AU_nPRINT("(0x0306)API_AUDIO_CUSTOMER_SPDIF_TX_ChannelStatus_CTRL(API_AUDIO_CUSTOMER_SPDIF_CS_TYPE cs_mode, API_AUDIO_CUSTOMER_SPDIF_CS_TYPE_STATUS status);                                                                \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== HDMI ================================================================================================================================================                \n");
        AU_nPRINT("(0x0400)API_AUDIO_CUSTOMER_HDMI_RX_GetAudioMode(API_AUDIO_CUSTOMER_HDMI_RX_CODEC_TYPE *pHDMIMode)                                                                                                                \n");
        AU_nPRINT("(0x0401)API_AUDIO_CUSTOMER_HDMI_RX_GetCopyInfo(API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT *pCopyInfo)                                                                                                                    \n");
        AU_nPRINT("(0x0402)API_AUDIO_CUSTOMER_HDMI_RX_SetAudioReturnChannel(MS_BOOL bOnOff)                                                                                                                                         \n");
        AU_nPRINT("(0x0403)API_AUDIO_CUSTOMER_HDMI_RX_SetMonitorOnOff(MS_BOOL bOnOff)                                                                                                                                               \n");
        AU_nPRINT("(0x0404)API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE eHDMIMode)                                                                                                               \n");
        AU_nPRINT("(0x0405)API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff(MS_BOOL bOnOff)                                                                                                                                               \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== ATV =================================================================================================================================================                \n");
        AU_nPRINT("(0x0500)API_AUDIO_CUSTOMER_SIF_SetInputSource(API_AUDIO_CUSTOMER_SIF_INPUT sifSource)                                                                                                                            \n");
        AU_nPRINT("(0x0501)API_AUDIO_CUSTOMER_SIF_SetHighDevMode(API_AUDIO_CUSTOMER_SIF_HIDEV_BW bandwidth, MS_BOOL bOnOff)                                                                                                         \n");
        AU_nPRINT("(0x0502)API_AUDIO_CUSTOMER_SIF_SetAudioStandard(API_AUDIO_CUSTOMER_SIF_STANDARD sifStandard)                                                                                                                     \n");
        AU_nPRINT("(0x0503)API_AUDIO_CUSTOMER_SIF_SetSoundMode(API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE u8SifSoundMode)                                                                                                                \n");
        AU_nPRINT("(0x0504)API_AUDIO_CUSTOMER_SIF_GetSoundMode(void)                                                                                                                                                                \n");
        AU_nPRINT("(0x0505)API_AUDIO_CUSTOMER_SIF_SetMonitorOnOff(MS_BOOL bOnOff)                                                                                                                                                   \n");
        AU_nPRINT("(0x0506)API_AUDIO_CUSTOMER_SIF_SetAutoMute(MS_BOOL bOnOff)                                                                                                                                                       \n");
        AU_nPRINT("(0x0507)API_AUDIO_CUSTOMER_SIF_StartAutoStandardDetection(void)                                                                                                                                                  \n");
        AU_nPRINT("(0x0508)API_AUDIO_CUSTOMER_SIF_SetThreshold(API_AUDIO_CUSTOMER_SIF_THR_TBL_TYPE *ThrTbl)                                                                                                                         \n");
        AU_nPRINT("(0x0509)API_AUDIO_CUSTOMER_SIF_SetPALType(API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type)                                                                                                                              \n");
        AU_nPRINT("(0x050A)API_AUDIO_CUSTOMER_SIF_SendCmd(API_AUDIO_CUSTOMER_SIF_CmdType enAudSifCommand, MS_U8 comm_arg1, MS_U8 comm_arg2)                                                                                         \n");
        AU_nPRINT("(0x050B)API_AUDIO_CUSTOMER_SIF_GetAudioStatus(API_AUDIO_CUSTOMER_SIF_AUDIOSTATUS *eCurrentAudioStatus)                                                                                                           \n");
        AU_nPRINT("(0x050C)API_AUDIO_CUSTOMER_SIF_IsPALType(API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type)                                                                                                                               \n");
        AU_nPRINT("(0x050D)API_AUDIO_CUSTOMER_SIF_SetPrescale(API_AUDIO_CUSTOMER_SIF_GAIN_TYPE gain_type, MS_S32 db_value)                                                                                                          \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Decoder =============================================================================================================================================                \n");
        AU_nPRINT("(0x0600)API_AUDIO_CUSTOMER_SetSyncMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)                                                                                                                  \n");
        AU_nPRINT("(0x0601)API_AUDIO_CUSTOMER_GetDecodingType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE *pAudioType)                                                                                   \n");
        AU_nPRINT("(0x0602)API_AUDIO_CUSTOMER_SetDualMonoOutMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_DUALMONO_MODE outputMode)                                                                              \n");
        AU_nPRINT("(0x0603)API_AUDIO_CUSTOMER_GetESInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, void * pAudioESInfo)                                                                                                               \n");
        AU_nPRINT("(0x0604)API_AUDIO_CUSTOMER_IsESExist(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                                    \n");
        AU_nPRINT("(0x0605)API_AUDIO_CUSTOMER_SetAudioDescription(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)                                                                                                          \n");
        AU_nPRINT("(0x0606)API_AUDIO_CUSTOMER_SetTrickMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_TRICK_MODE eTrickMode)                                                                                       \n");
        AU_nPRINT("(0x0607)API_AUDIO_CUSTOMER_GetBufferStatus(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 *pMaxSize, MS_U32 *pFreeSize)                                                                                         \n");
        AU_nPRINT("(0x0608)API_AUDIO_CUSTOMER_SetAdecPcmPath(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH pcmPath)                                                                                     \n");
        AU_nPRINT("(0x0609)API_AUDIO_CUSTOMER_AdecPcmReady(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                                 \n");
        AU_nPRINT("(0x060A)API_AUDIO_CUSTOMER_AdecPcmGet(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, void * pOutPcm, MS_U32 u32Size)                                                                                                   \n");
        AU_nPRINT("(0x060B)API_AUDIO_CUSTOMER_AdecRegisterDecodeDoneCallback(pfnAudioCustomerAdecDecodeDone pfnDecodeDoneCallBack)                                                                                                  \n");
        AU_nPRINT("(0x060C)API_AUDIO_CUSTOMER_AdecRegisterEndOfStreamCallback(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, pfnAudioCustomerAdecEndOfStream pfnEndOfStreamCallBack)                                                      \n");
        AU_nPRINT("(0x060D)API_AUDIO_CUSTOMER_AdecRegisterUnderrunCallback(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, pfnAudioCustomerAdecUnderrun pfnUnderrunCallBack)                                                               \n");
        AU_nPRINT("(0x060E)API_AUDIO_CUSTOMER_Auto_Recovery_SetMonitorOnOff(MS_BOOL bOnOff)                                                                                                                                         \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Common Decoder ======================================================================================================================================                \n");
        AU_nPRINT("(0x0700)API_AUDIO_CUSTOMER_COMMON_DECODER_Open(void * pData)                                                                                                                                                     \n");
        AU_nPRINT("(0x0701)API_AUDIO_CUSTOMER_COMMON_DECODER_Close(MS_S32 s32DeviceID)                                                                                                                                              \n");
        AU_nPRINT("(0x0702)API_AUDIO_CUSTOMER_COMMON_DECODER_Start(MS_S32 s32DeviceID)                                                                                                                                              \n");
        AU_nPRINT("(0x0703)API_AUDIO_CUSTOMER_COMMON_DECODER_Stop(MS_S32 s32DeviceID)                                                                                                                                               \n");
        AU_nPRINT("(0x0704)API_AUDIO_CUSTOMER_COMMON_DECODER_Set(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)                                                                                    \n");
        AU_nPRINT("(0x0705)API_AUDIO_CUSTOMER_COMMON_DECODER_Get(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)                                                                                    \n");
        AU_nPRINT("(0x0706)API_AUDIO_CUSTOMER_COMMON_DECODER_Read(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)                                                                                                                   \n");
        AU_nPRINT("(0x0707)API_AUDIO_CUSTOMER_COMMON_DECODER_Write(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)                                                                                                                  \n");
        AU_nPRINT("(0x0708)API_AUDIO_CUSTOMER_COMMON_DECODER_Flush(MS_S32 s32DeviceID)                                                                                                                                              \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Common ==============================================================================================================================================                \n");
        AU_nPRINT("(0x0800)API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_PARAM_TYPE paramType, void *pParam)                                                                         \n");
        AU_nPRINT("(0x0801)API_AUDIO_CUSTOMER_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE audioType, API_AUDIO_CUSTOMER_INFO_TYPE infoType, void *pInfo)                                    \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Customized patch ====================================================================================================================================                \n");
        AU_nPRINT("(0x0900)API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_PARAM_TYPE paramType, void *pParam)                                                         \n");
        AU_nPRINT("(0x0901)API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX  adecIndex, API_AUDIO_CUSTOMIZED_PATCH_INFO_TYPE  infoType,  void *pInfo)                                                          \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Clip play for ES ====================================================================================================================================                \n");
        AU_nPRINT("(0x0A00)API_AUDIO_CUSTOMER_PlayClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo, MS_U32 bufSize, void *pBufClip, pfnAudioCustomerAdecoderClipDone pfnCallBack)    \n");
        AU_nPRINT("(0x0A01)API_AUDIO_CUSTOMER_StopClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                              \n");
        AU_nPRINT("(0x0A02)API_AUDIO_CUSTOMER_PauseClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                             \n");
        AU_nPRINT("(0x0A03)API_AUDIO_CUSTOMER_ResumeClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                            \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Clip play for PCM ===================================================================================================================================                \n");
        AU_nPRINT("(0x0B00)API_AUDIO_CUSTOMER_PlayClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)                                                                                                                              \n");
        AU_nPRINT("(0x0B01)API_AUDIO_CUSTOMER_StopClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)                                                                                                                              \n");
        AU_nPRINT("(0x0B02)API_AUDIO_CUSTOMER_PauseClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)                                                                                                                             \n");
        AU_nPRINT("(0x0B03)API_AUDIO_CUSTOMER_ResumeClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)                                                                                                                            \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Gain, Mute & Delay ==================================================================================================================================                \n");
        AU_nPRINT("---Gain---                                                                                                                                                                                                       \n");
        AU_nPRINT("(0x0C00)API_AUDIO_CUSTOMER_SetAudioDescriptionGain(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 gain)                                                                                                         \n");
        AU_nPRINT("(0x0C01)API_AUDIO_CUSTOMER_SetPCMMixerInputGain(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex, MS_U32 gain)                                                                                                          \n");
        AU_nPRINT("(0x0C02)API_AUDIO_CUSTOMER_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_U32 gain)                                                            \n");
        AU_nPRINT("(0x0C03)API_AUDIO_CUSTOMER_SetI2SOutGain(MS_U32 gain)                                                                                                                                                            \n");
        AU_nPRINT("(0x0C04)API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_U32 gain)                                                                                                                \n");
        AU_nPRINT("(0x0C05)API_AUDIO_CUSTOMER_SetSPDIFOutGain(MS_U32 gain)                                                                                                                                                          \n");
        AU_nPRINT("(0x0C06)API_AUDIO_CUSTOMER_SetHDMIOutGain(MS_U32 gain)                                                                                                                                                           \n");
        AU_nPRINT("---Mute---                                                                                                                                                                                                       \n");
        AU_nPRINT("(0x0C07)API_AUDIO_CUSTOMER_SetPCMMixerInputMute(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex, MS_BOOL bOnOff)                                                                                                       \n");
        AU_nPRINT("(0x0C08)API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_BOOL bOnOff)                                                         \n");
        AU_nPRINT("(0x0C09)API_AUDIO_CUSTOMER_SetI2SOutMute(MS_BOOL bOnOff)                                                                                                                                                         \n");
        AU_nPRINT("(0x0C0A)API_AUDIO_CUSTOMER_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL bOnOff)                                                                                                             \n");
        AU_nPRINT("(0x0C0B)API_AUDIO_CUSTOMER_SetSPDIFOutMute(MS_BOOL bOnOff)                                                                                                                                                       \n");
        AU_nPRINT("(0x0C0C)API_AUDIO_CUSTOMER_SetHDMIOutMute(MS_BOOL bOnOff)                                                                                                                                                        \n");
        AU_nPRINT("(0x0C0D)API_AUDIO_CUSTOMER_GetI2SOutMuteStatus(MS_BOOL *pOnOff)                                                                                                                                                  \n");
        AU_nPRINT("(0x0C0E)API_AUDIO_CUSTOMER_GetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL *pOnOff)                                                                                                      \n");
        AU_nPRINT("(0x0C0F)API_AUDIO_CUSTOMER_GetSPDIFOutMuteStatus(MS_BOOL *pOnOff)                                                                                                                                                \n");
        AU_nPRINT("(0x0C10)API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Input(MS_U32 per_50ms, API_AUDIO_CUSTOMER_FWM_INDEX eFWM, API_AUDIO_CUSTOMER_FWM_INPUT eCh)                                                                     \n");
        AU_nPRINT("(0x0C11)API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Output(MS_U32 per_50ms, API_AUDIO_CUSTOMER_OUTPUT_TYPE ePort)                                                                                                   \n");
        AU_nPRINT("---Delay---                                                                                                                                                                                                      \n");
        AU_nPRINT("(0x0C12)API_AUDIO_CUSTOMER_SetChannelDelay(API_AUDIO_CUSTOMER_CH_SOUND ch, MS_U32 delay)                                                                                                                         \n");
        AU_nPRINT("(0x0C13)API_AUDIO_CUSTOMER_SetAudioDelay(MS_U32 delayTime)                                                                                                                                                       \n");
        AU_nPRINT("(0x0C14)API_AUDIO_CUSTOMER_SetSpdifDelay(MS_U32 delayTime)                                                                                                                                                       \n");
        AU_nPRINT("(0x0C15)API_AUDIO_CUSTOMER_SetHdmiDelay(MS_U32 delayTime)                                                                                                                                                        \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== AENC ================================================================================================================================================                \n");
        AU_nPRINT("(0x0D00)API_AUDIO_CUSTOMER_AENC_Start(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat)                                                                                                                         \n");
        AU_nPRINT("(0x0D01)API_AUDIO_CUSTOMER_AENC_Stop(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat)                                                                                                                          \n");
        AU_nPRINT("(0x0D02)API_AUDIO_CUSTOMER_AENC_RegisterCallback(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, pfnAudioCustomerAENCDataHandling pfnCallBack)                                                                \n");
        AU_nPRINT("(0x0D03)API_AUDIO_CUSTOMER_AENC_SetInfo(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, API_AUDIO_CUSTOMER_AENC_INFO info)                                                                                    \n");
        AU_nPRINT("(0x0D04)API_AUDIO_CUSTOMER_AENC_GetInfo(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, API_AUDIO_CUSTOMER_AENC_INFO *pInfo)                                                                                  \n");
        AU_nPRINT("(0x0D05)API_AUDIO_CUSTOMER_AENC_SetGain(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U32 gain)                                                                                                          \n");
        AU_nPRINT("(0x0D06)API_AUDIO_CUSTOMER_AENC_CopyData(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U8 *pDest, MS_U8 *pBufAddr, MS_U32 datasize, MS_U8 *pRStart, MS_U8 *pREnd)                                        \n");
        AU_nPRINT("(0x0D07)API_AUDIO_CUSTOMER_AENC_ReleaseData(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U8 *pBufAddr, MS_U32 datasize)                                                                                 \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== PCM Capture =========================================================================================================================================                \n");
        AU_nPRINT("(0x0E00)API_AUDIO_CUSTOMER_PCM_StartUpload(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect)                                                                                                                  \n");
        AU_nPRINT("(0x0E01)API_AUDIO_CUSTOMER_PCM_StopUpload(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect)                                                                                                                   \n");
        AU_nPRINT("(0x0E02)API_AUDIO_CUSTOMER_PCM_RegisterSendPCMCallback(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, pfnAudioCustomerPCMSending pfnCallBack)                                                              \n");
        AU_nPRINT("(0x0E03)API_AUDIO_CUSTOMER_PCM_SetGain(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, MS_U32 gain)                                                                                                         \n");
        AU_nPRINT("(0x0E04)API_AUDIO_CUSTOMER_PCM_SetMute(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, MS_BOOL bOnOff)                                                                                                      \n");
        AU_nPRINT("(0x0E05)API_AUDIO_CUSTOMER_PCM_SetRequestSizeInMs(MS_U32 request_ms)                                                                                                                                             \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== PCM IO Control ======================================================================================================================================                \n");
        AU_nPRINT("(0x0F00)API_AUDIO_CUSTOMER_PCM_Open(API_AUDIO_CUSTOMER_PCMIO_PARAM *pData)                                                                                                                                       \n");
        AU_nPRINT("(0x0F01)API_AUDIO_CUSTOMER_PCM_Close(MS_S32 s32DeviceId)                                                                                                                                                         \n");
        AU_nPRINT("(0x0F02)API_AUDIO_CUSTOMER_PCM_Start(MS_S32 s32DeviceId)                                                                                                                                                         \n");
        AU_nPRINT("(0x0F03)API_AUDIO_CUSTOMER_PCM_Stop(MS_S32 s32DeviceId)                                                                                                                                                          \n");
        AU_nPRINT("(0x0F04)API_AUDIO_CUSTOMER_PCM_Set(MS_S32 s32DeviceId, MS_U32 u32Cmd, const void *pData)                                                                                                                         \n");
        AU_nPRINT("(0x0F05)API_AUDIO_CUSTOMER_PCM_Get(MS_S32 s32DeviceId, MS_U32 u32Cmd, void *pData)                                                                                                                               \n");
        AU_nPRINT("(0x0F06)API_AUDIO_CUSTOMER_PCM_Read(MS_S32 s32DeviceId, void *pBuf, MS_U32 u32Size)                                                                                                                              \n");
        AU_nPRINT("(0x0F07)API_AUDIO_CUSTOMER_PCM_Write(MS_S32 s32DeviceId, const void *pBuf, MS_U32 u32Size)                                                                                                                       \n");
        AU_nPRINT("(0x0F08)API_AUDIO_CUSTOMER_PCM_Flush(MS_S32 s32DeviceId)                                                                                                                                                         \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== MM New Mode =========================================================================================================================================                \n");
        AU_nPRINT("(0x1000)API_AUDIO_CUSTOMER_GetDDRInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_DDRINFO DDRInfo)                                                                                               \n");
        AU_nPRINT("(0x1001)API_AUDIO_CUSTOMER_MM2_initAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)                                                                                                                              \n");
        AU_nPRINT("(0x1002)API_AUDIO_CUSTOMER_MM2_checkAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_AES_INFO *aes_info)                                                                                      \n");
        AU_nPRINT("(0x1003)API_AUDIO_CUSTOMER_MM2_inputAesFinished(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)                                                                           \n");
        AU_nPRINT("(0x1004)API_AUDIO_CUSTOMER_MM2_AD_initAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)                                                                             \n");
        AU_nPRINT("(0x1005)API_AUDIO_CUSTOMER_MM2_AD_checkAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)                                                                            \n");
        AU_nPRINT("(0x1006)API_AUDIO_CUSTOMER_MM2_AD_inputAesFinished(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)                                                                        \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== MStar Sound Effect ==================================================================================================================================                \n");
        AU_nPRINT("(0x1100)API_AUDIO_CUSTOMER_MSTAR_SE_Enable(API_AUDIO_CUSTOMER_MSTAR_SE_TYPE Type, MS_BOOL bOnOff)                                                                                                                \n");
        AU_nPRINT("(0x1101)API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ(MS_U8 u8band, MS_S8 s8level)                                                                                                                                         \n");
        AU_nPRINT("(0x1102)API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef(API_AUDIO_CUSTOMER_MSTAR_PEQ_COEF *peq_coef)                                                                                                                     \n");
        AU_nPRINT("(0x1103)API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef(API_AUDIO_CUSTOMER_MSTAR_HPF_COEF *hpf_coef)                                                                                                                     \n");
        AU_nPRINT("(0x1104)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE(API_AUDIO_CUSTOMER_MSTAR_AVC_MODE mode)                                                                                                                         \n");
        AU_nPRINT("(0x1105)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL(MS_U16 u16level)                                                                                                                                               \n");
        AU_nPRINT("(0x1106)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin(MS_U16 u16Begin)                                                                                                                                        \n");
        AU_nPRINT("(0x1107)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End(MS_U16 u16End)                                                                                                                                            \n");
        AU_nPRINT("(0x1108)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End(MS_U16 u16End)                                                                                                                                            \n");
        AU_nPRINT("(0x1109)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET(MS_U16 u16offset)                                                                                                                                      \n");
        AU_nPRINT("(0x110A)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime(MS_U8 AvcAT)                                                                                                                                              \n");
        AU_nPRINT("(0x110B)API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime(MS_U8 AvcRT)                                                                                                                                             \n");
        AU_nPRINT("(0x110C)API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL(MS_U16 u16level)                                                                                                                                               \n");
        AU_nPRINT("(0x110D)API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE(MS_U16 Lbalance, MS_U16 Rbalance)                                                                                                                                \n");
        AU_nPRINT("(0x110E)API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold(MS_U16 u16level)                                                                                                                                            \n");
        AU_nPRINT("(0x110F)API_AUDIO_CUSTOMER_MSTAR_SE_GET_NR_Status(void)                                                                                                                                                          \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("=========================================== Advanced Sound Effect ===============================================================================================================================                \n");
        AU_nPRINT("(0x1200)API_AUDIO_CUSTOMER_DTS_SE_Enable(API_AUDIO_CUSTOMER_DTS_SE_TYPE seType)                                                                                                                                  \n");
        AU_nPRINT("(0x1201)API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable(API_AUDIO_CUSTOMER_DTS_SE_UNIT_TYPE seUnit, MS_BOOL bOnOff)                                                                                                 \n");
        AU_nPRINT("(0x1202)API_AUDIO_CUSTOMER_DTS_SE_SetParam(API_AUDIO_CUSTOMER_DTS_SE_PARAM_TYPE param, MS_U32 u32value)                                                                                                          \n");
        AU_nPRINT("(0x1203)API_AUDIO_CUSTOMER_Dolby_DAP_Enable(MS_BOOL bOnOff)                                                                                                                                                      \n");
        AU_nPRINT("(0x1204)API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable(MS_BOOL bOnOff)                                                                                                                                          \n");
        AU_nPRINT("(0x1205)API_AUDIO_CUSTOMER_Dolby_DAP_SetParam(API_AUDIO_CUSTOMER_DOLBY_DAP_PARAM dap_params)                                                                                                                     \n");
        AU_nPRINT("=================================================================================================================================================================================================                \n");
        AU_nPRINT("                                                                                                                                                                                                                 \n");
        AU_nPRINT("(0x9999) exit                                                                                                                                                                                                    \n");
        AU_nPRINT("Select Command (Start from 0x) :                                                                                                                                                                                 \n");

        arg1 = AU_CUS_Debug_GetHex("");
        int nUnused = 0;
        nUnused = nUnused;

        switch(arg1)
        {
            /* Initialize, STR */
            case 0x0000:
            {
                API_AUDIO_CUSTOMER_OUTPUT_INFO OutputInfo;
                API_AUDIO_CUSTOMER_CHIP_PLATFORM chipPlatform;
                MS_U32 adec_pa = 0;
                MS_U32 adec_va = 0;

                memset((void *)(&OutputInfo), 0, sizeof(OutputInfo));

                OutputInfo.SpeakerOut = API_AUDIO_CUSTOMER_I2S_OUTPUT;
                OutputInfo.HpOut = API_AUDIO_CUSTOMER_HP_OUTPUT;
                OutputInfo.ScartOut = API_AUDIO_CUSTOMER_LINEOUT3_OUTPUT;
                OutputInfo.MonitorOut = API_AUDIO_CUSTOMER_LINEOUT0_OUTPUT;

                AU_nPRINT("Chip Platform (0:TV, 1: STB):\n");
                arg2 = AU_CUS_Debug_GetDec();
                chipPlatform = (API_AUDIO_CUSTOMER_CHIP_PLATFORM)arg2;

                adec_pa = MApi_AUDIO_GetDspMadBaseAddr(2);

                adec_va = MsOS_MPool_PA2KSEG1(adec_pa);
                if(adec_va != 0)
                {
                    API_AUDIO_CUSTOMER_InitializeModule(0, adec_va, OutputInfo, chipPlatform);
                    API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
                }
            }
            break;

            case 0x0001:
            {
                AU_nPRINT("InitializeModule_IsFinish (%d) \n", (unsigned int)API_AUDIO_CUSTOMER_InitializeModule_IsFinish() );
            }
            break;

            case 0x0002:
            {
                AU_nPRINT("Suspend: \n");
                API_AUDIO_CUSTOMER_Suspend();
            }
            break;

            case 0x0003:
            {
                AU_nPRINT("Resume: \n");
                API_AUDIO_CUSTOMER_Resume();
            }
            break;

            /* Connect & Disconnect */
            case 0x0100:
            {
                AU_nPRINT("////////////////////////////////////////////////////////////////////////////////\n");
                AU_nPRINT("// mode 0:\n");
                AU_nPRINT("//            AFIFO_0-> ES1\n");
                AU_nPRINT("//            AFIFO_1-> ES2\n");
                AU_nPRINT("//            AFIFO_2-> ES3\n");
                AU_nPRINT("//            AFIFO_3-> ES4\n");
                AU_nPRINT("// mode 1:\n");
                AU_nPRINT("//            AFIFO_2-> ES1\n");
                AU_nPRINT("//            AFIFO_3-> ES2\n");
                AU_nPRINT("//            AFIFO_0-> ES3\n");
                AU_nPRINT("//            AFIFO_1-> ES4\n");
                AU_nPRINT("// mode 2:\n");
                AU_nPRINT("//            AFIFO_1-> ES1\n");
                AU_nPRINT("//            AFIFO_2-> ES2\n");
                AU_nPRINT("//            AFIFO_0-> ES3\n");
                AU_nPRINT("//            AFIFO_3-> ES4\n");
                AU_nPRINT("// mode 3:\n");
                AU_nPRINT("//            AFIFO_0-> ES1\n");
                AU_nPRINT("//            AFIFO_1-> ES2\n");
                AU_nPRINT("//            AFIFO_2-> ES3\n");
                AU_nPRINT("//            AFIFO_3-> ES4\n");
                AU_nPRINT("////////////////////////////////////////////////////////////////////////////////\n");
                AU_nPRINT("mode:\n");

                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_PARSER_MODE pMode = (API_AUDIO_CUSTOMER_PARSER_MODE)arg2;

                API_AUDIO_CUSTOMER_SetParserMode(pMode);
            }
            break;

            case 0x0101:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect   = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg3;

                API_AUDIO_CUSTOMER_ADEC_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x0102:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_ADEC_Disconnect(currentConnect);
            }
            break;

            case 0x0103:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("portNum:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_ADC_IN_PORT portNum       = (API_AUDIO_CUSTOMER_ADC_IN_PORT)arg3;

                API_AUDIO_CUSTOMER_ADC_Connect(currentConnect, portNum);
            }
            break;

            case 0x0104:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("portNum:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_ADC_IN_PORT portNum       = (API_AUDIO_CUSTOMER_ADC_IN_PORT)arg3;

                API_AUDIO_CUSTOMER_ADC_Disconnect(currentConnect, portNum);
            }
            break;

            case 0x0105:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_MIXER_INDEX)arg2;
                API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect   = (API_AUDIO_CUSTOMER_PCM_MIXER_INPUT)arg3;

                API_AUDIO_CUSTOMER_PCM_Mixer_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x0106:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_MIXER_INDEX)arg2;
                API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect   = (API_AUDIO_CUSTOMER_PCM_MIXER_INPUT)arg3;

                API_AUDIO_CUSTOMER_PCM_Mixer_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x0107:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_CH_SOUND currentConnect = (API_AUDIO_CUSTOMER_CH_SOUND)arg2;
                API_AUDIO_CUSTOMER_CH_INPUT inputConnect   = (API_AUDIO_CUSTOMER_CH_INPUT)arg3;

                API_AUDIO_CUSTOMER_CH_Sound_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x0108:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_CH_SOUND currentConnect = (API_AUDIO_CUSTOMER_CH_SOUND)arg2;
                API_AUDIO_CUSTOMER_CH_INPUT inputConnect   = (API_AUDIO_CUSTOMER_CH_INPUT)arg3;

                API_AUDIO_CUSTOMER_CH_Sound_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x0109:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_FWM_INDEX currentConnect = (API_AUDIO_CUSTOMER_FWM_INDEX)arg2;
                API_AUDIO_CUSTOMER_FWM_INPUT inputConnect   = (API_AUDIO_CUSTOMER_FWM_INPUT)arg3;

                API_AUDIO_CUSTOMER_FW_MIXER_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x010A:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_FWM_INDEX currentConnect = (API_AUDIO_CUSTOMER_FWM_INDEX)arg2;
                API_AUDIO_CUSTOMER_FWM_INPUT inputConnect   = (API_AUDIO_CUSTOMER_FWM_INPUT)arg3;

                API_AUDIO_CUSTOMER_FW_MIXER_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x010B:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SE_INDEX currentConnect = (API_AUDIO_CUSTOMER_SE_INDEX)arg2;
                API_AUDIO_CUSTOMER_SE_INPUT inputConnect   = (API_AUDIO_CUSTOMER_SE_INPUT)arg3;

                API_AUDIO_CUSTOMER_SE_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x010C:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SE_INDEX currentConnect = (API_AUDIO_CUSTOMER_SE_INDEX)arg2;
                API_AUDIO_CUSTOMER_SE_INPUT inputConnect   = (API_AUDIO_CUSTOMER_SE_INPUT)arg3;

                API_AUDIO_CUSTOMER_SE_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x010D:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect = (API_AUDIO_CUSTOMER_SOUNDOUT_INDEX)arg2;
                API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect   = (API_AUDIO_CUSTOMER_SOUNDOUT_INPUT)arg3;

                API_AUDIO_CUSTOMER_SNDOUT_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x010E:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect = (API_AUDIO_CUSTOMER_SOUNDOUT_INDEX)arg2;
                API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect   = (API_AUDIO_CUSTOMER_SOUNDOUT_INPUT)arg3;

                API_AUDIO_CUSTOMER_SNDOUT_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x010F:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;
                API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT inputConnect   = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT)arg3;

                API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect(currentConnect, inputConnect);
            }
            break;

            case 0x0110:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;
                API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT inputConnect   = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT)arg3;

                API_AUDIO_CUSTOMER_PCM_CAPTURE_Disconnect(currentConnect, inputConnect);
            }
            break;

            case 0x0111:
            {
                AU_nPRINT("inputConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect = (API_AUDIO_CUSTOMER_MP3_ENC_INPUT)arg2;

                API_AUDIO_CUSTOMER_MP3_ENC_Connect(inputConnect);
            }
            break;

            case 0x0112:
            {
                AU_nPRINT("inputConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect = (API_AUDIO_CUSTOMER_MP3_ENC_INPUT)arg2;

                API_AUDIO_CUSTOMER_MP3_ENC_Disconnect(inputConnect);
            }
            break;

            case 0x0113:
            {
                AU_nPRINT("inputConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect = (API_AUDIO_CUSTOMER_AAC_ENC_INPUT)arg2;

                API_AUDIO_CUSTOMER_AAC_ENC_Connect(inputConnect);
            }
            break;

            case 0x0114:
            {
                AU_nPRINT("inputConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect = (API_AUDIO_CUSTOMER_AAC_ENC_INPUT)arg2;

                API_AUDIO_CUSTOMER_AAC_ENC_Disconnect(inputConnect);
            }
            break;

            /* Start & Stop */
            case 0x0200:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("audioType:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_CODEC_TYPE audioType = (API_AUDIO_CUSTOMER_CODEC_TYPE)arg3;

                API_AUDIO_CUSTOMER_SetCodecType(adecIndex, audioType);
            }
            break;

            case 0x0201:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_StartDecoding(adecIndex);
            }
            break;

            case 0x0202:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_StopDecoding(adecIndex);
            }
            break;

            case 0x0203:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_PauseDecoding(adecIndex);
            }
            break;

            case 0x0204:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_SetMainDecoderOutput(adecIndex);
            }
            break;

            /* SPDIF */
            case 0x0300:
            {
                AU_nPRINT("eSPDIFMode:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bForced:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SPDIF_TX_MODE eSPDIFMode = (API_AUDIO_CUSTOMER_SPDIF_TX_MODE)arg2;

                API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(eSPDIFMode);
            }
            break;

            case 0x0301:
            {
                API_AUDIO_CUSTOMER_SPDIF_TX_MODE Ret = API_AUDIO_CUSTOMER_SPDIF_TX_GetOutputType();

                AU_nPRINT("API_AUDIO_CUSTOMER_SPDIF_TX_MODE: %d\n", Ret);
            }
            break;

            case 0x0302:
            {
                AU_nPRINT("copyInfo:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT copyInfo = (API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT)arg2;

                API_AUDIO_CUSTOMER_SPDIF_TX_SetCopyInfo(copyInfo);
            }
            break;

            case 0x0303:
            {
                AU_nPRINT("categoryCode:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_U8 categoryCode =  (MS_U8)arg2;

                API_AUDIO_CUSTOMER_SPDIF_TX_SetCategoryCode(categoryCode);
            }
            break;

            case 0x0304:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff =  (MS_U8)arg2;

                API_AUDIO_CUSTOMER_SPDIF_TX_SetLightOnOff(bOnOff);
            }
            break;

            case 0x0305:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff =  (MS_U8)arg2;

                API_AUDIO_CUSTOMER_SPDIF_TX_SetMonitorOnOff(bOnOff);
            }
            break;

            case 0x0306:
            {
                AU_nPRINT("SPDIF_CS_TYPE:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("SPDIF_CS_TYPE_STATUS:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SPDIF_CS_TYPE eSPDIFCsType = (API_AUDIO_CUSTOMER_SPDIF_CS_TYPE)arg2;
                API_AUDIO_CUSTOMER_SPDIF_CS_TYPE_STATUS eSPDIFCsTypeStatus = (API_AUDIO_CUSTOMER_SPDIF_CS_TYPE_STATUS)arg3;

                API_AUDIO_CUSTOMER_SPDIF_TX_ChannelStatus_CTRL(eSPDIFCsType, eSPDIFCsTypeStatus);
            }
            break;

            /* HDMI */
            case 0x0400:
            {
                API_AUDIO_CUSTOMER_CODEC_TYPE HDMIMode = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;

                API_AUDIO_CUSTOMER_HDMI_RX_GetAudioMode(&HDMIMode);

                AU_nPRINT("get HDMIMode:%x\n", (unsigned int)HDMIMode);
            }
            break;

            case 0x0401:
            {
                API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT copyInfo = API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT_INVALID;

                API_AUDIO_CUSTOMER_HDMI_RX_GetCopyInfo(&copyInfo);

                AU_nPRINT("get HDMI copyInfo:%x\n", (unsigned int)copyInfo);
            }
            break;

            case 0x0402:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_HDMI_RX_SetAudioReturnChannel(bOnOff);
            }
            break;

            case 0x0403:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_HDMI_RX_SetMonitorOnOff(bOnOff);
            }
            break;

            case 0x0404:
            {
                AU_nPRINT("eHDMIMode:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE eHDMIMode = (API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE)arg2;

                API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(eHDMIMode);
            }
            break;

            case 0x0405:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff(bOnOff);
            }
            break;

            /* ATV */
            case 0x0500:
            {
                AU_nPRINT("sifSource:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_INPUT sifSource = (API_AUDIO_CUSTOMER_SIF_INPUT)arg2;

                API_AUDIO_CUSTOMER_SIF_SetInputSource(sifSource);
            }
            break;

            case 0x0501:
            {
                AU_nPRINT("bandwidth:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("bOnOff:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_HIDEV_BW bandwidth = (API_AUDIO_CUSTOMER_SIF_HIDEV_BW)arg2;
                MS_BOOL bOnOff = (MS_BOOL)arg3;

                API_AUDIO_CUSTOMER_SIF_SetHighDevMode(bandwidth, bOnOff);
            }
            break;

            case 0x0502:
            {
                AU_nPRINT("sifStandard:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_STANDARD sifStandard = (API_AUDIO_CUSTOMER_SIF_STANDARD)arg2;

                API_AUDIO_CUSTOMER_SIF_SetAudioStandard(sifStandard);
            }
            break;

            case 0x0503:
            {
                AU_nPRINT("u8SifSoundMode:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE u8SifSoundMode = (API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE)arg2;

                API_AUDIO_CUSTOMER_SIF_SetSoundMode(u8SifSoundMode);
            }
            break;

            case 0x0504:
            {
                AU_nPRINT("API_AUDIO_CUSTOMER_SIF_GetSoundMode: %d\n", (unsigned int)API_AUDIO_CUSTOMER_SIF_GetSoundMode());
            }
            break;

            case 0x0505:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_SIF_SetMonitorOnOff(bOnOff);
            }
            break;

            case 0x0506:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_SIF_SetAutoMute(bOnOff);
            }
            break;

            case 0x0507:
            {
                AU_nPRINT("SIF_StartAutoStandardDetection:\n");

                API_AUDIO_CUSTOMER_SIF_StartAutoStandardDetection();
            }
            break;

            case 0x0508:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0509:
            {
                AU_nPRINT("pal_type:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type = (API_AUDIO_CUSTOMER_SIF_PAL_TYPE)arg2;

                API_AUDIO_CUSTOMER_SIF_SetPALType(pal_type);
            }
            break;

            case 0x050A:
            {
                AU_nPRINT("enAudSifCommand:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("comm_arg1:\n");
                arg3 = AU_CUS_Debug_GetDec();

                AU_nPRINT("comm_arg2:\n");
                arg4 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_CmdType enAudSifCommand = (API_AUDIO_CUSTOMER_SIF_CmdType)arg2;
                MS_U8 comm_arg1 = (MS_U8)arg3;
                MS_U8 comm_arg2 = (MS_U8)arg4;

                API_AUDIO_CUSTOMER_SIF_SendCmd(enAudSifCommand, comm_arg1, comm_arg2);
            }
            break;

            case 0x050B:
            {
                API_AUDIO_CUSTOMER_SIF_AUDIOSTATUS eCurrentAudioStatus = API_AUDIO_CUSTOMER_SIF_E_STATE_AUDIO_NO_CARRIER;

                API_AUDIO_CUSTOMER_SIF_GetAudioStatus(&eCurrentAudioStatus);

                AU_nPRINT("eCurrentAudioStatus: 0x%x\n", eCurrentAudioStatus);
            }
            break;

            case 0x050C:
            {
                AU_nPRINT("pal_type:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type = (API_AUDIO_CUSTOMER_SIF_PAL_TYPE)arg2;

                AU_nPRINT("API_AUDIO_CUSTOMER_SIF_IsPALType(0x%x): 0x%x\n", pal_type, API_AUDIO_CUSTOMER_SIF_IsPALType(pal_type));
            }
            break;

            case 0x050D:
            {
                AU_nPRINT("gain_type:\n");
                arg2 = AU_CUS_Debug_GetHex("");

                AU_nPRINT("db_value:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_SIF_GAIN_TYPE gain_type = (API_AUDIO_CUSTOMER_SIF_GAIN_TYPE)arg2;
                MS_S32 db_value = (MS_S32)arg3;

                API_AUDIO_CUSTOMER_SIF_SetPrescale(gain_type, db_value);
            }
            break;

            /* Decoder */
            case 0x0600:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_BOOL bOnOff = (MS_BOOL)arg3;

                API_AUDIO_CUSTOMER_SetSyncMode(adecIndex, bOnOff);
            }
            break;

            case 0x0601:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_CODEC_TYPE audioType = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;

                API_AUDIO_CUSTOMER_GetDecodingType(adecIndex, &audioType);

                AU_nPRINT("get audioType:%x\n", (unsigned int)audioType);

            }
            break;

            case 0x0602:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("outputMode:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex     = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_DUALMONO_MODE outputMode = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg3;

                API_AUDIO_CUSTOMER_SetDualMonoOutMode(adecIndex, outputMode);
            }
            break;

            case 0x0603:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                void * pAudioESInfo = NULL;

                API_AUDIO_CUSTOMER_GetESInfo(adecIndex, &pAudioESInfo);
            }
            break;

            case 0x0604:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_IsESExist(adecIndex);

                if(adecIndex == API_AUDIO_CUSTOMER_ADEC0)
                {
                    AU_nPRINT("get g_audio_customer_ADEC0_bESExist:%x\n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_bESExist);
                }
                else if(adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                {
                    AU_nPRINT("get g_audio_customer_ADEC1_bESExist:%x\n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_bESExist);
                }
            }
            break;

            case 0x0605:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_BOOL bOnOff = (MS_BOOL)arg3;

                API_AUDIO_CUSTOMER_SetAudioDescription(adecIndex, bOnOff);
            }
            break;

            case 0x0606:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("eTrickMode:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex  = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_TRICK_MODE eTrickMode = (API_AUDIO_CUSTOMER_TRICK_MODE)arg3;

                API_AUDIO_CUSTOMER_SetTrickMode(adecIndex, eTrickMode);
            }
            break;

            case 0x0607:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_U32 maxSize = 0;
                MS_U32 freeSize = 0;

                API_AUDIO_CUSTOMER_GetBufferStatus(adecIndex, &maxSize, &freeSize);

                AU_nPRINT("get maxSize:%x\n", (unsigned int)maxSize);
                AU_nPRINT("get freeSize:%x\n", (unsigned int)freeSize);
            }
            break;

            case 0x0608:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("path:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_ADEC_PCM_PATH path = (API_AUDIO_CUSTOMER_ADEC_PCM_PATH)arg3;

                API_AUDIO_CUSTOMER_SetAdecPcmPath(adecIndex, path);
            }
            break;

            case 0x0609:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_AdecPcmReady(adecIndex);
            }
            break;

            case 0x060A://need to refine
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                void * pOutPcm = NULL;
                MS_U32 u32Size = 0;

                API_AUDIO_CUSTOMER_AdecPcmGet(adecIndex, pOutPcm, u32Size);
            }
            break;

            case 0x060B://need to refine
            {
                pfnAudioCustomerAdecDecodeDone pfnDecodeDoneCallBack = NULL;

                API_AUDIO_CUSTOMER_AdecRegisterDecodeDoneCallback(pfnDecodeDoneCallBack);
            }
            break;

            case 0x060C:
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x060D:
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x060E:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_Auto_Recovery_SetMonitorOnOff(bOnOff);
            }
            break;

            /* Common Decoder */
            case 0x0700:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0701:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0702:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0703:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0704:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0705:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0706:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0707:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0708:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            /* Common */
            case 0x0800:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("paramType:\n");
                arg3 = AU_CUS_Debug_GetDec();

                AU_nPRINT("Param:\n");
                arg4 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_ADEC_INDEX paramType = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg3;
                void *pParam = &arg4;

                API_AUDIO_CUSTOMER_SetAudioParam(adecIndex, paramType, pParam);
            }
            break;

            case 0x0801:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("infoType:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_INFO_TYPE infoType = (API_AUDIO_CUSTOMER_INFO_TYPE)arg3;

                MS_U32 info = 0;
                API_AUDIO_CUSTOMER_GetAudioInfo(adecIndex, infoType, &info);

                AU_nPRINT("info: %d\n", (unsigned int)info);
            }
            break;

            /* Customized patch */
            case 0x0900:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("paramType:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("Param:\n");
                arg4 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(arg2, arg3, (void*)&arg4);
            }
            break;

            case 0x0901:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            /* Clip Play for ES */
            case 0x0A00:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("repeatNumber:\n");
                arg3 = AU_CUS_Debug_GetDec();
            }
            break;

            case 0x0A01:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_StopClipDecoder(adecIndex);
            }
            break;

            case 0x0A02:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_PauseClipDecoder(adecIndex);
            }
            break;

            case 0x0A03:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_ResumeClipDecoder(adecIndex);
            }
            break;

            /* Clip Play for PCM */
            case 0x0B00:/* need to refine */
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("numOfChannel:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bitPerSample:\n");
                arg4 = AU_CUS_Debug_GetDec();
                AU_nPRINT("samplingFreq:\n");
                arg5 = AU_CUS_Debug_GetDec();
                AU_nPRINT("endianType:\n");
                arg6 = AU_CUS_Debug_GetDec();
                AU_nPRINT("signedType:\n");
                arg7 = AU_CUS_Debug_GetDec();
                AU_nPRINT("repeatNumber:\n");
                arg8 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bufSize:\n");
                arg9 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;
                API_AUDIO_CUSTOMER_CLIP_MIX_PARAM clipInfo;
                MS_U32 bufSize;
                void *pBufClip = NULL;
                pfnAudioCustomerAmixerClipDone pfnCallBack = NULL;
                memset((void *)(&clipInfo), 0, sizeof(clipInfo));

                clipInfo.numOfChannel = (MS_U32)arg3;
                clipInfo.bitPerSample = (MS_U32)arg4;
                clipInfo.samplingFreq = (API_AUDIO_CUSTOMER_SAMPLING_FREQ)arg5;
                clipInfo.endianType   = (API_AUDIO_CUSTOMER_PCM_ENDIAN)arg6;
                clipInfo.signedType   = (API_AUDIO_CUSTOMER_PCM_SIGNED_STATUS)arg7;
                clipInfo.repeatNumber = (MS_U32)arg8;
                bufSize               = (MS_U32)arg9;

                API_AUDIO_CUSTOMER_PlayClipMixer(mixerIndex, clipInfo, bufSize, pBufClip, pfnCallBack);
            }
            break;

            case 0x0B01:
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;

                API_AUDIO_CUSTOMER_StopClipMixer(mixerIndex);
            }
            break;

            case 0x0B02:
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;

                API_AUDIO_CUSTOMER_PauseClipMixer(mixerIndex);
            }
            break;

            case 0x0B03:
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;

                API_AUDIO_CUSTOMER_ResumeClipMixer(mixerIndex);
            }
            break;

            /* Gain, Mute & Delay */
            //---Gain---
            case 0x0C00:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("gain:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_U32 gain = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetAudioDescriptionGain(adecIndex, gain);
            }
            break;

            case 0x0C01:
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("gain:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;
                MS_U32 gain = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetPCMMixerInputGain(mixerIndex, gain);
            }
            break;

            case 0x0C02:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("gain:\n");
                arg4 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_FWM_INDEX currentConnect = (API_AUDIO_CUSTOMER_FWM_INDEX)arg2;
                API_AUDIO_CUSTOMER_FWM_INPUT inputConnect   = (API_AUDIO_CUSTOMER_FWM_INPUT)arg3;
                MS_U32 gain = (MS_U32)arg4;

                API_AUDIO_CUSTOMER_SetFWMixerChannelGain(currentConnect, inputConnect, gain);
            }
            break;

            case 0x0C03:
            {
                AU_nPRINT("gain:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_U32 gain = (MS_U32)arg2;

                API_AUDIO_CUSTOMER_SetI2SOutGain(gain);
            }
            break;

            case 0x0C04:
            {
                AU_nPRINT("lineIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("gain:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex = (API_AUDIO_CUSTOMER_LINE_OUT_IDX)arg2;
                MS_U32 gain = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetLineOutGain(lineIndex, gain);
            }
            break;

            case 0x0C05:
            {
                AU_nPRINT("gain:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_U32 gain = (MS_U32)arg2;

                API_AUDIO_CUSTOMER_SetSPDIFOutGain(gain);
            }
            break;

            case 0x0C06:
            {
                AU_nPRINT("gain:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_U32 gain = (MS_U32)arg2;

                API_AUDIO_CUSTOMER_SetHDMIOutGain(gain);
            }
            break;

            //---Mute---
            case 0x0C07:
            {
                AU_nPRINT("mixerIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex = (API_AUDIO_CUSTOMER_MIXER_INDEX)arg2;
                MS_BOOL bOnOff = (MS_BOOL)arg3;

                API_AUDIO_CUSTOMER_SetPCMMixerInputMute(mixerIndex, bOnOff);
            }
            break;

            case 0x0C08:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("inputConnect:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff:\n");
                arg4 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_FWM_INDEX currentConnect = (API_AUDIO_CUSTOMER_FWM_INDEX)arg2;
                API_AUDIO_CUSTOMER_FWM_INPUT inputConnect   = (API_AUDIO_CUSTOMER_FWM_INPUT)arg3;
                MS_BOOL bOnOff = (MS_BOOL)arg4;

                API_AUDIO_CUSTOMER_SetFWMixerChannelMute(currentConnect, inputConnect, bOnOff);
            }
            break;

            case 0x0C09:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_SetI2SOutMute(bOnOff);
            }
            break;

            case 0x0C0A:
            {
                AU_nPRINT("lineIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex = (API_AUDIO_CUSTOMER_LINE_OUT_IDX)arg2;
                MS_BOOL bOnOff = (MS_BOOL)arg3;

                API_AUDIO_CUSTOMER_SetLineOutMute(lineIndex, bOnOff);
            }
            break;

            case 0x0C0B:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_SetSPDIFOutMute(bOnOff);
            }
            break;

            case 0x0C0C:
            {
                AU_nPRINT("bOnOff:\n");
                arg2 = AU_CUS_Debug_GetDec();

                MS_BOOL bOnOff = (MS_BOOL)arg2;

                API_AUDIO_CUSTOMER_SetHDMIOutMute(bOnOff);
            }
            break;

            case 0x0C0D:
            {
                MS_BOOL onOff = FALSE;

                API_AUDIO_CUSTOMER_GetI2SOutMuteStatus(&onOff);

                AU_nPRINT("onOff:%x\n", onOff);
            }
            break;

            case 0x0C0E:
            {
                AU_nPRINT("lineIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex = (API_AUDIO_CUSTOMER_LINE_OUT_IDX)arg2;
                MS_BOOL onOff = FALSE;

                API_AUDIO_CUSTOMER_GetLineOutMuteStatus(lineIndex, &onOff);
                AU_nPRINT("onOff:%x\n", onOff);

            }
            break;

            case 0x0C0F:
            {
                MS_BOOL onOff = FALSE;

                API_AUDIO_CUSTOMER_GetSPDIFOutMuteStatus(&onOff);

                AU_nPRINT("onOff:%x\n", onOff);
            }
            break;

            case 0x0C10:
            {
                AU_nPRINT("per_50ms:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("eFM :\n");
                arg3 = AU_CUS_Debug_GetDec();

                AU_nPRINT("port:\n");
                arg4 = AU_CUS_Debug_GetDec();

                MS_U32 per_50ms = (MS_U32)arg2;
                API_AUDIO_CUSTOMER_FWM_INDEX eFM = arg3;
                API_AUDIO_CUSTOMER_FWM_INPUT port = arg4;
                API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Input(per_50ms, eFM, port);
            }
            break;

            case 0x0C11:
            {
                AU_nPRINT("per_50ms:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("port:\n");
                arg3 = AU_CUS_Debug_GetDec();

                MS_U32 per_50ms = (MS_U32)arg2;
                API_AUDIO_CUSTOMER_OUTPUT_TYPE port = arg3;
                API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Output(per_50ms, port);
            }
            break;

            //---Delay---
            case 0x0C12:
            {
                AU_nPRINT("channel:(ch5 = 0, ch6 = 1)\n");
                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_CH_SOUND channel = (API_AUDIO_CUSTOMER_CH_SOUND)arg2;

                AU_nPRINT("delayTime:\n");
                arg3 = AU_CUS_Debug_GetDec();
                MS_U32 delayTime = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetChannelDelay(channel, delayTime);
            }
            break;

            case 0x0C13:
            {
                AU_nPRINT("delayTime:\n");
                arg3 = AU_CUS_Debug_GetDec();
                MS_U32 delayTime = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetAudioDelay(delayTime);
            }
            break;

            case 0x0C14:
            {
                AU_nPRINT("delayTime:\n");
                arg3 = AU_CUS_Debug_GetDec();
                MS_U32 delayTime = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetSpdifDelay(delayTime);
            }
            break;

            case 0x0C15:
            {
                AU_nPRINT("delayTime:\n");
                arg3 = AU_CUS_Debug_GetDec();
                MS_U32 delayTime = (MS_U32)arg3;

                API_AUDIO_CUSTOMER_SetHdmiDelay(delayTime);
            }

            /* AENC */
            case 0x0D00:
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;

                API_AUDIO_CUSTOMER_AENC_Start(encFormat);
            }
            break;

            case 0x0D01:
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;

                API_AUDIO_CUSTOMER_AENC_Stop(encFormat);
            }
            break;

            case 0x0D02:
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                pfnAudioCustomerAENCDataHandling pfnCallBack = NULL;

                API_AUDIO_CUSTOMER_AENC_RegisterCallback(encFormat, pfnCallBack);
            }
            break;

            case 0x0D03://need to refine
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                API_AUDIO_CUSTOMER_AENC_INFO info;

                memset((void *)(&info), 0, sizeof(info));

                API_AUDIO_CUSTOMER_AENC_SetInfo(encFormat, info);

            }
            break;

            case 0x0D04://need to refine
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                API_AUDIO_CUSTOMER_AENC_INFO info;

                memset((void *)(&info), 0, sizeof(info));

                API_AUDIO_CUSTOMER_AENC_GetInfo(encFormat, &info);
            }
            break;

            case 0x0D05:
            {
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("enter value 0 ~ 1015\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                MS_U32 gain = (MS_U8)arg3;

                API_AUDIO_CUSTOMER_AENC_SetGain(encFormat, gain);
            }
            break;

            case 0x0D06:/* need to refine */
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                MS_U8 *pDest    = NULL;
                MS_U8 *pBufAddr = NULL;
                MS_U32 datasize = NULL;
                MS_U8 *pRStart  = NULL;
                MS_U8 *pREnd    = NULL;

                API_AUDIO_CUSTOMER_AENC_CopyData(encFormat, pDest, pBufAddr, datasize, pRStart, pREnd);
            }
            break;

            case 0x0D07:/* need to refine */
            {
                AU_nPRINT("encFormat:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat = (API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT)arg2;
                MS_U8 *pBufAddr = NULL;
                MS_U32 datasize = 0;

                API_AUDIO_CUSTOMER_AENC_ReleaseData(encFormat, pBufAddr, datasize);
            }
            break;

            /* PCM Capture */
            case 0x0E00:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;

                API_AUDIO_CUSTOMER_PCM_StartUpload(currentConnect);
            }
            break;

            case 0x0E01:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;

                API_AUDIO_CUSTOMER_PCM_StopUpload(currentConnect);
            }
            break;

            case 0x0E02:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;
                pfnAudioCustomerPCMSending pfnCallBack = NULL;

                API_AUDIO_CUSTOMER_PCM_RegisterSendPCMCallback(currentConnect, pfnCallBack);
            }
            break;

            case 0x0E03:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("enter value 0 ~ 1015\n");
                arg3 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;
                MS_U32 gain = arg3;

                API_AUDIO_CUSTOMER_PCM_SetGain(currentConnect, gain);
            }
            break;

            case 0x0E04:
            {
                AU_nPRINT("currentConnect:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("bOnOff\n");
                arg3 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect = (API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)arg2;
                MS_BOOL bOnOff = arg3;

                API_AUDIO_CUSTOMER_PCM_SetMute(currentConnect, bOnOff);
            }
            break;

            case 0x0E05:
            {
                AU_nPRINT("request_ms:\n");
                arg2 = AU_CUS_Debug_GetDec();
                MS_U32 request_ms = arg2;

                API_AUDIO_CUSTOMER_PCM_SetRequestSizeInMs(request_ms);
            }
            break;

            /* PCM IO Control */
            case 0x0F00:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F01:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F02:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F03:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F04:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F05:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F06:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F07:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            case 0x0F08:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            /* MM New Mode */
            case 0x1000:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("DDRInfo:\n");
                arg3 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_DDRINFO DDRInfo = (API_AUDIO_CUSTOMER_DDRINFO)arg3;

                API_AUDIO_CUSTOMER_GetDDRInfo(adecIndex, DDRInfo);
            }
            break;

            case 0x1001:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_MM2_initAesInfo(adecIndex);
            }
            break;

            case 0x1002:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_AES_INFO *aes_info;

                memset((void *)(&aes_info), 0, sizeof(aes_info));

                API_AUDIO_CUSTOMER_MM2_checkAesInfo(adecIndex, aes_info);
            }
            break;

            case 0x1003:/* need to refine */
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("es_size:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("ptsExist:\n");
                arg4 = AU_CUS_Debug_GetDec();
                AU_nPRINT("pts:\n");
                arg5 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_U32 es_size = (MS_U32)arg3;
                MS_BOOL ptsExist = (MS_BOOL)arg4;
                MS_U64 pts = (MS_U64)arg5;

                API_AUDIO_CUSTOMER_MM2_inputAesFinished(adecIndex, es_size, ptsExist, pts);
            }
            break;

            case 0x1004:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;

                API_AUDIO_CUSTOMER_MM2_AD_initAesInfo(adecIndex);
            }
            break;

            case 0x1005:
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                API_AUDIO_CUSTOMER_AES_INFO *aes_info;

                memset((void *)(&aes_info), 0, sizeof(aes_info));

                API_AUDIO_CUSTOMER_MM2_AD_checkAesInfo(adecIndex, aes_info);
            }
            break;

            case 0x1006:/* need to refine */
            {
                AU_nPRINT("adecIndex:\n");
                arg2 = AU_CUS_Debug_GetDec();
                AU_nPRINT("es_size:\n");
                arg3 = AU_CUS_Debug_GetDec();
                AU_nPRINT("ptsExist:\n");
                arg4 = AU_CUS_Debug_GetDec();
                AU_nPRINT("pts:\n");
                arg5 = AU_CUS_Debug_GetDec();

                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = (API_AUDIO_CUSTOMER_ADEC_INDEX)arg2;
                MS_U32 es_size = (MS_U32)arg3;
                MS_BOOL ptsExist = (MS_BOOL)arg4;
                MS_U64 pts = (MS_U64)arg5;

                API_AUDIO_CUSTOMER_MM2_AD_inputAesFinished(adecIndex, es_size, ptsExist, pts);
            }
            break;

            /* Mstar Sound Effect */
            case 0x1100:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_Enable();
            }
            break;

            case 0x1101:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_GEQ();
            }
            break;

            case 0x1102:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_PEQCoef();
            }
            break;

            case 0x1103:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_HPFCoef();
            }
            break;

            case 0x1104:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_MODE();
            }
            break;

            case 0x1105:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_LEVEL();
            }
            break;

            case 0x1106:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Begin();
            }
            break;

            case 0x1107:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_End();
            }
            break;

            case 0x1108:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_R_MODE_Slope();
            }
            break;

            case 0x1109:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_S_MODE_OFFSET();
            }
            break;

            case 0x110A:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_AttackTime();
            }
            break;

            case 0x110B:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_AVC_ReleaseTime();
            }
            break;

            case 0x110C:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_DRC_LEVEL();
            }
            break;

            case 0x110D:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_BALANCE();
            }
            break;

            case 0x110E:
            {
                AU_CUS_AQ_Tuning_MSTAR_SE_SET_NR_Threshold();
            }
            break;

            case 0x110F:/* need to refine */
            {
                AU_nPRINT("\n");
            }
            break;

            /* Advanced Sound Effect */
            case 0x1200:
            {
                AU_CUS_AQ_Tuning_DTS_SE_Enable();
            }
            break;

            case 0x1201:
            {
                AU_CUS_AQ_Tuning_DTS_SE_ProcessUnit_Enable();
            }
            break;

            case 0x1202:
            {
                AU_CUS_AQ_Tuning_DTS_SE_SetParam();
            }
            break;

            case 0x1203:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_Enable();
            }
            break;

            case 0x1204:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_ProcessUnit_Enable();
            }
            break;

            case 0x1205:
            {
                AU_CUS_AQ_Tuning_Dolby_DAP_SetParam();
            }
            break;

            case 0x9999:
            {
                return TRUE;
            }
            break;

            default:
            {
                return TRUE;
            }
            break;
        }
    }

    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg1  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg1);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg2  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg2);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg3  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg3);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg4  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg4);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg5  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg5);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg6  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg6);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg7  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg7);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg8  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg8);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg9  = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg9);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg10 = %d]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg10);
    AU_nPRINT("[AUDIO][%s] [%s] [%d] [------AUDIO_DEBUG------End] \n\n\n", __FILE__, __FUNCTION__, __LINE__);
}

void AU_CUS_Show_Bifrost_Test_File_Option(void)
{
    char usbMountPathString[256];

    if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport)
    {
        strcpy( usbMountPathString, "/mnt/sda1/");
    }
    else
    {
        strcpy( usbMountPathString, "/media/ext1:/");
    }

    AU_nPRINT("======================= AAC =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/ChID_voices_321_dp_audio1_adts.aac             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/DR_720k_321_HE-AAC.aac                         \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/heaac_v1_v2_sweep_258_ps.aac                   \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/jay.aac                                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/MM_Audio_ESDump_hulu_errorFrame.aac            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/AAC/MM_Audio_ESDump_netflix_glitch.aac             \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= Datmos ===================                       \n");
    AU_nPRINT("%s_Bifrost_Audio_only/Datmos/Datmos_id_obj_voice_ddp.ac3                 \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/Datmos/MM_Audio_ESDump_vudu_atmos.ac3              \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DD =======================                       \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DD/5ch_datarate_640_7_dd_h264.ac3                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DD/5ch_samplerate_44.1k_7_dd_h264.ac3              \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DD/dd.ac3                                          \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DD/Vudu_VS_On_Cutting.ac3                          \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DDP =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/5ch_23fps_datarate_3024_7.ac3                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/8ch_23fps_voices_id_21.ac3                     \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/10k.ac3                                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/AUDIO_026_TC5.ac3                              \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/ch_id.ac3                                      \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/ChID_voices_321_ddp.ac3                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/ddp.ac3                                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP/SR_32k_200_ddp.ac3                             \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DDP_71 ====================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DDP_71/7ch_ddp_25fps_channel_id.ac3                \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP_71/8ch_Ls_Rs_dmx_Lb_Rb.ac3                     \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DDP_71/71.ac3                                      \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DRA =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/14-fl_dra512kbps_71ch_44khz_vbr.dra            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/ID1.0ch_64kbps_48khz_cbr.dra                   \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/ID2.0ch_128kbps_48khz_cbr.dra                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/ID5.1ch_384kbps_48khz_cbr.dra                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/ID7.1ch_512kbps_48khz_cbr.dra                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DRA/m_96khz.dra                                    \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DTS =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DTS/44-1152-32tone-51.dtshd                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTS/44-1152-ChID51.dtshd                           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTS/48-1152-32tone-51.dtshd                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTS/48-1509-ChID51.dtshd                           \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DTSLBR =======================                   \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DTSLBR/4824-256kbps-ChID51.dtshd                   \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTSLBR/LBRS-48-255kbps-ChID51-ed20.dtshd           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTSLBR/LBRS-48-318kbps-10tone-51.dtshd             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTSLBR/LBRS-48-384kbps-10tone-51-ed20.dtshd        \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= DTSXLL =======================                   \n");
    AU_nPRINT("%s_Bifrost_Audio_only/DTSXLL/XLL_384000_96k_24b_DN.dtshd                 \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTSXLL/XLL_768000_48k_16b_DN.dtshd                 \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/DTSXLL/XLL_1509000_192k_16b_DN.dtshd               \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= ES_Bypass =======================                \n");
    AU_nPRINT("%s_Bifrost_Audio_only/ES_Bypass/dd_ESBypass.ac3                          \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/ES_Bypass/ddp_ESBypass.ac3                         \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/ES_Bypass/dts_ESBypass.dts                         \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= FLAC =======================                     \n");
    AU_nPRINT("%s_Bifrost_Audio_only/FLAC/naim-test-2-flac-24-48000.flac                \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/FLAC/surround88.flac                               \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= GAAC =======================                     \n");
    AU_nPRINT("%s_Bifrost_Audio_only/GAAC/ChID_voices_321_dp_audio1_adts.aac            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/GAAC/DR_720k_321_HE-AAC.aac                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/GAAC/heaac_v1_v2_sweep_258_ps.aac                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/GAAC/jay.aac                                       \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= MP3 =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/MP3/32k.mp3                                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/MP3/44k.mp3                                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/MP3/48k.mp3                                        \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= MP3_AD ====================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/MP3_AD/01_Main.mp3                                 \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/MP3_AD/02_AD.mp3                                   \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= MPEG =======================                     \n");
    AU_nPRINT("%s_Bifrost_Audio_only/MPEG/48_224.mpg                                    \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/MPEG/441_128.mpg                                   \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/MPEG/441_224.mpg                                   \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= OGG =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/OGG/IfCloudsKnow.ogg                               \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= RA8 =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/RA8/Cartoon.ra8                                    \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/RA8/Chae_Yeon.ra8                                  \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= WMA =======================                      \n");
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/01-God_Rest_You_Merry_Gentleman.wma            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/9.6Mbps.WMV9.1080p.WMA3.Experience.WMP10.wma   \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/96kbps-10years.wma                             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/background_music.wma                           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/LoveLove-Love.wma                              \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/Rahana_wma10pro_2ch.wma                        \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/thais.wma                                      \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/WMA/wmapro.wma                                     \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT("======================= XPCM =======================                     \n");
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/3_16K_64.wav                                  \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/96k.wav                                       \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/192k.wav                                      \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/aLaw_48khz.wav                                \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-6000.wav             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-8000.wav             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-11025.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-16000.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-22050.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-32000.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-44100.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-48000.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-64000.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-88200.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-96000.wav            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-192000.wav           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-minus20dB-16bit-48000.wav      \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/G5_MPEG2_DVD_LPCM_HD.Club-Alisan.wav          \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/imaadpcm_48khz.wav                            \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/msadpcm_48khz.wav                             \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/NTS_AUDIO-006-TC1.wav                         \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/surround51_48khz.wav                          \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/tone16bit-44100.wav                           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/tone16bit-88200.wav                           \n", usbMountPathString);
    AU_nPRINT("%s_Bifrost_Audio_only/XPCM/uLaw_48khz.wav                                \n", usbMountPathString);
    AU_nPRINT("                                                                         \n");
    AU_nPRINT(" Enter input file path: \n");
}

void AU_CUS_Show_Codec_Type_Option(void)
{
    AU_nPRINT(" Codec type: \n");
    AU_nPRINT(" (01) API_AUDIO_CUSTOMER_CODEC_TYPE_PCM                  \n");
    AU_nPRINT(" (02) API_AUDIO_CUSTOMER_CODEC_TYPE_AC3                  \n");
    AU_nPRINT(" (03) API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3                 \n");
    AU_nPRINT(" (04) API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG                 \n");
    AU_nPRINT(" (05) API_AUDIO_CUSTOMER_CODEC_TYPE_AAC                  \n");
    AU_nPRINT(" (06) API_AUDIO_CUSTOMER_CODEC_TYPE_HEAAC                \n");
    AU_nPRINT(" (07) API_AUDIO_CUSTOMER_CODEC_TYPE_DRA                  \n");
    AU_nPRINT(" (08) API_AUDIO_CUSTOMER_CODEC_TYPE_MP3                  \n");
    AU_nPRINT(" (09) API_AUDIO_CUSTOMER_CODEC_TYPE_DTS                  \n");
    AU_nPRINT(" (10) API_AUDIO_CUSTOMER_CODEC_TYPE_SIF                  \n");
    AU_nPRINT(" (11) API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_BTSC             \n");
    AU_nPRINT(" (12) API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_A2               \n");
    AU_nPRINT(" (13) API_AUDIO_CUSTOMER_CODEC_TYPE_DEFAULT              \n");
    AU_nPRINT(" (14) API_AUDIO_CUSTOMER_CODEC_TYPE_NONE                 \n");
    AU_nPRINT(" (15) API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_HD_MA            \n");
    AU_nPRINT(" (16) API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_EXPRESS          \n");
    AU_nPRINT(" (17) API_AUDIO_CUSTOMER_CODEC_TYPE_DTS_CD               \n");
    AU_nPRINT(" (18) API_AUDIO_CUSTOMER_CODEC_TYPE_WMA                  \n");
    AU_nPRINT(" (19) API_AUDIO_CUSTOMER_CODEC_TYPE_WMA_PRO              \n");
    AU_nPRINT(" (20) API_AUDIO_CUSTOMER_CODEC_TYPE_XPCM                 \n");
    AU_nPRINT(" (21) API_AUDIO_CUSTOMER_CODEC_TYPE_RA8LBR               \n");
    AU_nPRINT(" (22) API_AUDIO_CUSTOMER_CODEC_TYPE_FLAC                 \n");
    AU_nPRINT(" (23) API_AUDIO_CUSTOMER_CODEC_TYPE_VORBIS               \n");
    AU_nPRINT(" (24) API_AUDIO_CUSTOMER_CODEC_TYPE_AMR_NB               \n");
    AU_nPRINT(" (25) API_AUDIO_CUSTOMER_CODEC_TYPE_AMR_WB               \n");
    AU_nPRINT(" (26) API_AUDIO_CUSTOMER_CODEC_TYPE_DolbyTrueHDBypass    \n");
    AU_nPRINT(" (27) API_AUDIO_CUSTOMER_CODEC_TYPE_DVI                  \n");
    AU_nPRINT(" (28) API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass             \n");
}

MS_BOOL AU_CUS_DebugMenu(void)
{
    int arg1=0;
    unsigned int arg2=0, arg3=0, arg4=0, arg5=0, arg6=0, arg7=0, arg8=0, arg9=0, arg10=0;

    while(1)
    {
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0xSHOW) pstAudioCustomerShmData->g_audio_customer_Init_Done                     (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Init_Done);
        AU_nPRINT("(0xSHOW) pstAudioCustomerShmData->g_audio_customer_scanf_bSupport                (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_scanf_bSupport);
        AU_nPRINT("(0xSHOW) pstAudioCustomerShmData->g_audio_customer_Chip_Platform                 (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Chip_Platform);
        AU_nPRINT("(0xSHOW) g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select         (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_SndR2_MS12_Pcmr_Metadata_Select);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0000) pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg      (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg);
        AU_nPRINT("(0x0001) pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg         (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg);
        AU_nPRINT("(0x0002) pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval(%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval);
        AU_nPRINT("(0x0003) pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval      (%d)                                  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval);
        AU_nPRINT("(0x0004) (apiAUDIO / apiAUDIO_V2) g_api_audio_V2_bEnableNonThreadPrintMsg        (%d)                                  \n", (unsigned int)g_api_audio_V2_bEnableNonThreadPrintMsg);
        AU_nPRINT("(0x0005) (apiAUDIO / apiAUDIO_V2) g_api_audio_V2_bEnableThreadPrintMsg           (%d)                                  \n", (unsigned int)g_api_audio_V2_bEnableThreadPrintMsg);
        AU_nPRINT("(0x0006) (apiAUDIO / apiAUDIO_V2) g_api_audio_V2_bEnableReturnPrintMsg           (%d)                                  \n", (unsigned int)g_api_audio_V2_bEnableReturnPrintMsg);
        AU_nPRINT("(0x0007) Disable All Thread Monitor                                                                                    \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0100) [Demo] MP3 Encode                                                                                             \n");
        AU_nPRINT("(0x0101) [Demo] AAC Encode                                                                                             \n");
        AU_nPRINT("(0x0102) [Demo] CLIP Decoder play                                                                                      \n");
        AU_nPRINT("(0x0103) [Demo] PCM Capture                                                                                            \n");
        AU_nPRINT("(0x0104) [Demo] PCM IO write                                                                                           \n");
        AU_nPRINT("(0x0105) [Demo] Play All MM    File (Audio only)                                                                       \n");
        AU_nPRINT("(0x0106) [Demo] Play All MM AD File (Audio only)                                                                       \n");
        AU_nPRINT("(0x0107) [Demo] XPCM-channel mask                                                                                      \n");
        AU_nPRINT("(0x0108) [Demo] HDMI RX Monitor Event                                                                                  \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0200) (0:Sync, 1: Freerun) pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode          (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode);
        AU_nPRINT("(0x0201) (0:Sync, 1: Freerun) pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode          (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode);
        AU_nPRINT("(0x0202) (0:Line, 1: RF)      pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode);
        AU_nPRINT("(0x0203) (0:LIne, 1: RF)      pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode);
        AU_nPRINT("(0x0204) (0:LTRT, 1: LORO)    pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode  (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode);
        AU_nPRINT("(0x0205) (0:LTRT, 1: LORO)    pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode  (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode);
        AU_nPRINT("(0x0206) (0:LR,   1:LL, 2:RR) pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode      (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode);
        AU_nPRINT("(0x0207) (0:LR,   1:LL, 2:RR) pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode      (%d)                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0300) [DBG]  AV Sync status                                                                                         \n");
        AU_nPRINT("(0x0301) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay);
        AU_nPRINT("(0x0302) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable             (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable);
        AU_nPRINT("(0x0303) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out          (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out);
        AU_nPRINT("(0x0304) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out       (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out);
        AU_nPRINT("(0x0305) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out       (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out);
        AU_nPRINT("(0x0306) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out       (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out);
        AU_nPRINT("(0x0307) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out       (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out);
        AU_nPRINT("(0x0308) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out        (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out);
        AU_nPRINT("(0x0309) [DBG]  pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out         (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out);
        AU_nPRINT("(0x0310) [DBG]  Audio dump info                                                                                        \n");
        AU_nPRINT("(0x0311) [DBG]  Se-DSP  force encode without main sound                                                                \n");
        AU_nPRINT("(0x0312) [DBG]  ASND-R2 force encode without main sound                                                                \n");
        AU_nPRINT("(0x0313) [DBG]  AU_CUS_SetSourceInfo (%d)                                                                              \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_SetSourceInfo_eSourceType);
        AU_nPRINT("(0x0314) [DBG]  AU_CUS_InputSwitch   (%d, %d)                                                                          \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enSource, (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_InputSwitch_enGroup);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0400) pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff      (%d)                                     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff);
        AU_nPRINT("(0x0401) pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff       (%d)                                     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff);
        AU_nPRINT("(0x0402) pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff       (%d)                                     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff);
        AU_nPRINT("(0x0403) pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff           (%d)                                     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff);
        AU_nPRINT("(0x0404) pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff (%d)                                     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0500) AU_CUS_MuteDuringLimitedTime_Output(per_50ms, ePort)                                                          \n");
        AU_nPRINT("(0x0501) AU_CUS_MuteDuringLimitedTime_Input(per_50ms, eFWM, eCh)                                                       \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0600) pstAudioCustomerShmData->g_audio_customer_AU_ClipDecoderMonitor_Interval            (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_ClipDecoderMonitor_Interval);
        AU_nPRINT("(0x0601) pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval              (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval);
        AU_nPRINT("(0x0602) pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval                (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval);
        AU_nPRINT("(0x0603) pstAudioCustomerShmData->g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval);
        AU_nPRINT("(0x0604) pstAudioCustomerShmData->g_audio_customer_AU_AdecPcmOut_Interval                    (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AdecPcmOut_Interval);
        AU_nPRINT("(0x0605) pstAudioCustomerShmData->g_audio_customer_AU_PCMCapture_Interval                    (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_PCMCapture_Interval);
        AU_nPRINT("(0x0606) pstAudioCustomerShmData->g_audio_customer_AU_EndOfStreamMonitor_Interval            (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_EndOfStreamMonitor_Interval);
        AU_nPRINT("(0x0607) pstAudioCustomerShmData->g_audio_customer_AU_AdecUnderrun_Interval                  (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AdecUnderrun_Interval);
        AU_nPRINT("(0x0608) pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval);
        AU_nPRINT("(0x0609) pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_SetMute_Delay                 (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_SetMute_Delay);
        AU_nPRINT("(0x0610) g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time         (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time);
        AU_nPRINT("(0x0611) g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time        (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time);
        AU_nPRINT("(0x0612) pstAudioCustomerShmData->g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay       (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay);
        AU_nPRINT("(0x0613) pstAudioCustomerShmData->g_audio_customer_AU_CUS_PauseDecoding_Delay                (%d) ms                   \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_CUS_PauseDecoding_Delay);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0700) Input Source Change                                                                                           \n");
        AU_nPRINT("(0x0701) pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MM_ES1_bEnable        (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MM_ES1_bEnable);
        AU_nPRINT("(0x0702) pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable          (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable);
        AU_nPRINT("(0x0703) pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable      (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable);
        AU_nPRINT("(0x0704) pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable);
        AU_nPRINT("(0x0705) pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable      (%d)                      \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable);
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0800) SPDIF / HDMI TX Output Type                                                                                   \n");
        AU_nPRINT("(0x0801) HDMI ARC Enable                                                                                               \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x0900) MStar AVC (HDMI)                                                                                              \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x7202) log Audio Path                                                                                                \n");
        AU_nPRINT("(0x8888) Enable nDBG log in file                                                                                       \n");
        AU_nPRINT("(0x4444) Close  nDBG log in file                                                                                       \n");
        AU_nPRINT("(0x1111) Refresh menu                                                                                                  \n");
        AU_nPRINT("(0x1234) AU_CUS_SingleFunctionDebugMenu()                                                                              \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("(0x9990) AU_CUS_Show_HashKey_Support()                                                                                 \n");
        AU_nPRINT("(0x9991) AU_CUS_AQ_Tuning_and_Dump_Data()                                                                              \n");
        AU_nPRINT("(0x9992) AU_CUS_MCU_DUMP_R2_LOG()                                                                                      \n");
        AU_nPRINT("(0x9993) AU_CUS_Where_Am_I()                                                                                           \n");
        AU_nPRINT("(0x9994) AU_CUS_DDR_Dump_Debug()                                                                                       \n");
        AU_nPRINT("(0x9995) AU_CUS_Dump_Audio_Related_Bank()                                                                              \n");
        AU_nPRINT("(0x9996) AU_CUS_SHOW_ALL_VERSION()                                                                                     \n");
        AU_nPRINT("(0x9997) AU_CUS_SIF_Debug()                                                                                            \n");
        AU_nPRINT("(0x9998) AU_CUS_RegDebug()                                                                                             \n");
        AU_nPRINT("(0x9999) EXIT                                                                                                          \n");
        AU_nPRINT("==========================================================================================                             \n");
        AU_nPRINT("Please enter debug[Function arg2 arg3 arg4 arg5] => 0x1 0x1...                                                         \n");
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [------AUDIO_DEBUG------Begin] \n\n\n", __FILE__, __FUNCTION__, __LINE__);

        arg1 = AU_CUS_Debug_GetHex("");
        int nUnused = 0;
        nUnused = nUnused;

        switch(arg1)
        {
            case 0x0000:
            {
                AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg: \n");
                arg2 = AU_CUS_Debug_GetDec();

                pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = (MS_BOOL)arg2;
            }
            break;

            case 0x0001:
            {
                AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg: \n");
                arg2 = AU_CUS_Debug_GetDec();

                pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg = (MS_BOOL)arg2;
            }
            break;

            case 0x0002:
            {
                AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval: \n");
                arg2 = AU_CUS_Debug_GetDec();

                pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg_Interval = (MS_BOOL)arg2;
            }
            break;

            case 0x0003:
            {
                AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval: \n");
                arg2 = AU_CUS_Debug_GetDec();

                pstAudioCustomerShmData->g_audio_customer_bThreadPrintMsg_Interval = (MS_BOOL)arg2;
            }
            break;

            case 0x0004:
            {
                AU_nPRINT("g_api_audio_V2_bEnableNonThreadPrintMsg: \n");
                arg2 = AU_CUS_Debug_GetDec();

                g_api_audio_V2_bEnableNonThreadPrintMsg = (MS_U8)arg2;
            }
            break;

            case 0x0005:
            {
                AU_nPRINT("g_api_audio_V2_bEnableThreadPrintMsg: \n");
                arg2 = AU_CUS_Debug_GetDec();

                g_api_audio_V2_bEnableThreadPrintMsg = (MS_U8)arg2;
            }
            break;

            case 0x0006:
            {
                AU_nPRINT("g_api_audio_V2_bEnableReturnPrintMsg: \n");
                arg2 = AU_CUS_Debug_GetDec();

                g_api_audio_V2_bEnableReturnPrintMsg = (MS_U8)arg2;
            }
            break;

            case 0x0007:
            {
                AU_nPRINT("DisableAllThreadMonitor... \n");
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_ClipDecoderMonitor_bEnable                         = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_MP3EncodeMonitor_bEnable                           = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_MonitorService_bEnable                             = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_AACEncodeMonitor_bEnable                           = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_MuteDuringLimitedTime_Monitor_bEnable              = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_AdecPcmOutMonitor_bEnable                          = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_PCMCaptureMonitor_bEnable                          = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_EndOfStreamMonitor_bEnable                         = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_Underrun_Monitor_bEnable                      = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_PATCH_Dump_R2_Log_Monitor_bEnable                  = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_Auto_Audio_Delay_Monitor_bEnable    = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_General_Dump_Buffer_Monitor_bEnable = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_DDP_71_Auto_Bypass_Monitor_bEnable  = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_INTERNAL_PATCH_R2_Active_Monitor_bEnable           = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_AD_Play_Monitor_bEnable           = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_MM_New_Mode_Play_Monitor_bEnable              = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_Demo_PCMIO_Play_Monitor_bEnable                    = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_AV_Sync_Info_Monitor_bEnable                       = FALSE;
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_ThreadPrintMsg_Monitor_bEnable                     = FALSE;
            }
            break;

            case 0x0100:
            {
                int selNum_mp3Enc = 0;
                while(selNum_mp3Enc != 0x9999)
                {
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**             MP3_ENCODE                  **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("0x01 Start                                                               \n");
                    AU_nPRINT("0x02 Stop                                                                \n");
                    AU_nPRINT("9999 Exit                                                                \n");
                    selNum_mp3Enc = AU_CUS_Debug_GetHex("");

                    switch(selNum_mp3Enc)
                    {
                        case 0x01:
                        {
                            //Mp3 enc connect
                            API_AUDIO_CUSTOMER_MP3_ENC_Connect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT_CH5);

                            //Mp3 enc start
                            API_AUDIO_CUSTOMER_AENC_Start(API_AUDIO_CUSTOMER_AENC_ENCODE_MP3);
                        }
                        break;

                        case 0x02:
                        {
                            //Mp3 enc Stop
                            API_AUDIO_CUSTOMER_AENC_Stop(API_AUDIO_CUSTOMER_AENC_ENCODE_MP3);

                            //Mp3 enc disconnect
                            API_AUDIO_CUSTOMER_MP3_ENC_Disconnect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT_CH5);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0101:
            {
            #if (UTPA_SUPPORT_AAC_ENCODE == 1)
                int selNum_aacEnc = 0;
                while(selNum_aacEnc != 0x9999)
                {
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**   AAC Encode                            **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("0x01 Start                                                               \n");
                    AU_nPRINT("0x02 Stop                                                                \n");
                    AU_nPRINT("9999 Exit                                                                \n");
                    selNum_aacEnc = AU_CUS_Debug_GetHex("");

                    switch(selNum_aacEnc)
                    {
                        case 0x01:
                        {
                            //PCM capture connect
                            API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect(API_AUDIO_CUSTOMER_PCM_CAPTURE1, API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH5);

                            //aac enc connect
                            API_AUDIO_CUSTOMER_AAC_ENC_Connect(API_AUDIO_CUSTOMER_AAC_ENC_INPUT_PCM_CAPTURE1);

                            //aac enc setup gain
                            API_AUDIO_CUSTOMER_AENC_SetGain(API_AUDIO_CUSTOMER_AENC_ENCODE_AAC, (MS_U32)919);//0dB

                            //aac enc start
                            API_AUDIO_CUSTOMER_AENC_Start(API_AUDIO_CUSTOMER_AENC_ENCODE_AAC);
                        }
                        break;
                        case 0x02:
                        {
                            //aac enc Stop
                            API_AUDIO_CUSTOMER_AENC_Stop(API_AUDIO_CUSTOMER_AENC_ENCODE_AAC);
                        }
                        break;
                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            #endif
            }
            break;

            case 0x0102:
            {
                int selNum_clipDec = 0;
                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = API_AUDIO_CUSTOMER_ADEC0;
                MS_U32 repeatNum = 1;

                while(selNum_clipDec != 0x9999)
                {
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**   CLIP Decoder play                     **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("0x01 Start                                                               \n");
                    AU_nPRINT("0x02 Stop                                                                \n");
                    AU_nPRINT("0x03 Pause                                                               \n");
                    AU_nPRINT("0x04 Resume                                                              \n");
                    AU_nPRINT("9999 Exit                                                                \n");
                    selNum_clipDec = AU_CUS_Debug_GetHex("");

                    switch(selNum_clipDec)
                    {
                        case 0x01:
                        {
                            API_AUDIO_CUSTOMER_CH_INPUT chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;

                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                switch(adecIndex)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC0:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC1:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
                                    }
                                    break;

                                    default:
                                        break;
                                }

                                AU_nPRINT(" Enter repeat time \n");
                                repeatNum = AU_CUS_Debug_GetHex("");

                                //Connect ADEC
                                API_AUDIO_CUSTOMER_ADEC_Connect(adecIndex, API_AUDIO_CUSTOMER_ADEC_INPUT_CLIP);

                                //Set Codec Type
                                API_AUDIO_CUSTOMER_SetCodecType(adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG);

                                //CH5 input connect
                                API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, chInput);

                                //FW mixer0 connect
                                API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                                //FW mixer0 channel unmute
                                API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);

                                //Play clip decoder
                                API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo;
                                pfnAudioCustomerAdecoderClipDone pfnCallBack;

                                AU_UNUSED(clipInfo);
                                AU_UNUSED(pfnCallBack);

                                clipInfo.clipType = API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG;
                                clipInfo.repeatNumber = repeatNum;
                                pfnCallBack = &API_AUDIO_CUSTOMER_StopClipDecoder;

                                //API_AUDIO_CUSTOMER_PlayClipDecoder(adecIndex, clipInfo, MPEG_BIN_SIZE, (void *)mpeg_bin_var, pfnCallBack);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x02:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Stop clip decoder
                                API_AUDIO_CUSTOMER_StopClipDecoder(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x03:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Pause clip decoder
                                API_AUDIO_CUSTOMER_PauseClipDecoder(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x04:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Resume clip decoder
                                API_AUDIO_CUSTOMER_ResumeClipDecoder(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0103:
            {
                int selNum = -1;
                int PCMCapture_Index = -1;
                int PCMCapture_Input = -1;
                int PCMCapture_Source_Dump_To_File_bEnable  = 0;
                MS_U32 request_ms = 50;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                                                                    \n");
                    AU_nPRINT("**             PCM_CAPTURE                 **                                                                    \n");
                    AU_nPRINT("=============================================                                                                    \n");
                    AU_nPRINT("(SHOW) selNum_PCMCapture_Index (%d)                                                                              \n", PCMCapture_Index);
                    AU_nPRINT("(SHOW) selNum_PCMCapture_Input (%d)                                                                              \n", PCMCapture_Input);
                    AU_nPRINT("(SHOW) pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable (%d)                    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable);
                    AU_nPRINT("(SHOW) pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte        (%d)  request_ms*48*2*2 \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte);
                    AU_nPRINT("=============================================                                                                    \n");
                    AU_nPRINT("0x01 Start                                                                                                       \n");
                    AU_nPRINT("0x02 Stop                                                                                                        \n");
                    AU_nPRINT("9999 Exit                                                                                                        \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01:
                        {
                            AU_nPRINT(" Capture Index (0~2: Capture 0~2) \n");
                            PCMCapture_Index = AU_CUS_Debug_GetHex("");

                            AU_nPRINT(" Capture Input (0~7) \n");
                            AU_nPRINT(" 0: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH5         \n");
                            AU_nPRINT(" 1: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH6         \n");
                            AU_nPRINT(" 2: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH7         \n");
                            AU_nPRINT(" 3: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_CH8         \n");
                            AU_nPRINT(" 4: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM         \n");
                            AU_nPRINT(" 5: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM_DELAY   \n");
                            AU_nPRINT(" 6: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_PCM_SE      \n");
                            AU_nPRINT(" 7: API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_MIXER       \n");
                            PCMCapture_Input = AU_CUS_Debug_GetHex("");

                            AU_nPRINT(" Capture source dump to file (for debuging check) (0: No, 1: Yes) \n");
                            PCMCapture_Source_Dump_To_File_bEnable = AU_CUS_Debug_GetHex("");
                            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable = (MS_BOOL)PCMCapture_Source_Dump_To_File_bEnable;

                            AU_nPRINT(" Set Request Size In Ms: \n");
                            request_ms = AU_CUS_Debug_GetDec();

                            //PCM capture Set Request size in MS
                            API_AUDIO_CUSTOMER_PCM_SetRequestSizeInMs(request_ms);

                            //PCM capture connect
                            API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect((API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)PCMCapture_Index, (API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT)PCMCapture_Input);

                            //Setup callback function
                            API_AUDIO_CUSTOMER_PCM_RegisterSendPCMCallback((API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)PCMCapture_Index, (pfnAudioCustomerPCMSending)&AU_CUS_Demo_PCM_Capture_CallBackFun);

                            //PCM capture setup gain
                            API_AUDIO_CUSTOMER_PCM_SetGain((API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)PCMCapture_Index, (MS_U32)919);//0dB

                            //PCM start upload
                            API_AUDIO_CUSTOMER_PCM_StartUpload((API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX)PCMCapture_Index);
                        }
                        break;

                        case 0x02:
                        {
                            //PCM Stop
                            API_AUDIO_CUSTOMER_PCM_StopUpload(API_AUDIO_CUSTOMER_PCM_CAPTURE0);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0104:
            {
                int    selNum = 0;
                int    SampleRate = 0;
                char*  pInput_File_Name = NULL;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**             PCM IO Write                **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("0x01 Start                                                               \n");
                    AU_nPRINT("0x02 Stop                                                                \n");
                    AU_nPRINT("9999 Exit                                                                \n");

                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01:
                        {
                            char usbMountPathString[256];

                            if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport)
                            {
                                strcpy( usbMountPathString, "/mnt/sda1/");
                            }
                            else
                            {
                                strcpy( usbMountPathString, "/media/ext1:/");
                            }

                            AU_nPRINT("======================= PCM-IO =======================                       \n");
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/5000Hz_0dB-16bit-48000_tone.wav                   \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-6000.wav                 \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-8000.wav                 \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-11025.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-16000.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-22050.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-32000.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-44100.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-48000.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-64000.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-88200.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-96000.wav                \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-0dB-16bit-192000.wav               \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/XPCM/Cool_Edit_tone-minus20dB-16bit-48000.wav          \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/PCMIO/MoodyLoop.wav                                    \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/PCMIO/NTS_AUDIO-006-TC1.pcm                            \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/PCMIO/OUT2.wav                                         \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/PCMIO/PCM_48KHz_16bit_stereo.pcm                       \n", usbMountPathString);
                            AU_nPRINT("%s_Bifrost_Audio_only/PCMIO/Sine.pcm                                         \n", usbMountPathString);

                            AU_nPRINT(" Enter input file path: \n");
                            pInput_File_Name = AU_CUS_Debug_GetString();

                            //handle audio input file
                            pAU_debug_input_file2 = AU_CUS_FileOpen(pInput_File_Name, "rb");
                            if (pAU_debug_input_file2 == NULL)
                            {
                                AU_nPRINT("Open file FAIL!!\n");
                                break;
                            }
                            fseek(pAU_debug_input_file2, 0, SEEK_END);
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length = ftell(pAU_debug_input_file2);
                            rewind(pAU_debug_input_file2);
                            AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length = %d\n", pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length);

                            //copy input file to readin buffer
                            MS_U32 WrtBytes;
                            AU_UNUSED(WrtBytes);
                            AU_Demo_MM_File_read_in_buffer2 = AU_CUS_MemoryAlloc(pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length);
                            WrtBytes = fread(AU_Demo_MM_File_read_in_buffer2, 1, pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_input_file_length, pAU_debug_input_file2);

                            AU_nPRINT("Sample Rate (44100, 48000, 88200, 96000...): \n");
                            SampleRate = AU_CUS_Debug_GetDec();

                            AU_nPRINT("Enter repeat time: \n");
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_repeatNum = AU_CUS_Debug_GetHex("");

                            memset((void *)&pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam, 0x00, sizeof(API_AUDIO_CUSTOMER_PCMIO_PARAM));
                            strcpy((char*)pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u8Name, AU_HW_DMA_READER1);
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32BigEndian       = 0;
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32BitWidth        = 16;
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32BufferDuration  = 80;
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32Channel         = 2;
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u32SampleRate      = SampleRate;
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_pcmParam.u8MultiChFlag      = 0;

                            //Enable PCMIO play monitor
                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay = API_AUDIO_CUSTOMER_UPPER_PLAY;
                        }
                        break;

                        case 0x02:
                        {
                            MS_S32 s32DeviceId = 0;

                            AU_nPRINT(" Enter Device ID \n");
                            s32DeviceId = AU_CUS_Debug_GetDec();

                            pstAudioCustomerShmData->g_audio_customer_AU_Demo_PCMIO_UpperPlay = API_AUDIO_CUSTOMER_UPPER_STOP;

                            AU_CUS_FileClose(pAU_debug_input_file2);
                            AU_CUS_MemoryFree((void *)AU_Demo_MM_File_read_in_buffer2);

                            API_AUDIO_CUSTOMER_PCM_Stop(s32DeviceId);
                            API_AUDIO_CUSTOMER_PCM_Flush(s32DeviceId);
                            API_AUDIO_CUSTOMER_PCM_Close(s32DeviceId);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0105:
            {
                API_AUDIO_CUSTOMER_ADEC_PCM_PATH AdecPcmPath = 0;
                API_AUDIO_CUSTOMER_ADEC_INDEX    adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
                API_AUDIO_CUSTOMER_CODEC_TYPE    codecType = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
                MS_BOOL ADEC_EOSCallback_bRegister = FALSE;
                MS_BOOL ADEC_UnderrunCallback_bRegister = FALSE;
                MS_U32  ADEC_UnderrunThreshold = 0;
                MS_U32  ADEC_UnderrunDebounceCnt = 0;

                MS_U32  repeatNum = 1;
                int     selNum_clipDec = 0;
                char*   pInput_File_Name = NULL;
                int     input_file_length = 0;
                int     bDTSbypass = FALSE;
                int     syncMode = 0;
                MS_U64  u64STCset = 0;

                while(selNum_clipDec != 0x9999)
                {
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("**    AU Demo Play All MM File (Audio only)         **                               \n");
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("(SHOW) File Path   (%s)                                                              \n", pInput_File_Name);
                    AU_nPRINT("(SHOW) AdecPcmPath (%d)                                                              \n", AdecPcmPath);
                    AU_nPRINT("(SHOW) pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister);
                    AU_nPRINT("(SHOW) pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister);
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("(0x00) pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt);
                    AU_nPRINT("(0x01) Start                                                                         \n");
                    AU_nPRINT("(0x02) Stop                                                                          \n");
                    AU_nPRINT("(0x03) Pause                                                                         \n");
                    AU_nPRINT("(0x04) Resume                                                                        \n");
                    AU_nPRINT("(0x05) pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset    (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset);
                    AU_nPRINT("(9999) Exit                                                                          \n");
                    selNum_clipDec = AU_CUS_Debug_GetHex("");

                    switch(selNum_clipDec)
                    {
                        case 0x00:
                        {
                            unsigned int arg1 = 0;
                            AU_nPRINT("g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt:\n");
                            arg1 = AU_CUS_Debug_GetDec();

                            pstAudioCustomerShmData->g_audio_customer_ADEC_End_Of_Stream_TimeOutCnt = arg1;
                        }
                        break;

                        case 0x01:
                        {
                            API_AUDIO_CUSTOMER_CH_INPUT chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;

                            AU_CUS_Show_Bifrost_Test_File_Option();
                            pInput_File_Name = AU_CUS_Debug_GetString();

                            //handle audio input file
                            pAU_debug_input_file = AU_CUS_FileOpen(pInput_File_Name, "rb");
                            if (pAU_debug_input_file == NULL)
                            {
                                AU_nPRINT("Open file FAIL!!\n");
                                break;
                            }
                            fseek(pAU_debug_input_file, 0, SEEK_END);
                            input_file_length = ftell(pAU_debug_input_file);
                            rewind(pAU_debug_input_file);
                            AU_nPRINT(" input_file_length = %d\n", input_file_length);

                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            AU_CUS_Show_Codec_Type_Option();
                            codecType = AU_CUS_Debug_GetDec();

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                switch(adecIndex)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC0:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC1:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
                                    }
                                    break;

                                    default:
                                        break;
                                }
                                AU_nPRINT(" Enter ADEC PCM Path (0:DSP_SRC, 1:MCU) \n");
                                AdecPcmPath = AU_CUS_Debug_GetHex("");

                                AU_nPRINT(" Enter repeat time \n");
                                repeatNum = AU_CUS_Debug_GetHex("");

                                AU_nPRINT(" Register ADEC EOS Callback (0:NO, 1:YES) \n");
                                ADEC_EOSCallback_bRegister = AU_CUS_Debug_GetHex("");

                                AU_nPRINT(" Register ADEC Underrun Callback (0:NO, 1:YES) \n");
                                ADEC_UnderrunCallback_bRegister = AU_CUS_Debug_GetHex("");

                                //Set pts offset
                                if(syncMode == TRUE)
                                {
                                    AU_nPRINT(" Enter pts offset: \n");
                                    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset = AU_CUS_Debug_GetDec();
                                }

                                //ADEC Connect
                                API_AUDIO_CUSTOMER_ADEC_Connect(adecIndex, API_AUDIO_CUSTOMER_ADEC_INPUT_MM);

                                //Step1: Set codec type (for DecID)
                                API_AUDIO_CUSTOMER_SetCodecType(adecIndex, codecType);

                                //check some codec need additinal parser.
                                switch(codecType)
                                {
                                    case API_AUDIO_CUSTOMER_CODEC_TYPE_DTS:
                                    {
                                        #if(DTS_AUDIO_PARSER_ENABLE)
                                        {
                                            AU_nPRINT(" DTS Bypass (0:Decode, 1:Bypass) \n");
                                            bDTSbypass = AU_CUS_Debug_GetHex("");

                                            if(bDTSbypass)
                                            {
                                                API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_AUTO);
                                                API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM);
                                            }
                                            else
                                            {
                                                AU_CUS_DTS_Parser_ParseInputFile(pInput_File_Name);
                                            }

                                        }
                                        #endif //#if(DTS_AUDIO_PARSER_ENABLE)
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_CODEC_TYPE_WMA:
                                    case API_AUDIO_CUSTOMER_CODEC_TYPE_WMA_PRO:
                                    {
                                        #if(WMA_AUDIO_PARSER_ENABLE)
                                        {
                                            input_file_length = AU_CUS_WMA_Parser_ParseInputFile(pInput_File_Name, input_file_length);
                                        }
                                        #endif //#if(WMA_AUDIO_PARSER_ENABLE)
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_CODEC_TYPE_XPCM:
                                    {
                                        #if(XPCM_AUDIO_PARSER_ENABLE)
                                        {
                                            AU_CUS_XPCM_Parser_ParseInputFile();
                                        }
                                        #endif //#if(XPCM_AUDIO_PARSER_ENABLE)
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_CODEC_TYPE_ESBypass:
                                    {
                                        int delaySample = 0;
                                        int pcm_samplerate = 48000;
                                        int hdmi_samplerate = 192000;

                                        AU_nPRINT(" delaySample: (ex: 0) \n");
                                        delaySample = AU_CUS_Debug_GetDec();

                                        AU_nPRINT(" pcm_samplerate: (ex: 48000) \n");
                                        pcm_samplerate = AU_CUS_Debug_GetDec();

                                        AU_nPRINT(" hdmi_samplerate: (ex: 192000) \n");
                                        hdmi_samplerate = AU_CUS_Debug_GetDec();

                                        API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_DELAY_SAMPLE, &delaySample);
                                        API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_PCM_SAMPLERATE, &pcm_samplerate);
                                        API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_ES_PASSTHROUGH_HDMI_SAMPLERATE, &hdmi_samplerate);
                                    }

                                    default:
                                    {
                                        //no need additinal parser
                                    }
                                    break;
                                }

                                //copy input file to readin buffer
                                MS_U32 WrtBytes;
                                AU_UNUSED(WrtBytes);
                                AU_Demo_MM_File_read_in_buffer = AU_CUS_MemoryAlloc(input_file_length);
                                WrtBytes = fread(AU_Demo_MM_File_read_in_buffer, 1, input_file_length, pAU_debug_input_file);

                                switch(AdecPcmPath)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC:
                                    {
                                        //Set Adec Pcm output path
                                        API_AUDIO_CUSTOMER_SetAdecPcmPath(adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC);
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU:
                                    {
                                        pAU_Demo_MM_New_Mode_AdecPcmDump = AU_CUS_FileOpen(AU_DEMO_MM_NEW_MODE_GET_PCM_FILE_PATH, "wb");

                                        //Set Adec Pcm output path
                                        API_AUDIO_CUSTOMER_SetAdecPcmPath(adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU);

                                        //Regist Adec Pcm decode done function
                                        API_AUDIO_CUSTOMER_AdecRegisterDecodeDoneCallback((pfnAudioCustomerAdecDecodeDone)&AU_CUS_Demo_MM_New_Mode_AdecPcmCallBackFun);
                                    }
                                    break;

                                    default:
                                        break;
                                }

                                if(ADEC_EOSCallback_bRegister)
                                {
                                    //Register ADEC EOS Callback function
                                    API_AUDIO_CUSTOMER_AdecRegisterEndOfStreamCallback(adecIndex, (pfnAudioCustomerAdecEndOfStream)&AU_CUS_Demo_MM_New_Mode_EndOfStreamCallBackFun);
                                }

                                if(ADEC_UnderrunCallback_bRegister)
                                {
                                    AU_nPRINT(" Underrund threshold (in ms): (ex: 30) \n");
                                    ADEC_UnderrunThreshold = AU_CUS_Debug_GetDec();

                                    AU_nPRINT(" Underrund Debounce cnt: (ex: 10) \n");
                                    ADEC_UnderrunDebounceCnt = AU_CUS_Debug_GetDec();

                                    //Set Underrun threshold
                                    void* pParam = &ADEC_UnderrunThreshold;
                                    API_AUDIO_CUSTOMER_SetAudioParam(adecIndex, API_AUDIO_CUSTOMER_ADEC_PARAM_UNDERRUN_THRESHOLD_IN_MS, pParam);

                                    //Set Underrun debounce cnt
                                    pParam = &ADEC_UnderrunDebounceCnt;
                                    API_AUDIO_CUSTOMER_SetAudioParam(adecIndex, API_AUDIO_CUSTOMER_ADEC_PARAM_UNDERRUN_DEBOUNCE_CNT, pParam);

                                    //Register ADEC Underrun Callback function
                                    API_AUDIO_CUSTOMER_AdecRegisterUnderrunCallback(adecIndex, (pfnAudioCustomerAdecUnderrun)&AU_CUS_Demo_MM_New_Mode_AdecUnderrunCallBackFun);
                                }

                                //Play MM New Mode decoder
                                API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo;
                                clipInfo.clipType = codecType;
                                clipInfo.repeatNumber = repeatNum;
                                AU_CUS_Demo_MM_New_Mode_Play(adecIndex, clipInfo, input_file_length, (void *)AU_Demo_MM_File_read_in_buffer);

                                if(syncMode)
                                {
                                    AU_nPRINT(" Sync mode on  \n");
                                }
                                else
                                {
                                    AU_nPRINT(" Sync mode off \n");
                                }
                                API_AUDIO_CUSTOMER_SetSyncMode(adecIndex, (MS_BOOL)syncMode);

                                //CH5 input connect
                                API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, chInput);

                                //FW mixer0 connect
                                API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                                //FW mixer0 channel unmute
                                API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);

                                //Set STC
                                if(syncMode == TRUE)
                                {
                                    u64STCset = MsOS_GetSystemTime() * 90;
                                    AU_nPRINT(" u64STCset = %-9lld    \n", u64STCset);
                                    AU_nPRINT(" u64STCset = %-9lld ms \n", AU_CUS_long_div(u64STCset, 90));
                                    MApi_DMX_Stc_Set((MS_U32)(u64STCset>>32) , (MS_U32)u64STCset);
                                }

                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x02:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Stop MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_Stop(adecIndex);

                                //Free memory
                                AU_CUS_MemoryFree((void *)AU_Demo_MM_File_read_in_buffer);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x03:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Pause MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_Pause(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x04:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Resume MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_Resume(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x05:
                        {
                            unsigned int arg1 = 0;
                            AU_nPRINT("g_audio_customer_AU_AV_Sync_Info_pts_offset:\n");
                            arg1 = AU_CUS_Debug_GetDec();

                            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_pts_offset = arg1;
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0106:
            {
                API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
                API_AUDIO_CUSTOMER_CODEC_TYPE codecType = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;

                MS_U32  repeatNum = 1;
                int     selNum_clipDec = 0;
                char*   pInput_File_Name = NULL;
                int     input_file_length = 0;

                while(selNum_clipDec != 0x9999)
                {
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("**    AU Demo Play All MM AD File (Audio only)         **                            \n");
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("(SHOW) File Path   (%s)                                                              \n", pInput_File_Name);
                    AU_nPRINT("=====================================================================================\n");
                    AU_nPRINT("(0x01) Start                                                                         \n");
                    AU_nPRINT("(0x02) Stop                                                                          \n");
                    AU_nPRINT("(0x03) Pause                                                                         \n");
                    AU_nPRINT("(0x04) Resume                                                                        \n");
                    AU_nPRINT("(9999) Exit                                                                          \n");
                    selNum_clipDec = AU_CUS_Debug_GetHex("");

                    switch(selNum_clipDec)
                    {
                        case 0x01:
                        {
                            API_AUDIO_CUSTOMER_CH_INPUT chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                            AU_UNUSED(chInput);

                            AU_CUS_Show_Bifrost_Test_File_Option();
                            pInput_File_Name = AU_CUS_Debug_GetString();

                            //handle audio input file
                            pAU_debug_input_file3 = AU_CUS_FileOpen(pInput_File_Name, "rb");
                            if (pAU_debug_input_file3 == NULL)
                            {
                                AU_nPRINT("Open file FAIL!!\n");
                                break;
                            }
                            fseek(pAU_debug_input_file3, 0, SEEK_END);
                            input_file_length = ftell(pAU_debug_input_file3);
                            rewind(pAU_debug_input_file3);
                            AU_nPRINT(" input_file_length = %d\n", input_file_length);

                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            AU_CUS_Show_Codec_Type_Option();
                            codecType = AU_CUS_Debug_GetDec();

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                switch(adecIndex)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC0:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC1:
                                    {
                                        chInput = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
                                    }
                                    break;

                                    default:
                                        break;
                                }

                                AU_nPRINT(" Enter repeat time \n");
                                repeatNum = AU_CUS_Debug_GetHex("");

                                //Step 1: enable AD Play cmd
                                API_AUDIO_CUSTOMER_SetAudioDescription(adecIndex, TRUE);

                                //copy input file to readin buffer
                                MS_U32 WrtBytes;
                                AU_UNUSED(WrtBytes);
                                AU_Demo_MM_File_read_in_buffer3 = AU_CUS_MemoryAlloc(input_file_length);
                                WrtBytes = fread(AU_Demo_MM_File_read_in_buffer3, 1, input_file_length, pAU_debug_input_file3);

                                //Play MM New Mode AD
                                API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo;
                                clipInfo.clipType = codecType;
                                clipInfo.repeatNumber = repeatNum;

                                AU_CUS_Demo_MM_New_Mode_AD_Play(adecIndex, clipInfo, input_file_length, (void *)AU_Demo_MM_File_read_in_buffer3);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x02:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //disable AD function.
                                API_AUDIO_CUSTOMER_SetAudioDescription(adecIndex, FALSE);

                                //Stop MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_AD_Stop(adecIndex);

                                //Free memory
                                AU_CUS_MemoryFree((void *)AU_Demo_MM_File_read_in_buffer3);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x03:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Pause MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_AD_Pause(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x04:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                //Resume MM New Mode decoder
                                AU_CUS_Demo_MM_New_Mode_AD_Resume(adecIndex);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0107:
            {
                #if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
                {
                    int selNum = 0;

                    while(selNum != 0x9999)
                    {
                        AU_nPRINT("=================================================                        \n");
                        AU_nPRINT("**   XPCM channel mask                         **                        \n");
                        AU_nPRINT("=================================================                        \n");
                        AU_nPRINT("default: (reset)                       0x0                               \n");
                        AU_nPRINT("#define SPEAKER_FRONT_LEFT             0x1                               \n");
                        AU_nPRINT("#define SPEAKER_FRONT_RIGHT            0x2                               \n");
                        AU_nPRINT("#define SPEAKER_FRONT_CENTER           0x4                               \n");
                        AU_nPRINT("#define SPEAKER_LOW_FREQUENCY          0x8                               \n");
                        AU_nPRINT("#define SPEAKER_BACK_LEFT              0x10                              \n");
                        AU_nPRINT("#define SPEAKER_BACK_RIGHT             0x20                              \n");
                        AU_nPRINT("=================================================                        \n");
                        AU_nPRINT("g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd  0x%x             \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd );
                        AU_nPRINT("=================================================                        \n");
                        AU_nPRINT("EXIT                                   0x9999                            \n");

                        selNum = AU_CUS_Debug_GetHex("");

                        switch(selNum)
                        {
                            case 0x00:
                            {
                                pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd = 0;
                            }
                            break;

                            case 0x01:
                            case 0x02:
                            case 0x04:
                            case 0x08:
                            case 0x10:
                            case 0x20:
                            {
                                pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd |= selNum;
                            }
                            break;

                            case 0x9999:
                            {
                                //Exit
                                pstAudioCustomerShmData->g_audio_customer_ADEC_Param_XPCM_ChannelMask_debug_Cmd = 0;
                            }
                            break;

                            default:
                                break;
                        }
                    }
                }
                #endif //#if(UTPA_SUPPORT_XPCM_PARAM_CHANNEL_MASK)
            }
            break;

            case 0x0108:
            {
                #if(CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK)
                {
                    AU_nPRINT("HDMI RX Monitor EVENT(0:Disable, 1: Enable)\n");

                    arg2 = AU_CUS_Debug_GetDec();

                    if(arg2 == 1)
                    {
                        API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK_REGISTER, (pfnAudioCustomerHDMIMonitorEvent)&AU_CUS_Demo_HDMI_Monitor_Event_CallBackFun);
                    }

                    if(arg2 == 0)
                    {
                        API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_RX_MONITOR_EVENT_CALLBACK_REGISTER, NULL);
                    }
                }
                #endif
            }
            break;

            case 0x0200:
            {
                AU_nPRINT("(0:Sync, 1: Freerun) pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode);

                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_SetSyncMode(API_AUDIO_CUSTOMER_ADEC0, (MS_BOOL)arg2);
            }
            break;

            case 0x0201:
            {
                AU_nPRINT("(0:Sync, 1: Freerun) pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode);

                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_SetSyncMode(API_AUDIO_CUSTOMER_ADEC1, (MS_BOOL)arg2);
            }
            break;

            case 0x0202:
            {
                AU_nPRINT("(0:Line, 1: RF) pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode);

                arg2 = AU_CUS_Debug_GetDec();

                void* mode = &arg2;
                API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE, mode);
            }
            break;

            case 0x0203:
            {
                AU_nPRINT("(0:Line, 1: RF) pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode);

                arg2 = AU_CUS_Debug_GetDec();

                void* mode = &arg2;
                API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE, mode);
            }
            break;

            case 0x0204:
            {
                AU_nPRINT("(0:LTRT, 1: LORO) pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode);

                arg2 = AU_CUS_Debug_GetDec();

                void* mode = &arg2;
                API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DOWNMIX_MODE, mode);
            }
            break;

            case 0x0205:
            {
                AU_nPRINT("(0:LTRT, 1: LORO) pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode);

                arg2 = AU_CUS_Debug_GetDec();

                void* mode = &arg2;
                API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DOWNMIX_MODE, mode);
            }
            break;

            case 0x0206:
            {
                AU_nPRINT("(0:LR, 1:LL, 2:RR) pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode);

                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_SetDualMonoOutMode(API_AUDIO_CUSTOMER_ADEC0, (API_AUDIO_CUSTOMER_DUALMONO_MODE)arg2);
            }
            break;

            case 0x0207:
            {
                AU_nPRINT("(0:LR, 1:LL, 2:RR) pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode);

                arg2 = AU_CUS_Debug_GetDec();
                API_AUDIO_CUSTOMER_SetDualMonoOutMode(API_AUDIO_CUSTOMER_ADEC1, (API_AUDIO_CUSTOMER_DUALMONO_MODE)arg2);
            }
            break;

            case 0x0300:
            {
                int selNum = 0;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                                            \n");
                    AU_nPRINT("**             AV Sync Info                **                                            \n");
                    AU_nPRINT("=============================================                                            \n");
                    AU_nPRINT("0x01 Start                                                                               \n");
                    AU_nPRINT("0x02 Stop                                                                                \n");
                    AU_nPRINT("0x03 pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Monitor_Interval  (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Monitor_Interval   );
                    AU_nPRINT("SHOW pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex         (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex          );
                    AU_nPRINT("9999 Exit                                                                                \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01:
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_adecIndex = AU_CUS_Debug_GetHex("");
                            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable = TRUE;
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_AVSYNC, 0);
                        }
                        break;

                        case 0x02:
                        {
                            pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable = FALSE;
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_Off, 0);
                        }
                        break;

                        case 0x03:
                        {
                            AU_nPRINT(" Interval: \n");
                            pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval = AU_CUS_Debug_GetDec();
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0301:
            {
                AU_nPRINT("Final_Auto_Audio_Delay: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_MS12_HDMI_TX_PCM_Final_Auto_Audio_Delay = arg2;
            }
            break;

            case 0x0302:
            {
                char* pInput_File_Name = NULL;

                AU_nPRINT("General_Buffer_Dump_bEnable: \n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT(" Enter input file path: ( ex: /tmp/General_Buffer_Dump.bin ) \n");
                pInput_File_Name = AU_CUS_Debug_GetString();

                if(arg2 > 0)
                {
                    pAU_GeneralBufferDumpFile = AU_CUS_FileOpen(pInput_File_Name, "wb");

                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP_ENABLE, &arg2);
                }
                else
                {
                    AU_CUS_INTERNAL_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, AU_CUS_INTERNAL_PATCH_PARAM_GENERAL_BUFFER_DUMP_ENABLE, &arg2);

                    if(pAU_GeneralBufferDumpFile != NULL)
                    {
                        AU_CUS_FileClose(pAU_GeneralBufferDumpFile);
                        pAU_GeneralBufferDumpFile = NULL;
                    }
                }
            }
            break;

            case 0x0303:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out = arg2;

                API_AUDIO_CUSTOMER_SetI2SOutGain(pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Gain);
            }
            break;

            case 0x0304:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out = arg2;

                API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_0, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Gain);
            }
            break;

            case 0x0305:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out = arg2;

                API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_1, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Gain);
            }
            break;

            case 0x0306:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out = arg2;

                API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_2, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Gain);
            }
            break;

            case 0x0307:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out = arg2;

                API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_3, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Gain);
            }
            break;

            case 0x0308:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out = arg2;

                API_AUDIO_CUSTOMER_SetSPDIFOutGain(pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Gain);
            }
            break;

            case 0x0309:
            {
                AU_nPRINT("g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out: \n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out = arg2;

                API_AUDIO_CUSTOMER_SetHDMIOutGain(pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Gain);
            }
            break;

            case 0x0310:
            {
                int selNum = 0;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("**             Audio dump Info             **                \n");
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("selNum(0x%x)                                                 \n", selNum);
                    AU_nPRINT("0x00   DUMP_INFO_Off                                         \n");
                    AU_nPRINT("0x01   DUMP_INFO_AVSYNC                                      \n");
                    AU_nPRINT("0x02   DUMP_INFO_ADEC0                                       \n");
                    AU_nPRINT("0x03   DUMP_INFO_IO_INFO                                     \n");
                    AU_nPRINT("0x04   DUMP_INFO_IO_INFO                                     \n");
                    AU_nPRINT("0x05   DUMP_INFO_ALL                                         \n");
                    AU_nPRINT("0x9999 Exit                                                  \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x00:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_Off, 0);
                        }
                        break;

                        case 0x01:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_AVSYNC, 0);
                        }
                        break;

                        case 0x02:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_ADEC0, 0);
                        }
                        break;

                        case 0x03:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_IO_INFO, 0);
                        }
                        break;

                        case 0x04:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_MM_FILE_AVSYNC, 0);
                        }
                        break;

                        case 0x05:
                        {
                            API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_COMMON_PARAM_DUMP_INFO_ALL, 0);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0311:
            {
                int selNum = 0;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("** Se-DSP force encode without main sound **                 \n");
                    AU_nPRINT("=============================================                \n");
                    #if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
                    AU_nPRINT("(SHOW)g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable  (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_bEnable);
                    AU_nPRINT("(SHOW)g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_bEnable);
                    AU_nPRINT("(SHOW)g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_bEnable);
                    #endif //#if(CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND)
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("selNum(0x%x)                                                 \n", selNum);
                    AU_nPRINT("0x01   HDMI  TX DDE  without main sound                      \n");
                    AU_nPRINT("0x02   HDMI  TX DDPE without main sound                      \n");
                    AU_nPRINT("0x03   SPDIF TX DDE  without main sound                      \n");
                    AU_nPRINT("0x04   Disable Se-DSP MS12 Encode without main sound         \n");
                    AU_nPRINT("0x9999 Exit                                                  \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01:
                        {
                            //Set Decoder type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);

                            //Set HDMI TX output type (DD)
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM);

                            //Enable HDMI TX force DDE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_TX_SEDSP_DDE_WO_MAIN_SND_ENABLE, NULL);
                        }
                        break;

                        case 0x02:
                        {
                            //Set Decoder type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);

                            //Set HDMI TX output type (DDP)
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3);

                            //Enable HDMI TX force DDPE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_TX_SEDSP_DDPE_WO_MAIN_SND_ENABLE, NULL);
                        }
                        break;

                        case 0x03:
                        {
                            //Set Decoder type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);

                            //Set HDMI TX output type (DD)
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM);

                            //Set SPDIF TX output type (DD)
                            API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_AUTO);

                            //Enable SPDIF TX force DDE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_SPDIF_TX_SEDSP_DDE_WO_MAIN_SND_ENABLE, NULL);
                        }
                        break;

                        case 0x04:
                        {
                            //Disable HDMI TX force DDE/DDPE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_SEDSP_MS12_ENC_WO_MAIN_SND_DISABLE, NULL);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0312:
            {
                int selNum = 0;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("** ASND-R2 force encode without main sound **                \n");
                    AU_nPRINT("=============================================                \n");
                    #if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
                    AU_nPRINT("(SHOW)g_audio_customer_patch_HDMI_ARC_SNDR2_DDE_WO_MAIN_SND_bEnable  (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_bEnable);
                    AU_nPRINT("(SHOW)g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable (%d)    \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_patch_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_bEnable);
                    #endif //#if(CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND)
                    AU_nPRINT("=============================================                \n");
                    AU_nPRINT("selNum(0x%x)                                                 \n", selNum);
                    AU_nPRINT("0x01   HDMI ARC DDE  without main sound                      \n");
                    AU_nPRINT("0x02   HDMI ARC DDPE without main sound                      \n");
                    AU_nPRINT("0x03   Disable Snd-R2 MS12 Encode without main sound         \n");
                    AU_nPRINT("0x9999 Exit                                                  \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01:
                        {
                            //Set Decoder type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);

                            //Set SPDIF TX output type (DD)
                            API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_DD);

                            //Enable HDMI ARC force DDE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_ARC_SEDSP_DDE_WO_MAIN_SND_ENABLE, NULL);
                        }
                        break;

                        case 0x02:
                        {
                            //Set Decoder type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);

                            //Set SPDIF TX output type (DDP)
                            API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_AUTO);

                            //Enable HDMI ARC force DDE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_HDMI_ARC_SNDR2_DDPE_WO_MAIN_SND_ENABLE, NULL);
                        }
                        break;

                        case 0x03:
                        {
                            //Disable HDMI ARC force DDE/DDPE without main sound.
                            API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMIZED_PATCH_PARAM_SNDR2_MS12_ENC_WO_MAIN_SND_DISABLE, NULL);
                        }
                        break;

                        case 0x9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0313:
            {
                AU_nPRINT("eSourceType:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_CUS_SetSourceInfo((AUDIO_SOURCE_INFO_TYPE)arg2);
            }
            break;

            case 0x0314:
            {
                AU_nPRINT("enSource:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("enGroup:\n");
                arg3 = AU_CUS_Debug_GetDec();

                AU_CUS_InputSwitch((AUDIO_INPUT_TYPE)arg2, (AUDIO_SWITCH_GROUP)arg3);
            }
            break;

            case 0x0400:
            {
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff = arg2;
            }
            break;

            case 0x0401:
            {
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff = arg2;
            }
            break;

            case 0x0402:
            {
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff = arg2;
            }
            break;

            case 0x0403:
            {
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff = arg2;
            }
            break;

            case 0x0404:
            {
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff = arg2;
            }
            break;

            case 0x0500:
            {
                AU_nPRINT("per_50ms:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("port:\n");
                arg3 = AU_CUS_Debug_GetDec();

                MS_U32 per_50ms = (MS_U32)arg2;
                API_AUDIO_CUSTOMER_OUTPUT_TYPE port = arg3;
                AU_CUS_MuteDuringLimitedTime_Output(per_50ms, port);
            }
            break;

            case 0x0501:
            {
                AU_nPRINT("per_50ms:\n");
                arg2 = AU_CUS_Debug_GetDec();

                AU_nPRINT("eFM :\n");
                arg3 = AU_CUS_Debug_GetDec();

                AU_nPRINT("port:\n");
                arg4 = AU_CUS_Debug_GetDec();

                MS_U32 per_50ms = (MS_U32)arg2;
                API_AUDIO_CUSTOMER_FWM_INDEX eFM = arg3;
                API_AUDIO_CUSTOMER_FWM_INPUT port = arg4;
                AU_CUS_MuteDuringLimitedTime_Input(per_50ms, eFM, port);
            }
            break;

            case 0x0600:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_ClipDecoderMonitor_Interval = arg2;
            }
            break;

            case 0x0601:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_MP3EncodeMonitor_Interval = arg2;
            }
            break;

            case 0x0602:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_MonitorService_Interval = arg2;
            }
            break;

            case 0x0603:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_MuteDuringLimitedTime_Monitor_Interval = arg2;
            }
            break;

            case 0x0604:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_AdecPcmOut_Interval = arg2;
            }
            break;

            case 0x0605:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_PCMCapture_Interval = arg2;
            }
            break;

            case 0x0606:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_EndOfStreamMonitor_Interval = arg2;
            }
            break;

            case 0x0607:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_AdecUnderrun_Interval = arg2;
            }
            break;

            case 0x0608:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_Demo_MM_New_Mode_Play_Monitor_Interval = arg2;
            }
            break;

            case 0x0609:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_ADEC_SetMute_Delay = arg2;
            }
            break;

            case 0x0610:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Stop_Pop_Noise_mute_limited_time = arg2;
            }
            break;

            case 0x0611:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_internal_patch_Avoid_ADEC_Pause_Pop_Noise_mute_limited_time = arg2;
            }
            break;

            case 0x0612:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_SetPlayCmdByAdecSource_Delay = arg2;
            }
            break;

            case 0x0613:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();
                pstAudioCustomerShmData->g_audio_customer_AU_CUS_PauseDecoding_Delay = arg2;
            }
            break;

            case 0x0700:
            {
                API_AUDIO_CUSTOMER_ADEC_INDEX   adecIndex = API_AUDIO_CUSTOMER_ADEC_INDEX_INVALID;
                API_AUDIO_CUSTOMER_CODEC_TYPE   adecType  = API_AUDIO_CUSTOMER_CODEC_TYPE_INVALID;
                API_AUDIO_CUSTOMER_CH_INPUT     ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
                API_AUDIO_CUSTOMER_CH_INPUT     ch6_Input = API_AUDIO_CUSTOMER_CH_INPUT_INVALID;
                API_AUDIO_CUSTOMER_ADC_INDEX    ADCIndex  = API_AUDIO_CUSTOMER_ADC_INDEX_INVALID;
                API_AUDIO_CUSTOMER_ADC_IN_PORT  ADC_In_portNum = API_AUDIO_CUSTOMER_ADC_IN_PORT_INVALID;

                int selNum = 0;

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                                    \n");
                    AU_nPRINT("**   Input Source Change                   **                                    \n");
                    AU_nPRINT("=============================================                                    \n");
                    AU_nPRINT("(0x01) DTV  (ADEC :%d)  (CH5 input: %d) (CH6 input: %d)                          \n", adecIndex, ch5_Input, ch6_Input);
                    AU_nPRINT("(0x02) ATV  (ADEC: %d)  (CH5 input: %d) (CH6 input: %d)                          \n", adecIndex, ch5_Input, ch6_Input);
                    AU_nPRINT("(0x03) HDMI (ADEC: %d)  (CH5 input: %d) (CH6 input: %d)                          \n", adecIndex, ch5_Input, ch6_Input);
                    AU_nPRINT("(0x04) Component                                                                 \n");
                    AU_nPRINT("(0x05) AV                                                                        \n");
                    AU_nPRINT("(9999) Exit                                                                      \n");
                    selNum = AU_CUS_Debug_GetHex("");

                    switch(selNum)
                    {
                        case 0x01: //DTV
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            AU_nPRINT(" Enter Decoder TYPE (0: MPEQ, 1: AC3, 2:AAC) \n");
                            adecType = AU_CUS_Debug_GetHex("");

                            switch(adecType)
                            {
                                case 1:
                                {
                                    adecType = API_AUDIO_CUSTOMER_CODEC_TYPE_EAC3;
                                }
                                break;

                                case 2:
                                {
                                    adecType = API_AUDIO_CUSTOMER_CODEC_TYPE_HEAAC;
                                }
                                break;

                                case 0:
                                default:
                                {
                                    adecType = API_AUDIO_CUSTOMER_CODEC_TYPE_MPEG;
                                }
                                break;
                            }

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                switch(adecIndex)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC0:
                                    {
                                        ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC1:
                                    {
                                        ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
                                    }
                                    break;

                                    default:
                                        break;
                                }

                                //Connect ADEC to HDMI
                                API_AUDIO_CUSTOMER_ADEC_Connect(adecIndex, API_AUDIO_CUSTOMER_ADEC_INPUT_DTV);

                                //Set Adec Pcm output path
                                API_AUDIO_CUSTOMER_SetAdecPcmPath(adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC);

                                //CH5 input connect
                                API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, ch5_Input);

                                //Set Decoder type
                                API_AUDIO_CUSTOMER_SetCodecType(adecIndex, adecType);

                                //Start decoding
                                API_AUDIO_CUSTOMER_StartDecoding(adecIndex);

                                //FW mixer0 connect
                                API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                                //FW mixer0 channel unmute
                                API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }

                        }
                        break;

                        case 0x02: //ATV
                        {
                            AU_nPRINT(" Enter ATV TYPE (0: PAL, 1: BTSC) \n");
                            adecType = AU_CUS_Debug_GetHex("");
                            if(adecType == 0)
                            {
                                adecType = API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_A2;
                            }
                            else
                            {
                                adecType = API_AUDIO_CUSTOMER_CODEC_TYPE_SIF_BTSC;
                            }

                            //Connect ADEC_ATV
                            API_AUDIO_CUSTOMER_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_ATV, API_AUDIO_CUSTOMER_ADEC_INPUT_ATV);

                            //CH5 input connect
                            API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, API_AUDIO_CUSTOMER_CH_INPUT_ADEC_ATV);

                            //Set SIF type
                            API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC_ATV, adecType);

                            //Start decoding
                            API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC_ATV);

                            //FW mixer0 connect
                            API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                            //FW mixer0 channel unmute
                            API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);

                            //Enable ATV Monitor
                            API_AUDIO_CUSTOMER_SIF_SetMonitorOnOff(TRUE);

                        }
                        break;

                        case 0x03: //HDMI
                        {
                            AU_nPRINT(" Enter ADEC index (0: ADEC0, 1: ADEC1) \n");
                            adecIndex = AU_CUS_Debug_GetHex("");

                            if(adecIndex == API_AUDIO_CUSTOMER_ADEC0 || adecIndex == API_AUDIO_CUSTOMER_ADEC1)
                            {
                                switch(adecIndex)
                                {
                                    case API_AUDIO_CUSTOMER_ADEC0:
                                    {
                                        ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC0;
                                    }
                                    break;

                                    case API_AUDIO_CUSTOMER_ADEC1:
                                    {
                                        ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADEC1;
                                    }
                                    break;

                                    default:
                                        break;
                                }

                                //Connect ADEC to HDMI
                                API_AUDIO_CUSTOMER_ADEC_Connect(adecIndex, API_AUDIO_CUSTOMER_ADEC_INPUT_HDMI);

                                //Set Adec Pcm output path
                                API_AUDIO_CUSTOMER_SetAdecPcmPath(adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH_DSP_SRC);

                                //CH5 input connect
                                API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, ch5_Input);

                                //Start decoding
                                API_AUDIO_CUSTOMER_StartDecoding(adecIndex);

                                //FW mixer0 connect
                                API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                                //FW mixer0 channel unmute
                                API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);

                                //Enable HDMI RX Monitor
                                API_AUDIO_CUSTOMER_HDMI_RX_SetMonitorOnOff(TRUE);
                            }
                            else
                            {
                                AU_nPRINT(" Invalid ADEC index \n");
                            }
                        }
                        break;

                        case 0x04: //Component
                        case 0x05: //AV
                        {
                            AU_nPRINT(" Enter ADC index: \n");
                            AU_nPRINT(" (0) API_AUDIO_CUSTOMER_ADC0     \n");
                            AU_nPRINT(" (1) API_AUDIO_CUSTOMER_ADC1     \n");
                            ADCIndex = (API_AUDIO_CUSTOMER_ADC_INDEX)AU_CUS_Debug_GetHex("");

                            AU_nPRINT(" Enter ADC In Port Number: \n");
                            AU_nPRINT(" (0x02) API_AUDIO_CUSTOMER_ADC0_IN_PORT_0     \n");
                            AU_nPRINT(" (0x12) API_AUDIO_CUSTOMER_ADC0_IN_PORT_1     \n");
                            AU_nPRINT(" (0x22) API_AUDIO_CUSTOMER_ADC0_IN_PORT_2     \n");
                            AU_nPRINT(" (0x32) API_AUDIO_CUSTOMER_ADC0_IN_PORT_3     \n");
                            AU_nPRINT(" (0xA2) API_AUDIO_CUSTOMER_ADC0_IN_PORT_4     \n");
                            AU_nPRINT(" (0xB2) API_AUDIO_CUSTOMER_ADC0_IN_PORT_5     \n");
                            AU_nPRINT(" (0x72) API_AUDIO_CUSTOMER_ADC0_MIC_IN        \n");
                            AU_nPRINT(" (0x09) API_AUDIO_CUSTOMER_ADC1_IN_PORT_0     \n");
                            AU_nPRINT(" (0x19) API_AUDIO_CUSTOMER_ADC1_IN_PORT_1     \n");
                            AU_nPRINT(" (0x29) API_AUDIO_CUSTOMER_ADC1_IN_PORT_2     \n");
                            AU_nPRINT(" (0x39) API_AUDIO_CUSTOMER_ADC1_IN_PORT_3     \n");
                            AU_nPRINT(" (0xA9) API_AUDIO_CUSTOMER_ADC1_IN_PORT_4     \n");
                            AU_nPRINT(" (0xB9) API_AUDIO_CUSTOMER_ADC1_IN_PORT_5     \n");
                            AU_nPRINT(" (0x79) API_AUDIO_CUSTOMER_ADC1_MIC_IN        \n");
                            ADC_In_portNum = (API_AUDIO_CUSTOMER_ADC_IN_PORT)AU_CUS_Debug_GetHex("");

                            AU_nPRINT("ADC_In_portNum = 0x%x \n", ADC_In_portNum);

                            //Connect ADC to ADC-in port
                            API_AUDIO_CUSTOMER_ADC_Connect(ADCIndex, ADC_In_portNum);

                            switch(ADCIndex)
                            {
                                case API_AUDIO_CUSTOMER_ADC0:
                                {
                                    ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADC0;
                                }
                                break;

                                case API_AUDIO_CUSTOMER_ADC1:
                                {
                                    ch5_Input = API_AUDIO_CUSTOMER_CH_INPUT_ADC1;
                                }
                                break;

                                default:
                                    break;
                            }

                            //CH5 input connect
                            API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, ch5_Input);

                            AU_nPRINT("[0x112C65]=0x%-4X,\n", AU_CUS_ReadAbsReg((MS_U32)0x112C65));
                            AU_nPRINT("[0x112CE2]=0x%-4X,\n", AU_CUS_ReadAbsReg((MS_U32)0x112CE2));

                            //FW mixer0 connect
                            API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);

                            //FW mixer0 channel unmute
                            API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);
                        }
                        break;

                        case 9999:
                        {
                            //Exit
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
            break;

            case 0x0701:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();

                if(arg2)
                {
                    //[Debug] Dump MM ES1
                    pAU_MMESDumpFile = AU_CUS_FileOpen("/tmp/MM_Audio_ES1_Dump.bin", "wb");
                    if(pAU_MMESDumpFile == NULL)
                    {
                        AU_nPRINT("Open file FAIL!!\n");
                    }

                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MM_ES1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;
                }
                else
                {
                    //[Debug] Stop Dump ES1
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MM_ES1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;

                    if(pAU_MMESDumpFile != NULL)
                    {
                        AU_CUS_FileClose(pAU_MMESDumpFile);
                        pAU_MMESDumpFile = NULL;
                    }
                }
            }
            break;

            case 0x0702:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();

                if(arg2)
                {
                    //[Debug] Dump DEC PCM1
                    pAU_GeneralBufferDumpFile = AU_CUS_FileOpen("/tmp/General_Buffer_Dump1_DEC_PCM1_Buffer.pcm", "wb");
                    if(pAU_GeneralBufferDumpFile == NULL)
                    {
                        AU_nPRINT("Open file FAIL!!\n");
                    }

                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;
                }
                else
                {
                    //[Debug] Stop Dump DEC PCM1
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_PCM1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;

                    if(pAU_GeneralBufferDumpFile != NULL)
                    {
                        AU_CUS_FileClose(pAU_GeneralBufferDumpFile);
                        pAU_GeneralBufferDumpFile = NULL;
                    }
                }
            }
            break;

            case 0x0703:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();

                if(arg2)
                {
                    //[Debug] Dump HDMI NonPCM
                    pAU_GeneralBufferDumpFile2 = AU_CUS_FileOpen("/tmp/General_Buffer_Dump2_HDMI_NPCM_Buffer.bin", "wb");
                    if(pAU_GeneralBufferDumpFile2 == NULL)
                    {
                        AU_nPRINT("Open file FAIL!!\n");
                    }

                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;
                }
                else
                {
                    //[Debug] Stop Dump HDMI NonPCM
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMINPCM_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;

                    if(pAU_GeneralBufferDumpFile2 != NULL)
                    {
                        AU_CUS_FileClose(pAU_GeneralBufferDumpFile2);
                        pAU_GeneralBufferDumpFile2 = NULL;
                    }
                }

            }
            break;

            case 0x0704:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();

                if(arg2)
                {
                    //[Debug] Dump MS12 DDPE Data
                    pAU_GeneralBufferDumpFile3 = AU_CUS_FileOpen("/tmp/General_Buffer_Dump3_MS12_MetaData_Buffer.bin", "wb");
                    if(pAU_GeneralBufferDumpFile3 == NULL)
                    {
                        AU_nPRINT("Open file FAIL!!\n");
                    }

                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;
                }
                else
                {
                    //[Debug] Stop Dump MS12 DDPE Data
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_MS12_METADATA_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;

                    if(pAU_GeneralBufferDumpFile3 != NULL)
                    {
                        AU_CUS_FileClose(pAU_GeneralBufferDumpFile3);
                        pAU_GeneralBufferDumpFile3 = NULL;
                    }
                }
            }
            break;

            case 0x0705:
            {
                AU_nPRINT("arg2:\n");
                arg2 = AU_CUS_Debug_GetDec();

                if(arg2)
                {
                    //[Debug] Dump HDMI ES1
                    pAU_GeneralBufferDumpFile4 = AU_CUS_FileOpen("/tmp/HDMI_Audio_ES1_Dump.bin", "wb");
                    if(pAU_GeneralBufferDumpFile4 == NULL)
                    {
                        AU_nPRINT("Open file FAIL!!\n");
                    }

                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;
                }
                else
                {
                    //[Debug] Stop Dump HDMI ES1
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_Dump_HDMI_ES1_bEnable = arg2;
                    pstAudioCustomerShmData->g_audio_customer_internal_patch_General_Buffer_Dump_bEnable = arg2;

                    if(pAU_GeneralBufferDumpFile4 != NULL)
                    {
                        AU_CUS_FileClose(pAU_GeneralBufferDumpFile4);
                        pAU_GeneralBufferDumpFile4 = NULL;
                    }
                }
            }
            break;

            case 0x0800:
            {
                int selNum = 0;
                int ADEC0_bAtmos_Stream = 0;
                int ADEC1_bAtmos_Stream = 0;
                API_AUDIO_CUSTOMER_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_INFO_AC3P_IS_ATMOS_STREAM, &ADEC0_bAtmos_Stream);
                API_AUDIO_CUSTOMER_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC1, API_AUDIO_CUSTOMER_ADEC_INFO_AC3P_IS_ATMOS_STREAM, &ADEC1_bAtmos_Stream);

                while(selNum != 0x9999)
                {
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**             SPDIF TX output type        **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType  (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);
                    AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_DriverOutputType (%d) \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_DriverOutputType);
                    AU_nPRINT("0x00 SPDIF_TX_NONE                                                       \n");
                    AU_nPRINT("0x01 SPDIF_TX_PCM                                                        \n");
                    AU_nPRINT("0x02 SPDIF_TX_AUTO                                                       \n");
                    AU_nPRINT("0x03 SPDIF_TX_BYPASS                                                     \n");
                    AU_nPRINT("0x04 SPDIF_TX_TRANSCODE                                                  \n");
                    AU_nPRINT("0x05 SPDIF_TX_DD                                                         \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("**             HDMI TX output type         **                            \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType  (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType);
                    AU_nPRINT("pstAudioCustomerShmData->g_audio_customer_HDMI_TX_DriverOutputType (%d)  \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_TX_DriverOutputType);
                    AU_nPRINT("0x10 HDMI_TX_PCM         (HDMI PCM)                                      \n");
                    AU_nPRINT("0x11 HDMI_TX_NONPCM      (HDMI NPCM)                                     \n");
                    AU_nPRINT("0x12 HDMI_TX_EAC3_BYPASS (HDMI DDP bypass)                               \n");
                    AU_nPRINT("0x13 HDMI_TX_EAC3        (HDMI DDP)                                      \n");
                    AU_nPRINT("=============================================                            \n");
                    AU_nPRINT("ADEC0_bAtmos_Stream(%d)                                                  \n", (unsigned int)ADEC0_bAtmos_Stream);
                    AU_nPRINT("ADEC1_bAtmos_Stream(%d)                                                  \n", (unsigned int)ADEC1_bAtmos_Stream);
                    AU_nPRINT("bDDP_71_Stream(%d)                                                       \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_bDDP_71_Stream);
                    AU_nPRINT("g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt (%d)     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_Debounce_Cnt);
                    AU_nPRINT("g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt     (%d)     \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_internal_patch_DDP_71_Auto_Bypass_okFrmCnt);
                    AU_nPRINT("9999 Exit                                                                \n");

                    selNum = AU_CUS_Debug_GetHex("");

                    //Enable HDMI TX Monitor
                    API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff(TRUE);

                    switch(selNum)
                    {
                        case 0x00:
                        case 0x01:
                        case 0x02:
                        case 0x03:
                        case 0x04:
                        case 0x05:
                        {
                            API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType((API_AUDIO_CUSTOMER_SPDIF_TX_MODE)selNum);
                        }
                        break;

                        case 0x10:
                        {
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_PCM);
                        }
                        break;

                        case 0x11:
                        {
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_NONPCM);
                        }
                        break;

                        case 0x12:
                        {
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3_BYPASS);
                        }
                        break;

                        case 0x13:
                        {
                            API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_EAC3);
                        }
                        break;

                        default:
                        case 0x9999:
                        {
                            //Exit
                        }
                        break;
                    }
                }
            }
            break;

            case 0x0801:
            {
                int arg1 = 0;
                MS_BOOL bEnable = FALSE;

                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("**             HDMI ARC Enable/Disable     **                            \n");
                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("Enter 1:Enable  0:Disable:\n");
                arg1 = AU_CUS_Debug_GetDec();
                bEnable = (MS_BOOL)arg1;

                MDrv_HDMI_ARC_PINControl(INPUT_PORT_DVI0, bEnable, FALSE);
                MDrv_HDMI_ARC_PINControl(INPUT_PORT_DVI1, bEnable, FALSE);
                MDrv_HDMI_ARC_PINControl(INPUT_PORT_DVI2, bEnable, FALSE);
                MDrv_HDMI_ARC_PINControl(INPUT_PORT_DVI3, bEnable, FALSE);
                #if (0)
                if(bEnable)
                {
                    MApi_CEC_TxSendMsg2(E_LA_AUDIO_SYS, E_MSG_ARC_REQUEST_ARC_INITATION,0 ,0);
                    AU_CUS_Delay1MS(33);
                    MApi_CEC_TxSendMsg2(E_LA_AUDIO_SYS, E_MSG_ARC_REPORT_ARC_INITIATED,0 ,0);
                }
                else
                {
                    MApi_CEC_TxSendMsg2(E_LA_AUDIO_SYS, E_MSG_ARC_REQUEST_ARC_TERMINATION,0 ,0);
                    AU_CUS_Delay1MS(33);
                    MApi_CEC_TxSendMsg2(E_LA_AUDIO_SYS, E_MSG_ARC_REPORT_ARC_TERMINATED,0 ,0);
                }
                #endif
            }
            break;

            case 0x0900:
            {
                int arg1 = 0;
                MS_BOOL bOnOff = FALSE;
                MS_U16 u16level = 0;
                MS_U16 u16offset = 0;
                API_AUDIO_CUSTOMER_MSTAR_AVC_MODE mode = API_AUDIO_CUSTOMER_AVC_NORMAL;

                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("**           MSTAR  AVC (HDMI)             **                            \n");
                AU_nPRINT("=============================================                            \n");
                AU_nPRINT("Enter 1:Enable  0:Disable:\n");
                arg1 = AU_CUS_Debug_GetDec();
                bOnOff = (MS_BOOL)arg1;

                // API_AUDIO_CUSTOMER_SNDOUT_Connect should be set when audio systm init, here is just for demo
                API_AUDIO_CUSTOMER_SNDOUT_Connect(API_AUDIO_CUSTOMER_SOUNDOUT_HDMI_TX, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT_DSPSE);

                API_AUDIO_CUSTOMER_MSTAR_SE_Enable(API_AUDIO_CUSTOMER_AVC, bOnOff);

                if(bOnOff == TRUE)
                {
                    AU_nPRINT("Enter AVC level value: 0~80 (step: -0.5dB / range: 0 ~ -40dB)\n");
                    arg1 = AU_CUS_Debug_GetDec();
                    u16level = arg1;
                    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL(u16level);

                    AU_nPRINT("Enter AVC S MODE OFFSET: +0dB ~ +12dB \n");
                    arg1 = AU_CUS_Debug_GetDec();
                    u16offset = arg1;
                    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET(u16offset);

                    AU_nPRINT("Enter AVC mode-> 0:Linear 1:Shift 2:Normal\n");
                    arg1 = AU_CUS_Debug_GetDec();
                    mode = arg1;
                    API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE(mode);
                }
            }
            break;

            case 0x7202:
            {
                pAU_nDBG_MenuLog_To_File = AU_CUS_FileOpen(AU_NDBG_MENULOG_TO_FILE_PATH, "wb");
                AU_CUS_ShowAudioBlockDiagram();
            }
            break;

            case 0x8888:
            {
                pAU_nDBG_Log_To_File        = AU_CUS_FileOpen(AU_NDBG_LOG_TO_FILE_PATH, "wb");
                pAU_nDBG_MenuLog_To_File    = AU_CUS_FileOpen(AU_NDBG_MENULOG_TO_FILE_PATH, "wb");
            }
            break;

            case 0x4444:
            {
                fflush(pAU_nDBG_Log_To_File);
                if (pAU_nDBG_Log_To_File != NULL)
                {
                    AU_CUS_FileClose(pAU_nDBG_Log_To_File);
                    pAU_nDBG_Log_To_File = NULL;
                }
            }
            break;

            case 0x1111:
            {
                //refresh
            }
            break;

            case 0x1234:
            {
                AU_CUS_SingleFunctionDebugMenu();
            }
            break;

            case 0x9990:
            {
                AU_CUS_Show_HashKey_Support();
            }
            break;

            case 0x9991:
            {
                AU_CUS_AQ_Tuning_and_Dump_Data();
            }
            break;

            case 0x9992:
            {
                AU_CUS_MCU_DUMP_R2_LOG();
            }
            break;

            case 0x9993:
            {
                AU_CUS_Where_Am_I();
            }
            break;

            case 0x9994:
            {
                AU_CUS_DDR_Dump_Debug();
            }
            break;

            case 0x9995:
            {
                AU_CUS_Dump_Audio_Related_Bank();
            }
            break;

            case 0x9996:
            {
                AU_CUS_SHOW_ALL_VERSION();
            }
            break;

            case 0x9997:
            {
                AU_CUS_SIF_Debug();
            }
            break;

            case 0x9998:
            {
                AU_CUS_RegDebug();
            }
            break;

            default:
            case 0x9999:
            {
                AU_nPRINT("\n\n\n\n\n\n\n\n");
                AU_nPRINT("============================================================    \n");
                AU_nPRINT(">>>> Exit AU_Debug menu, BYE BYE!!! Audio Bless You !!! <<<<    \n");
                AU_nPRINT("============================================================    \n");
                AU_nPRINT("\n\n\n\n\n\n\n\n");

                return TRUE;
            }
            break;
        }

        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg1  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg1);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg2  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg2);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg3  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg3);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg4  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg4);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg5  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg5);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg6  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg6);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg7  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg7);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg8  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg8);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg9  = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg9);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [arg10 = 0x%x]   \n", __FILE__, __FUNCTION__, __LINE__, (unsigned int)arg10);
        AU_nPRINT("[AUDIO][%s] [%s] [%d] [------AUDIO_DEBUG------End] \n\n\n", __FILE__, __FUNCTION__, __LINE__);
    }
}

#endif

//-------------------------------------------------------------------------------------------------------------------------------------
// Until to debug menu, is the APIs open to customer, DO NOT add Internal function / variable / define.
// Until to debug menu, is the APIs open to customer, DO NOT add Internal function / variable / define.
// Until to debug menu, is the APIs open to customer, DO NOT add Internal function / variable / define.
// please understand, it's important.
//-------------------------------------------------------------------------------------------------------------------------------------
/* Initialize, STR */
MS_BOOL API_AUDIO_CUSTOMER_InitializeModule(MS_U32 u32MiuNo, MS_U32 mad_va, API_AUDIO_CUSTOMER_OUTPUT_INFO OutputInfo, API_AUDIO_CUSTOMER_CHIP_PLATFORM chipPlatform)
{
    MS_U32 mad_pa;
    Digital_Out_Device_Capability_t Device_Capability;
    API_AUDIO_CUSTOMER_DOLBY_DRC_MODE dolbyDrcMode = API_AUDIO_CUSTOMER_DOLBY_LINE_MODE;
    AU_UNUSED(dolbyDrcMode);

    AU_CUS_ShmInit();
    AU_CUS_Mutex_Init();

    pstAudioCustomerShmData->g_audio_customer_Chip_Platform = chipPlatform;

#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    if(pstAudioCustomerShmData->g_audio_customer_Chip_Platform == API_AUDIO_CUSTOMER_CHIP_PLATFORM_STB)
    {
        #ifdef CONFIG_MBOOT
        {
            //do nothing
        }
        #else
        {
            //help to init HDMI for HDMI TX monitor.
            MApi_HDMITx_Init();
        }
        #endif
    }
#endif

    if(pstAudioCustomerShmData->g_audio_customer_Init_Done == TRUE)
    {
        AU_nPRINT("[AUDIO][%s] [%d] [Return for Double Init!!!] \n", __FUNCTION__, __LINE__);
        return TRUE;
    }

    AU_nDBG("[u32MiuNo              = 0x%x] \n", (unsigned int)u32MiuNo);
    AU_nDBG("[mad_va                = 0x%x] \n", (unsigned int)mad_va);
    AU_nDBG("[OutputInfo.SpeakerOut = 0x%x] \n", (unsigned int)OutputInfo.SpeakerOut);
    AU_nDBG("[OutputInfo.HpOut      = 0x%x] \n", (unsigned int)OutputInfo.HpOut);
    AU_nDBG("[OutputInfo.MonitorOut = 0x%x] \n", (unsigned int)OutputInfo.MonitorOut);
    AU_nDBG("[OutputInfo.ScartOut   = 0x%x] \n", (unsigned int)OutputInfo.ScartOut);
    AU_nDBG("[OutputInfo.SpdifOut   = 0x%x] \n", (unsigned int)OutputInfo.SpdifOut);
    AU_nDBG("[OutputInfo.ArcOut     = 0x%x] \n", (unsigned int)OutputInfo.ArcOut);
    AU_nDBG("[OutputInfo.HDMIOut    = 0x%x] \n", (unsigned int)OutputInfo.HDMIOut);

    //write audio pre-init table
    MApi_AUDIO_WritePreInitTable();

    //Set AUDIO DDR info
    mad_pa = (MS_U32)MsOS_MPool_VA2PA(mad_va);
    #if(UTPA_AUDIO_CHIP_TYPE_1D)
    {
        MApi_AUDIO_SetDspBaseAddr(DSP_SE, 0 , mad_pa + u32MiuNo);
    }
    #else
    {
        MApi_AUDIO_SetDspBaseAddr(DSP_ADV, 0 , mad_pa + u32MiuNo);
    }
    #endif

    //Set output info
    MApi_AUDIO_SetOutputInfo((AUDIO_OUT_INFO*)&OutputInfo);

    //audio init
    MApi_AUDIO_Initialize();

    //Initialize audio global variable
    memset((void *)&madCallBack, 0, sizeof(St_Audio_Callback_Func));
    memset((void *)&clipDecoderInfo, 0, sizeof(St_Audio_Clip_Decoder_Info));
    AU_CUS_Initial_Register_Bank_By_ChipType();

    //Create thread
    AU_CUS_CreateThread();

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        AU_CUS_KERNEL_DEBUG_PROC_init();
    }
    #endif

    //set device default capability
    memset((void *)&Device_Capability, 0, sizeof(Device_Capability));
    Device_Capability.support_codec = 1;
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DD , &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_AAC, &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DDP, &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DTS, &Device_Capability);

    //init FWM connect
    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8);

    //init FWM gain to 0dB
    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, 919);
    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6, 919);
    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8, 919);

    //init FWM0 Mute status
    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, FALSE);
    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6, TRUE);
    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8, FALSE);

    #if(CUSTOMIZED_INTERNAL_PATCH_LIMITED_AUDIO_DELAY_ENABLE)
    {
        AU_CUS_SetAudioDelay((MS_U32)AUDIO_DELAY_LOWER_BOUND);
    }
    #endif

    //init ADEC0 codec type to AC3
    #if(CUSTOMIZED_INTERNAL_PATCH_ADEC0_INITIAL_CODEC_TYPE_AC3_ENABLE)
    {
        AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_INPUT_MM);
        AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_AC3);
    }
    #endif

    #if(CUSTOMIZED_INTERNAL_PATCH_ADEC0_INITIAL_DOLBY_DRC_LINE_MODE)
    {
        AU_CUS_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE, &dolbyDrcMode);
    }
    #endif

    //update Audio Init flag
    pstAudioCustomerShmData->g_audio_customer_Init_Done = TRUE;

    #if(CUSTOMIZED_INTERNAL_PATCH_R2_ACTIVE_MONITOR_ENABLE)
    {
        //do nothing
    }
    #else
    {
        g_api_audio_InitializeModule_R2_bActive = TRUE;
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_InitializeModule_IsFinish(void)
{
    return g_api_audio_InitializeModule_R2_bActive;
}

MS_BOOL API_AUDIO_CUSTOMER_Suspend(void)
{
    pstAudioCustomerShmData->g_audio_customer_Init_Done = FALSE;
    pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart = TRUE;
    pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish = FALSE;
    g_api_audio_InitializeModule_R2_bActive = FALSE;

    //let HDMI RX monitor alive when next HDMI Connect.
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;
    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Init_Done                   = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Init_Done);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart           = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish           = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish);
    AU_nDBG("[g_api_audio_InitializeModule_R2_bActive                               = %d] \n", (unsigned int)g_api_audio_InitializeModule_R2_bActive);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type  = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type);

    #if(UTPA_SUPPORT_SET_POWER_ON)
    {
        MApi_AUDIO_SetPowerOn(FALSE);
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_Resume(void)
{
    MS_BOOL Sound_Out_I2S_bMute_Backup   = FALSE;
    MS_BOOL Sound_Out_Line0_bMute_Backup = FALSE;
    MS_BOOL Sound_Out_Line1_bMute_Backup = FALSE;
    MS_BOOL Sound_Out_Line2_bMute_Backup = FALSE;
    MS_BOOL Sound_Out_Line3_bMute_Backup = FALSE;
    MS_BOOL Sound_Out_SPDIF_bMute_Backup = FALSE;

    pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart = FALSE;
    pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish = FALSE;

    //avoid pop noise
    Sound_Out_I2S_bMute_Backup   = pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute;
    Sound_Out_Line0_bMute_Backup = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute;
    Sound_Out_Line1_bMute_Backup = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute;
    Sound_Out_Line2_bMute_Backup = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute;
    Sound_Out_Line3_bMute_Backup = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute;
    Sound_Out_SPDIF_bMute_Backup = pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute;

    AU_CUS_SetI2SOutMute(TRUE);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_0, TRUE);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_1, TRUE);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_2, TRUE);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_3, TRUE);
    AU_CUS_SetSPDIFOutMute(TRUE);

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Init_Done           = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Init_Done);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart   = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish   = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish);
    AU_nDBG("[g_api_audio_InitializeModule_R2_bActive                       = %d] \n", (unsigned int)g_api_audio_InitializeModule_R2_bActive);

    //write audio pre-init table
    MApi_AUDIO_WritePreInitTable();

    //wait for AMP init
    AU_CUS_Delay1MS(1);

    //audio init
    MApi_AUDIO_Initialize();

    #if(CUSTOMIZED_INTERNAL_PATCH_STR_RESUME_ADC_FAST_CHARGE_ENABLE)
    {
        //ADC Fast charge (Begin)
        AU_CUS_WriteAbsMaskReg(REG_ADC_FAST_CHARGE, 0x1000, 0x1000);
    }
    #endif

    #if(UTPA_SUPPORT_AC3P_INFOTYPE_HDMITX_BYPASS_ENABLE)
    {
        //reset g_DDPBypassenable_1 and g_DDPBypassenable_2 to default value for HDMI RX monitor
        MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, DDPBYPASSENABLE_1_DEFAULT, 0);
        MApi_AUDIO_SetAC3PInfo(Audio_AC3P_infoType_hdmiTxBypass_enable, DDPBYPASSENABLE_2_DEFAULT, 1);
    }
    #endif

    //set device default capability
    Digital_Out_Device_Capability_t Device_Capability;
    Device_Capability.support_codec = 1;
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DD , &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_AAC, &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DDP, &Device_Capability);
    MApi_AUDIO_DigitalOut_SetDeviceCapability(DIGITAL_HDMI_ARC_OUTPUT, CODEC_DTS, &Device_Capability);

    #if(CUSTOMIZED_INTERNAL_PATCH_ADEC0_INITIAL_CODEC_TYPE_AC3_ENABLE)
    {
        AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
        AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_CODEC_TYPE_AC3);
    }
    #endif

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay  = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect    = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode   = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode);

    if(pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
    {
        AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect);
        AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC0, pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec);
        AU_CUS_StartDecoding(API_AUDIO_CUSTOMER_ADEC0);
        AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC0,  pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode);
    }

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay  = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect    = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode   = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode);

    if(pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
    {
        AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC1, pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect);
        AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC1, pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec);
        AU_CUS_StartDecoding(API_AUDIO_CUSTOMER_ADEC1);
        AU_CUS_SetSyncMode(API_AUDIO_CUSTOMER_ADEC1,  pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode);
    }

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay    = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect      = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType = 0x%x] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType);

    if(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay == API_AUDIO_CUSTOMER_UPPER_PLAY)
    {
        AU_CUS_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_ATV, pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect);
        AU_CUS_SetCodecType(API_AUDIO_CUSTOMER_ADEC_ATV, pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType);
        AU_CUS_StartDecoding(API_AUDIO_CUSTOMER_ADEC_ATV);
    }

    if(pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode > API_AUDIO_CUSTOMER_DOLBY_DRC_MODE_INVALID)
    {
        AU_CUS_SetAudioParam(API_AUDIO_CUSTOMER_ADEC0, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE, &pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode);
    }

    if(pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode > API_AUDIO_CUSTOMER_DOLBY_DRC_MODE_INVALID)
    {
        AU_CUS_SetAudioParam(API_AUDIO_CUSTOMER_ADEC1, API_AUDIO_CUSTOMER_ADEC_PARAM_AC3P_DRC_MODE, &pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode);
    }

    AU_CUS_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH5_SOUND, pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect);
    AU_CUS_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH6_SOUND, pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect);
    AU_CUS_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH8_SOUND, pstAudioCustomerShmData->g_audio_customer_CH8_Sound_Connect);

    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5);
    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6);
    AU_CUS_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8);

    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]);
    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]);
    AU_CUS_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]);

    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH5, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]);
    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH6, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]);
    AU_CUS_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM0, API_AUDIO_CUSTOMER_FWM_INPUT_CH8, pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]);

    AU_CUS_SetI2SOutGain(pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Gain);
    AU_CUS_SetI2SOutMute(Sound_Out_I2S_bMute_Backup);

    AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_0, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Gain);
    AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_1, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Gain);
    AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_2, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Gain);
    AU_CUS_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_3, pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Gain);

    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_0, Sound_Out_Line0_bMute_Backup);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_1, Sound_Out_Line1_bMute_Backup);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_2, Sound_Out_Line2_bMute_Backup);
    AU_CUS_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_3, Sound_Out_Line3_bMute_Backup);

    AU_CUS_SetSPDIFOutGain(pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Gain);
    AU_CUS_SetSPDIFOutMute(Sound_Out_SPDIF_bMute_Backup);

    pstAudioCustomerShmData->g_audio_customer_Init_Done = TRUE;
    pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish = TRUE;
    g_api_audio_InitializeModule_R2_bActive = TRUE;

    #if(CUSTOMIZED_INTERNAL_PATCH_STR_RESUME_ADC_FAST_CHARGE_ENABLE)
    {
        //ADC Fast charge (End)
        AU_CUS_WriteAbsMaskReg(REG_ADC_FAST_CHARGE, 0x1000, 0x0000);
    }
    #endif

    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_Init_Done           = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_Init_Done);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart   = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bSuspendStart);
    AU_nDBG("[pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish   = %d] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_STR_bResumeFinish);
    AU_nDBG("[g_api_audio_InitializeModule_R2_bActive                       = %d] \n", (unsigned int)g_api_audio_InitializeModule_R2_bActive);

    return TRUE;
}

/* Connect & Disconnect */
MS_BOOL API_AUDIO_CUSTOMER_SetParserMode(API_AUDIO_CUSTOMER_PARSER_MODE ParserMode)
{
    AU_nDBG("[ParserMode = 0x%x] \n", (unsigned int)ParserMode);

    pstAudioCustomerShmData->g_audio_customer_PARSER_Mode = ParserMode;

    ////////////////////////////////////////////////////////////////////////////////
    // mode 0:
    //            AFIFO_0-> ES1
    //            AFIFO_1-> ES2
    //            AFIFO_2-> ES3
    //            AFIFO_3-> ES4
    // mode 1:
    //            AFIFO_2-> ES1
    //            AFIFO_3-> ES2
    //            AFIFO_0-> ES3
    //            AFIFO_1-> ES4
    // mode 2:
    //            AFIFO_1-> ES1
    //            AFIFO_2-> ES2
    //            AFIFO_0-> ES3
    //            AFIFO_3-> ES4
    // mode 3:
    //            AFIFO_0-> ES1
    //            AFIFO_2-> ES2
    //            AFIFO_1-> ES3
    //            AFIFO_3-> ES4
    ////////////////////////////////////////////////////////////////////////////////
    switch(ParserMode)
    {
        case API_AUDIO_CUSTOMER_PARSER_MODE_0:
        {
            pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO0;
            pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO1;
            pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO2;
            pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO3;
        }
        break;

        case API_AUDIO_CUSTOMER_PARSER_MODE_1:
        {
            pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO2;
            pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO3;
            pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO0;
            pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO1;
        }
        break;

        case API_AUDIO_CUSTOMER_PARSER_MODE_2:
        {
            pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO1;
            pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO2;
            pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO0;
            pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO3;
        }
        break;

        case API_AUDIO_CUSTOMER_PARSER_MODE_3:
        {
            pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO0;
            pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO2;
            pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO1;
            pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect = API_AUDIO_CUSTOMER_PARSER_INPUT_AFIFO3;
        }
        break;

        default:
        break;
    }

    MApi_AUDIO_SetCommAudioInfo(Audio_Comm_infoType_Set_Parser, (MS_U32)ParserMode, 0);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_ADEC_Connect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADEC_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_ADEC_Connect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_ADEC_Disconnect(API_AUDIO_CUSTOMER_ADEC_INDEX currentConnect)
{
    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    return AU_CUS_ADEC_Disconnect(currentConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_ADC_Connect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)
{
    AU_nDBG("[currentConnect = 0x%x][portNum = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)portNum);

    return AU_CUS_ADC_Connect(currentConnect, portNum);
}

MS_BOOL API_AUDIO_CUSTOMER_ADC_Disconnect(API_AUDIO_CUSTOMER_ADC_INDEX currentConnect, API_AUDIO_CUSTOMER_ADC_IN_PORT portNum)
{
    AU_nDBG("[currentConnect = 0x%x][portNum = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)portNum);

    return AU_CUS_ADC_Disconnect(currentConnect, portNum);
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_Mixer_Connect(API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_Mixer_Disconnect(API_AUDIO_CUSTOMER_PCM_MIXER_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_MIXER_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_CH_Sound_Connect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)
{
    AU_nDBG("[currectChannel = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_CH_Sound_Connect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_CH_Sound_Disconnect(API_AUDIO_CUSTOMER_CH_SOUND currentConnect, API_AUDIO_CUSTOMER_CH_INPUT inputConnect)
{
    AU_nDBG("[currectChannel = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_CH_Sound_Disconnect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_FW_MIXER_Connect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_FW_MIXER_Connect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_FW_MIXER_Disconnect(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_FW_MIXER_Disconnect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_SE_Connect(API_AUDIO_CUSTOMER_SE_INDEX currentConnect, API_AUDIO_CUSTOMER_SE_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_SE_Disconnect(API_AUDIO_CUSTOMER_SE_INDEX currentConnect, API_AUDIO_CUSTOMER_SE_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_SNDOUT_Connect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_SNDOUT_Connect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_SNDOUT_Disconnect(API_AUDIO_CUSTOMER_SOUNDOUT_INDEX currentConnect, API_AUDIO_CUSTOMER_SOUNDOUT_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    return AU_CUS_SNDOUT_Disconnect(currentConnect, inputConnect);
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect = inputConnect;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect = inputConnect;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE2:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Connect = inputConnect;
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_CAPTURE_Disconnect(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT inputConnect)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE2:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Connect = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_INVALID;
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MP3_ENC_Connect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect)
{
    AU_nDBG("[inputConnect = 0x%x] \n", (unsigned int)inputConnect);

    pstAudioCustomerShmData->g_audio_customer_MP3_ENC_Connect = inputConnect;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MP3_ENC_Disconnect(API_AUDIO_CUSTOMER_MP3_ENC_INPUT inputConnect)
{
    AU_nDBG("[inputConnect = 0x%x] \n", (unsigned int)inputConnect);

    pstAudioCustomerShmData->g_audio_customer_MP3_ENC_Connect = API_AUDIO_CUSTOMER_MP3_ENC_INPUT_INVALID;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AAC_ENC_Connect(API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect)
{
    AU_nDBG("[inputConnect = 0x%x] \n", (unsigned int)inputConnect);

    pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect = inputConnect;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AAC_ENC_Disconnect(API_AUDIO_CUSTOMER_AAC_ENC_INPUT inputConnect)
{
    AU_nDBG("[inputConnect = 0x%x] \n", (unsigned int)inputConnect);

    pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect = API_AUDIO_CUSTOMER_AAC_ENC_INPUT_INVALID;

    return TRUE;
}

/* Start & Stop */
MS_BOOL API_AUDIO_CUSTOMER_SetCodecType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE audioType)
{
    AU_nDBG("[adecIndex = 0x%x] [audioType = 0x%x] \n", (unsigned int)adecIndex, (unsigned int)audioType);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec = audioType;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec = audioType;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType = audioType;
        }
        break;

        default:
            break;
    }

    return AU_CUS_SetCodecType(adecIndex, audioType);
}

MS_BOOL API_AUDIO_CUSTOMER_StartDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    return AU_CUS_StartDecoding(adecIndex);
}

MS_BOOL API_AUDIO_CUSTOMER_StopDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    return AU_CUS_StopDecoding(adecIndex);
}

MS_BOOL API_AUDIO_CUSTOMER_PauseDecoding(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    return AU_CUS_PauseDecoding(adecIndex);
}

MS_BOOL API_AUDIO_CUSTOMER_SetMainDecoderOutput(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput = adecIndex;

    if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC0)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect));
    }
    else if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC1)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect));
    }
    else if(pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput == API_AUDIO_CUSTOMER_ADEC_ATV)
    {
        AU_CUS_SetSourceInfo(AU_CUS_ConvertCustomerADECSourceToDriverSourceType(pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect));
    }

    return TRUE;
}

/* SPDIF */
MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType(API_AUDIO_CUSTOMER_SPDIF_TX_MODE eSPDIFMode)
{
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType = eSPDIFMode;

    AU_nDBG("[eSPDIFMode = 0x%x] \n", (unsigned int)eSPDIFMode);

    AU_CUS_SPDIF_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType);

    return TRUE;
}

API_AUDIO_CUSTOMER_SPDIF_TX_MODE API_AUDIO_CUSTOMER_SPDIF_TX_GetOutputType(void)
{
    API_AUDIO_CUSTOMER_SPDIF_TX_MODE Ret = API_AUDIO_CUSTOMER_SPDIF_TX_MODE_INVALID;

    AUDIO_SPDIF_OUTPUT_TYPE mode = (AUDIO_SPDIF_OUTPUT_TYPE)MApi_AUDIO_SPDIF_GetMode();
    switch(mode)
    {
        case SPDIF_OUT_PCM:
        {
            Ret = API_AUDIO_CUSTOMER_SPDIF_TX_PCM;
        }
        break;

        case SPDIF_OUT_AUTO:
        {
            if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType == API_AUDIO_CUSTOMER_SPDIF_TX_AUTO)
            {
                Ret = API_AUDIO_CUSTOMER_SPDIF_TX_AUTO;
            }
            else if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType == API_AUDIO_CUSTOMER_SPDIF_TX_DD)
            {
                Ret = API_AUDIO_CUSTOMER_SPDIF_TX_DD;
            }
            else
            {
                Ret = API_AUDIO_CUSTOMER_SPDIF_TX_AUTO;
            }
        }
        break;

        case SPDIF_OUT_BYPASS:
        {
            #if(CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_ENABLE && CUSTOMIZED_INTERNAL_PATCH_DDP_71_AUTO_BYPASS_TV_HDMI_ARC)
            {
                if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType == API_AUDIO_CUSTOMER_SPDIF_TX_AUTO)
                {
                    Ret = API_AUDIO_CUSTOMER_SPDIF_TX_AUTO;
                }
                else if(pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType == API_AUDIO_CUSTOMER_SPDIF_TX_DD)
                {
                    Ret = API_AUDIO_CUSTOMER_SPDIF_TX_DD;
                }
                else
                {
                    Ret = API_AUDIO_CUSTOMER_SPDIF_TX_AUTO;
                }
            }
            #else
            {
                Ret = API_AUDIO_CUSTOMER_SPDIF_TX_BYPASS;
            }
            #endif
        }
        break;

        case SPDIF_OUT_TRANSCODE:
        {
            Ret = API_AUDIO_CUSTOMER_SPDIF_TX_TRANSCODE;
        }
        break;

        case SPDIF_OUT_NONE:
        {
            Ret = API_AUDIO_CUSTOMER_SPDIF_TX_NONE;
        }
        break;

        default:
        {
            Ret = API_AUDIO_CUSTOMER_SPDIF_TX_NONE;
        }
        break;
    }

    AU_nDBG("[Ret = 0x%x] \n", (unsigned int)Ret);

    return Ret;
}

MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_SetCopyInfo(API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT copyInfo)
{
    AU_nDBG("[copyInfo = 0x%x] \n", (unsigned int)copyInfo);

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_CopyInfo = copyInfo;

    switch(copyInfo)
    {
        case API_AUDIO_CUSTOMER_SPDIF_COPY_FREE:    /* cp-bit : 1, L-bit : 0 */
        {
            MApi_AUDIO_SPDIF_SetSCMS(1, 0);
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_COPY_NO_MORE: /* cp-bit : 0, L-bit : 1 */
        {
            MApi_AUDIO_SPDIF_SetSCMS(1, 0);
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_COPY_ONCE:    /* cp-bit : 0, L-bit : 0 */
        {
            MApi_AUDIO_SPDIF_SetSCMS(0, 0);
        }
        break;

        case API_AUDIO_CUSTOMER_SPDIF_COPY_NEVER:   /* cp-bit : 0, L-bit : 1 */
        {
            MApi_AUDIO_SPDIF_SetSCMS(0, 1);
        }
        break;

        default:
        {
            MApi_AUDIO_SPDIF_SetSCMS(0, 0);
        }
        break;

    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_SetCategoryCode(MS_U8 categoryCode)
{
    AU_nDBG("[categoryCode = 0x%x] \n", (unsigned int)categoryCode);

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_CategoryCode = categoryCode;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_SetLightOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_LightOnOff = bOnOff;

    MApi_AUDIO_SPDIF_HWEN(bOnOff);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_SetMonitorOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_MonitorOnOff = bOnOff;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SPDIF_TX_ChannelStatus_CTRL(API_AUDIO_CUSTOMER_SPDIF_CS_TYPE cs_mode, API_AUDIO_CUSTOMER_SPDIF_CS_TYPE_STATUS status)
{
    AU_nDBG("[cs_mode = 0x%x] [status = 0x%x]\n", (unsigned int)cs_mode, (unsigned int)status);

    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_ChannelStatus_Type = cs_mode;
    pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_ChannelStatus_Type_Status = status;

    MApi_AUDIO_SPDIF_ChannelStatus_CTRL(cs_mode, status);

    return TRUE;
}

/* HDMI */
MS_BOOL API_AUDIO_CUSTOMER_HDMI_RX_GetAudioMode(API_AUDIO_CUSTOMER_CODEC_TYPE *pHDMIMode)
{
    AU_CUS_HDMI_RX_GetAudioMode();

    *pHDMIMode = pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Current_Codec_Type;

    AU_nThreadDBG("[HDMI Mode = 0x%x] \n", *((unsigned int *)pHDMIMode));

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_HDMI_RX_GetCopyInfo(API_AUDIO_CUSTOMER_SPDIF_COPYRIGHT *pCopyInfo)
{
    *pCopyInfo = API_AUDIO_CUSTOMER_SPDIF_COPY_ONCE;

    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_CopyInfo = *pCopyInfo;

    AU_nThreadDBG("[*pCopyInfo = 0x%x] \n", *pCopyInfo);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_HDMI_RX_SetAudioReturnChannel(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_AudioReturnChannel = bOnOff;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_HDMI_RX_SetMonitorOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_HDMI_RX_MonitorOnOff = bOnOff;

    if(bOnOff == FALSE)
    {
        pstAudioCustomerShmData->g_audio_customer_HDMI_RX_Previous_Codec_Type = API_AUDIO_CUSTOMER_CODEC_TYPE_UNKNOWN;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType(API_AUDIO_CUSTOMER_HDMI_TX_OUTPUT_TYPE eHDMIMode)
{
    AU_nDBG("[eHDMIMode = 0x%x] \n", (unsigned int)eHDMIMode);
#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType = eHDMIMode;
    AU_CUS_HDMI_TX_SetOutputType(pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType);
    return TRUE;
#else
    AU_nPRINT("TV don't support API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType\n");
    return FALSE;
#endif
}

MS_BOOL API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);
#ifdef CONFIG_API_HDMITX //TV dont have HDMI TX
    pstAudioCustomerShmData->g_audio_customer_HDMI_TX_MonitorOnOff = bOnOff;
    return TRUE;
#else
    AU_nPRINT("TV don't support API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff\n");
    return FALSE;
#endif
}

/* ATV */
MS_BOOL API_AUDIO_CUSTOMER_SIF_SetInputSource(API_AUDIO_CUSTOMER_SIF_INPUT sifSource)
{
    AU_nDBG("[sifSource = %d] \n", (unsigned int)sifSource);

    switch(sifSource)
    {
        case API_AUDIO_CUSTOMER_SIF_INPUT_EXTERNAL:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_SET_ADC_FROM_VIF_PATH, FALSE, 0); // set SIF mode
        }
        break;
        case API_AUDIO_CUSTOMER_SIF_INPUT_INTERNAL:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_SET_ADC_FROM_VIF_PATH, TRUE, 0); // set VIF mode
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetHighDevMode(API_AUDIO_CUSTOMER_SIF_HIDEV_BW bandwidth, MS_BOOL bOnOff)
{
    AU_nDBG("[bandwidth = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)bandwidth, (unsigned int)bOnOff);

    switch(bOnOff)
    {
        case TRUE:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_ENABLE_HIDEV, TRUE, 0);
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_SET_HIDEV_FILTER_BW_LEVEL, bandwidth, 0);
        }
        break;
        case FALSE:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_ENABLE_HIDEV, FALSE, 0);
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetAudioStandard(API_AUDIO_CUSTOMER_SIF_STANDARD sifStandard)
{
    AU_nDBG("[sifStandard = 0x%x] \n", (unsigned int)sifStandard);

    if((sifStandard < API_AUDIO_CUSTOMER_SIF_BG) || (sifStandard > API_AUDIO_CUSTOMER_SIF_M_EIA_J))
    {
         return FALSE;
    }

    SIF_AudioStandard = sifStandard;

    MApi_AUDIO_SIF_SetStandard((AUDIOSTANDARD_TYPE)sifStandard);

    switch(sifStandard)
    {
        case API_AUDIO_CUSTOMER_SIF_BG:
        case API_AUDIO_CUSTOMER_SIF_DK:
        case API_AUDIO_CUSTOMER_SIF_M:
        {
            if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_MONO))
            {
                MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_MONO);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_SIF_BG_A2:
        case API_AUDIO_CUSTOMER_SIF_DK1_A2:
        case API_AUDIO_CUSTOMER_SIF_DK2_A2:
        case API_AUDIO_CUSTOMER_SIF_DK3_A2:
        case API_AUDIO_CUSTOMER_SIF_M_A2:
        {
            if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_A2))
            {
                MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_A2);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_SIF_I:
        {
            if(MApi_AUDIO_SIF_GetSoundMode() >= E_AUDIOMODE_NICAM_MONO && MApi_AUDIO_SIF_GetSoundMode() <= E_AUDIOMODE_NICAM_DUAL_AB)
            {
                MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_NICAM);
            }
            else
            {
                MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_MONO);
            }
        }
        break;

        case API_AUDIO_CUSTOMER_SIF_BG_NICAM:
        case API_AUDIO_CUSTOMER_SIF_DK_NICAM:
        case API_AUDIO_CUSTOMER_SIF_L:
        {
            if(FALSE == MApi_AUDIO_SIF_IsPALType(AU_SIF_PAL_NICAM))
            {
                MApi_AUDIO_SIF_SetPALType(AU_SIF_PAL_NICAM);
            }
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetSoundMode(API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE u8SifSoundMode)
{
    AU_nDBG("[u8SifSoundMode = 0x%x] \n", (unsigned int)u8SifSoundMode);

    SIF_AudioMode = (AUDIOMODE_TYPE)u8SifSoundMode;
    MApi_AUDIO_SIF_SetSoundMode((MS_U8)u8SifSoundMode);
    return TRUE;
}

API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE API_AUDIO_CUSTOMER_SIF_GetSoundMode(void)
{
    API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE Ret = API_AUDIO_CUSTOMER_SIF_AUDIOMODE_INVALID;
    AUDIOSTATUS eCurrentAudioStatus;

    MApi_AUDIO_SIF_GetAudioStatus(&eCurrentAudioStatus);

    Ret = (API_AUDIO_CUSTOMER_SIF_AUDIOMODE_TYPE)MApi_AUDIO_SIF_GetSoundMode();

    AU_nThreadDBG("[Ret = 0x%x] \n", (unsigned int)Ret);

    return Ret;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetMonitorOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_SIF_MonitorOnOff = bOnOff;

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetAutoMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    switch(bOnOff)
    {
        case TRUE:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_ENABLE_AUTO_MUTE, TRUE, 0);
        }
        break;
        case FALSE:
        {
            MApi_AUDIO_SIF_SendCmd(MSAPI_AUD_SIF_CMD_ENABLE_AUTO_MUTE, FALSE, 0);
        }
        break;
        default:
            break;
    }

    return TRUE;
}

API_AUDIO_CUSTOMER_SIF_STANDARD API_AUDIO_CUSTOMER_SIF_StartAutoStandardDetection(void)
{
    AU_nDBG("\n");

    MApi_AUDIO_SIF_StartAutoStandardDetection(); //Set Command
    AU_CUS_Delay1MS(50); //@todo: need fine tune

    return (API_AUDIO_CUSTOMER_SIF_STANDARD)MApi_AUDIO_SIF_GetResultOfAutoStandardDetection(); //Get Result
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetThreshold(API_AUDIO_CUSTOMER_SIF_THR_TBL_TYPE *ThrTbl)
{
    AU_nDBG("\n");

    MApi_AUDIO_SIF_SetThreshold((THR_TBL_TYPE*)ThrTbl);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetPALType(API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type)
{
    AU_nThreadDBG("[pal_type = 0x%x] \n", (unsigned int)pal_type);

    MApi_AUDIO_SIF_SetPALType((AUDIO_SIF_PAL_TYPE)pal_type);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SendCmd(API_AUDIO_CUSTOMER_SIF_CmdType enAudSifCommand, MS_U8 comm_arg1, MS_U8 comm_arg2)
{
    AU_nDBG("[enAudSifCommand = 0x%x] [comm_arg1 = 0x%x] [comm_arg2 = 0x%x] \n", (unsigned int)enAudSifCommand, (unsigned int)comm_arg1, (unsigned int)comm_arg2);

    MApi_AUDIO_SIF_SendCmd((En_AUD_SIF_CmdType)enAudSifCommand, (MS_U8)comm_arg1, (MS_U8)comm_arg2);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_GetAudioStatus(API_AUDIO_CUSTOMER_SIF_AUDIOSTATUS *eCurrentAudioStatus)
{
    MS_BOOL Ret = FALSE;

    AUDIOSTATUS CurrentCarrierStatus = E_STATE_AUDIO_NO_CARRIER;
    Ret = MApi_AUDIO_SIF_GetAudioStatus(&CurrentCarrierStatus);
    *eCurrentAudioStatus = CurrentCarrierStatus;

    AU_nThreadDBG("[*eCurrentAudioStatus = 0x%x]\n", (unsigned int)(*eCurrentAudioStatus));

    return Ret;
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_IsPALType(API_AUDIO_CUSTOMER_SIF_PAL_TYPE pal_type)
{
    AU_nDBG("[pal_type = 0x%x] \n", pal_type);

    return MApi_AUDIO_SIF_IsPALType((AUDIO_SIF_PAL_TYPE)pal_type);
}

MS_BOOL API_AUDIO_CUSTOMER_SIF_SetPrescale(API_AUDIO_CUSTOMER_SIF_GAIN_TYPE gain_type, MS_S32 db_value)
{
    AU_nDBG("[db_value = 0x%x] \n", (unsigned int)db_value);

    MApi_AUDIO_SIF_SetPrescale((AUDIO_SIF_GAIN_TYPE)gain_type, db_value);

    return TRUE;
}

/* Decoder */
MS_BOOL API_AUDIO_CUSTOMER_SetSyncMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)
{
    AU_nDBG("[adecIndex = 0x%X] [bOnOff = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);

    return AU_CUS_SetSyncMode(adecIndex, bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_GetDecodingType(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CODEC_TYPE *pAudioType)
{
    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            *pAudioType = pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            *pAudioType = pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC_ATV:
        {
            *pAudioType = pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType;
        }
        break;

        default:
            break;
    }

    AU_nThreadDBG("[adecIndex = 0x%X][*pAudioType = 0x%X]\n", (unsigned int)adecIndex, (unsigned int)*pAudioType);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetDualMonoOutMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_DUALMONO_MODE outputMode)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x] [outputMode = 0x%x] \n", (unsigned int)adecIndex, (unsigned int)outputMode);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode = outputMode;
        }
        break;
        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode = outputMode;
        }
        break;

        default:
            break;
    }
    MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_SoundMode, (MS_U32)outputMode);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_GetESInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, void * pAudioESInfo)
{
    /* Need to refine log */
    AU_nThreadDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_IsESExist(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;
    MS_U32 es_exist = 0;

    AU_nThreadDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_DecStatus, (void *)&es_exist);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_bESExist = (MS_BOOL)es_exist;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_bESExist = (MS_BOOL)es_exist;
        }
        break;

        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetAudioDescription(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_BOOL bOnOff)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = %u] [bOnOff = %u] \n", (unsigned int)adecIndex, (unsigned int)bOnOff);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_bMain = bOnOff;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_bMain = bOnOff;
        }
        break;

        default:
            break;
    }

    switch(bOnOff)
    {
        case TRUE:
        {
            MApi_AUDIO_SetADOutputMode(AD_OUT_BOTH);
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, (MS_U32)MMA_PLAY_AD);
        }
        break;
        case FALSE:
        {
            MApi_AUDIO_SetADOutputMode(AD_OUT_NONE);
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, (MS_U32)MMA_STOP_AD);
        }
        break;
        default:
            break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetTrickMode(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_TRICK_MODE eTrickMode)
{
    MS_BOOL syncMode = FALSE;
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%X] [eTrickMode = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)eTrickMode);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_TrickMode = eTrickMode;
            syncMode = pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_TrickMode = eTrickMode;
            syncMode = pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode;
        }
        break;

        default:
            break;
    }

    if (eTrickMode == API_AUDIO_CUSTOMER_TRICK_NONE)
    {
        if(syncMode)
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_AVSYNC);
        }
        else
        {
            MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_FREERUN);
        }
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_GetBufferStatus(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 *pMaxSize, MS_U32 *pFreeSize)
{
    MS_U32 *pCurrLevel = 0;

    AUDIO_DEC_ID DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);


    if(pMaxSize != NULL && pCurrLevel != NULL )
    {
        MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_UNI_ES_Size, (void*)pMaxSize);
        MApi_AUDIO_GetAudioInfo2(DecID, Audio_infoType_esBuf_currLevel, (void*)pCurrLevel);
        *pFreeSize = *pMaxSize - *pCurrLevel;
    }
    else
    {
        return FALSE;
    }

    AU_nDBG("[adecIndex = 0x%X] [pMaxSize = 0x%X] [pFreeSize = 0x%X]\n", (unsigned int)adecIndex, *((unsigned int *)pMaxSize), *((unsigned int *)pFreeSize));

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetAdecPcmPath(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_ADEC_PCM_PATH pcmPath)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%X] [pcmPath = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)pcmPath);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath = pcmPath;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath = pcmPath;
        }
        break;

        default:
            break;
    }

    if(pcmPath == API_AUDIO_CUSTOMER_ADEC_PCM_PATH_MCU)
    {
        AU_CUS_AdecPcmInit(DecID, FALSE);
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AdecPcmReady(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    API_AUDIO_MM_PCM_Info* pPcmInfo;

    if ( pAdecPcmHandle == NULL )
    {
        AU_nPRINT("pAdecPcmHandle i null");
        return FALSE;
    }

    AUDIO_DEC_ID decID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    pPcmInfo = &pAdecPcmHandle->PcmInfo;

    if ( MApi_AUDIO_GetAudioInfo2(decID, Audio_infoType_UNI_PCM1_Info, (void *)pPcmInfo ) != TRUE )
    {
        AU_nPRINT("can not get PCM1 Info");
        return FALSE;
    }

    if ( pAdecPcmHandle->u32LastDecodeFrame == pPcmInfo->U32DecodeFrame )
    {
        return FALSE;
    }

    AU_nDBG("%s: U32DecodeFrame=%u, U32WrtAddr=%p, U32WrtBytes=%u\r\n", __FUNCTION__, (unsigned int)pPcmInfo->U32DecodeFrame, (void *) pPcmInfo->U32WrtAddr, (unsigned int)pPcmInfo->U32WrtBytes);

    pAdecPcmHandle->u32LastDecodeFrame = pPcmInfo->U32DecodeFrame;

    return TRUE;
}

MS_U32 API_AUDIO_CUSTOMER_AdecPcmGet(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, void * pOutPcm, MS_U32 u32Size)
{
    API_AUDIO_MM_PCM_BufControl * pPcmCtrl = NULL;
    MS_U32 u32Size_temp = 0;
    volatile void * pSrcVPtr;

    if ( pAdecPcmHandle == NULL )
    {
        return 0;
    }

    AUDIO_DEC_ID decID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    pPcmCtrl = &pAdecPcmHandle->PcmBuf;
    pPcmCtrl->u32BufWrPtr = pAdecPcmHandle->PcmInfo.U32WrtAddr;

    if(u32Size > pAdecPcmHandle->PcmInfo.U32WrtBytes)   u32Size = pAdecPcmHandle->PcmInfo.U32WrtBytes;

    if ((pPcmCtrl->u32BufEndAddr - pPcmCtrl->u32BufWrPtr) >= u32Size)
    {
        pSrcVPtr = (volatile void *) MsOS_MPool_PA2KSEG1(pPcmCtrl->u32BufWrPtr);

        memcpy(pOutPcm, (void *) pSrcVPtr, u32Size);
    }
    else
    {
        volatile MS_U8 *u32_dstPtr;

        //copy tail
        u32_dstPtr = (volatile MS_U8 *)pOutPcm;
        pSrcVPtr = (volatile void *) MsOS_MPool_PA2KSEG1(pPcmCtrl->u32BufWrPtr);
        u32Size_temp = pPcmCtrl->u32BufEndAddr - pPcmCtrl->u32BufWrPtr;

        memcpy((void *) u32_dstPtr, (void *) pSrcVPtr, u32Size_temp);

        //copy head
        u32_dstPtr = u32_dstPtr + u32Size_temp;
        pSrcVPtr = (volatile void *) MsOS_MPool_PA2KSEG1(pPcmCtrl->u32BufStartAddr);
        u32Size_temp = u32Size - u32Size_temp;

        memcpy((void *) u32_dstPtr, (void *) pSrcVPtr, u32Size_temp);
    }

    if (pAU_AdecPcmDumpFile != NULL && pstAudioCustomerShmData->g_audio_customer_bEnableAdecPcmDump == TRUE)
    {
        AU_CUS_FileWrite((void*)pOutPcm, sizeof(MS_U8), pAdecPcmHandle->PcmInfo.U32WrtBytes, pAU_AdecPcmDumpFile);
    }

    MsOS_FlushMemory();

    MApi_AUDIO_SetAudioParam2(decID, Audio_ParamType_UNI_PCMOutCnt, u32Size);

    return u32Size;
}

MS_BOOL API_AUDIO_CUSTOMER_AdecRegisterDecodeDoneCallback(pfnAudioCustomerAdecDecodeDone pfnDecodeDoneCallBack)
{
    AU_nDBG("[pfnDecodeDoneCallBack = 0x%X] \n", (unsigned int)pfnDecodeDoneCallBack);
    madCallBack.pFunc_AdecDecDone = pfnDecodeDoneCallBack;
    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AdecRegisterEndOfStreamCallback(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, pfnAudioCustomerAdecEndOfStream pfnEndOfStreamCallBack)
{
    AU_nDBG("[adecIndex = 0x%x][pfnEndOfStreamCallBack = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)pfnEndOfStreamCallBack);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            if(pfnEndOfStreamCallBack)
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister = TRUE;
                madCallBack.pFunc_Adec0_EndOfStream = pfnEndOfStreamCallBack;
            }
            else
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister = FALSE;
                madCallBack.pFunc_Adec0_EndOfStream = NULL;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            if(pfnEndOfStreamCallBack)
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister = TRUE;
                madCallBack.pFunc_Adec1_EndOfStream = pfnEndOfStreamCallBack;
            }
            else
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister = FALSE;
                madCallBack.pFunc_Adec1_EndOfStream = NULL;
            }
        }
        break;

        default:
        {
            AU_nDBG("\n");
            pstAudioCustomerShmData->g_audio_customer_ADEC0_End_Of_Stream_bRegister = FALSE;
            pstAudioCustomerShmData->g_audio_customer_ADEC1_End_Of_Stream_bRegister = FALSE;
            madCallBack.pFunc_Adec0_EndOfStream = NULL;
            madCallBack.pFunc_Adec1_EndOfStream = NULL;
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AdecRegisterUnderrunCallback(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, pfnAudioCustomerAdecUnderrun pfnUnderrunCallBack)
{
    AU_nDBG("[adecIndex = 0x%x][pfnUnderrunCallBack = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)pfnUnderrunCallBack);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            if(pfnUnderrunCallBack)
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_bRegister = TRUE;
                madCallBack.pFunc_Adec0_Underrun= pfnUnderrunCallBack;
            }
            else
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_bRegister = FALSE;
                madCallBack.pFunc_Adec0_Underrun = NULL;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            if(pfnUnderrunCallBack)
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_bRegister = TRUE;
                madCallBack.pFunc_Adec1_Underrun = pfnUnderrunCallBack;
            }
            else
            {
                AU_nDBG("\n");
                pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_bRegister = FALSE;
                madCallBack.pFunc_Adec1_Underrun = NULL;
            }
        }
        break;

        default:
        {
            AU_nDBG("\n");
            pstAudioCustomerShmData->g_audio_customer_ADEC0_Underrun_bRegister = FALSE;
            pstAudioCustomerShmData->g_audio_customer_ADEC1_Underrun_bRegister = FALSE;
            madCallBack.pFunc_Adec0_Underrun = NULL;
            madCallBack.pFunc_Adec1_Underrun = NULL;
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_Auto_Recovery_SetMonitorOnOff(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_Auto_Recovery_MonitorOnOff = bOnOff;

    return TRUE;
}

/* Common Decoder */
MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Open(void * pData)
{
    AU_nDBG("\n");

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Open(pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Close(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Close(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Start(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Start(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Stop(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Stop(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Set(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Set(s32DeviceID, Cmd, pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Get(MS_S32 s32DeviceID, API_AUDIO_CUSTOMER_COMMON_DECODER_COMMAND Cmd, void* pData)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Get(s32DeviceID, Cmd, pData);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_U32 API_AUDIO_CUSTOMER_COMMON_DECODER_Read(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)
{
    AU_nDBG("[s32DeviceID = %ld] [u32Size = 0x%x] \n", (signed long)s32DeviceID, (unsigned int)u32Size);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Read(s32DeviceID, pBuf, u32Size);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_U32 API_AUDIO_CUSTOMER_COMMON_DECODER_Write(MS_S32 s32DeviceID, void* pBuf, MS_U32 u32Size)
{
    AU_nDBG("[s32DeviceID = %ld] [u32Size = 0x%x] \n", (signed long)s32DeviceID, (unsigned int)u32Size);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Write(s32DeviceID, pBuf, u32Size);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

MS_S32 API_AUDIO_CUSTOMER_COMMON_DECODER_Flush(MS_S32 s32DeviceID)
{
    AU_nDBG("[s32DeviceID = %ld] \n", (signed long)s32DeviceID);

    #if(UTPA_SUPPORT_COMMON_DECODER_API)
    {
        return AU_CUS_COMMON_DECODER_Flush(s32DeviceID);
    }
    #else
    {
        return FALSE;
    }
    #endif //#if(UTPA_SUPPORT_COMMON_DECODER_API)
}

/* Common */
MS_BOOL API_AUDIO_CUSTOMER_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_PARAM_TYPE paramType, void *pParam)
{
    AU_nThreadDBG("[adecIndex = 0x%X] [paramType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)paramType);

    return AU_CUS_SetAudioParam(adecIndex, paramType, pParam);
}

MS_BOOL API_AUDIO_CUSTOMER_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_INFO_TYPE infoType, void *pInfo)
{
    AU_nThreadDBG("[adecIndex = 0x%X] [infoType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)infoType);

    return AU_CUS_GetAudioInfo(adecIndex, infoType, pInfo);
}

/* Customized patch */
MS_BOOL API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_PARAM_TYPE paramType, void *pParam)
{
    AU_nThreadDBG("[adecIndex = 0x%X] [paramType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)paramType);

    return AU_CUS_PATCH_SetAudioParam(adecIndex, paramType, pParam);
}

MS_BOOL API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMIZED_PATCH_INFO_TYPE infoType, void *pInfo)
{
    AU_nThreadDBG("[adecIndex = 0x%X] [infoType = 0x%X] \n", (unsigned int)adecIndex, (unsigned int)infoType);

    return AU_CUS_PATCH_GetAudioInfo(adecIndex, infoType, pInfo);
}

/* Clip Play for ES */
MS_BOOL API_AUDIO_CUSTOMER_PlayClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_CLIP_DEC_PARAM clipInfo, MS_U32 bufSize, void *pBufClip, pfnAudioCustomerAdecoderClipDone pfnCallBack)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex             = 0x%x] \n", (unsigned int)adecIndex);
    AU_nDBG("[clipInfo.clipType     = 0x%x] \n", (unsigned int)clipInfo.clipType);
    AU_nDBG("[clipInfo.repeatNumber = 0x%x] \n", (unsigned int)clipInfo.repeatNumber);
    AU_nDBG("[bufSize               = 0x%x] \n", (unsigned int)bufSize);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    if(pfnCallBack == NULL)
    {
        AU_nPRINT("[Error] [%s] [Call-Back function is NULL] \n", __FUNCTION__);
        return FALSE;
    }

    madCallBack.pFunc_ClipDec = pfnCallBack;

    // Buffer init
    AU_CUS_ClipDecoderBufInit(DecID);

    // For safety, clean the memory
    memset((void *)(pClipDecESBufInfo->u32BufStartAddr_V), 0, pClipDecESBufInfo->u32BufSize);
    memset((void *)(pClipDecExtBufInfo->u32BufStartAddr_V), 0, pClipDecExtBufInfo->u32BufSize);

    // Save clip info in driver and set play command
    AU_CUS_ClipDecoderPlay(adecIndex, clipInfo);

    // Copy clip data to External buffer
    if(bufSize <= pClipDecExtBufInfo->u32BufSize)
    {
        memcpy((void *)(pClipDecExtBufInfo->u32BufWptr_V), pBufClip, bufSize);
        pClipDecExtBufInfo->u32BufWptr_V += bufSize;
        clipDecoderInfo.address = pBufClip;
        clipDecoderInfo.u32Size = bufSize;
        clipDecoderInfo.u8Sink = adecIndex;
        clipDecoderInfo.decID = DecID;
        clipDecoderInfo.u32RepeatNum = clipInfo.repeatNumber;
        clipDecoderInfo.bIsPause = FALSE;
        clipDecoderInfo.bIsStart = TRUE;
    }
    else
    {
        // Size larger than both ES buffer and external buffer
        AU_nPRINT("[Error] [%s] [ES size(0x%X) is too large] \n", __FUNCTION__, (unsigned int)bufSize);
        return FALSE;
    }


    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_StopClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    clipDecoderInfo.bIsStart = FALSE;

    MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_STOP);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PauseClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    clipDecoderInfo.bIsPause = TRUE;

    MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_PAUSE);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_ResumeClipDecoder(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);

    clipDecoderInfo.bIsPause = FALSE;

    MApi_AUDIO_SetAudioParam2(DecID, Audio_ParamType_playControl, MMA_PLAY_FILE);

    return TRUE;
}


/* Clip Play for PCM */
MS_BOOL API_AUDIO_CUSTOMER_PlayClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex, API_AUDIO_CUSTOMER_CLIP_MIX_PARAM clipInfo, MS_U32 bufSize, void *pBufClip, pfnAudioCustomerAmixerClipDone pfnCallBack)
{
    AU_nDBG("[mixerIndex            = 0x%x] \n", (unsigned int)mixerIndex);
    AU_nDBG("[clipInfo.numOfChannel = 0x%x] \n", (unsigned int)clipInfo.numOfChannel);
    AU_nDBG("[clipInfo.bitPerSample = 0x%x] \n", (unsigned int)clipInfo.bitPerSample);
    AU_nDBG("[clipInfo.samplingFreq = 0x%x] \n", (unsigned int)clipInfo.samplingFreq);
    AU_nDBG("[clipInfo.endianType   = 0x%x] \n", (unsigned int)clipInfo.endianType);
    AU_nDBG("[clipInfo.signedType   = 0x%x] \n", (unsigned int)clipInfo.signedType);
    AU_nDBG("[clipInfo.repeatNumber = 0x%x] \n", (unsigned int)clipInfo.repeatNumber);
    AU_nDBG("[bufSize               = 0x%x] \n", (unsigned int)bufSize);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_StopClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)
{
    AU_nDBG("[mixerIndex = 0x%x] \n", (unsigned int)mixerIndex);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_PauseClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)
{
    AU_nDBG("[mixerIndex = 0x%x] \n", (unsigned int)mixerIndex);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_ResumeClipMixer(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex)
{
    AU_nDBG("[mixerIndex = 0x%x] \n", (unsigned int)mixerIndex);

    return FALSE;
}

/* Gain, Mute & Delay */

/**
 * API_AUDIO_CUSTOMER_SetAudioDescriptionGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetAudioDescriptionGain(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 gain)
{
    int vol1, vol2;
    MS_U32 uAbsVolume;
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nDBG("[adecIndex = 0x%x] \n", (unsigned int)adecIndex);
    AU_nDBG("[gain      = %d]   \n", (unsigned int)gain);

    switch(adecIndex)
    {
        case API_AUDIO_CUSTOMER_ADEC0:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_Gain = gain;
        }
        break;

        case API_AUDIO_CUSTOMER_ADEC1:
        {
            pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_Gain = gain;
        }
        break;

        default:
            break;
    }

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;

    uAbsVolume = ((vol1&0x7F)<<8)+((vol2&0x7)<<5);
    uAbsVolume = uAbsVolume >> 5;

    MApi_AUDIO_SetAudioParam2(DecID, Audio_R2_SHM_PARAM_AD_Volume, uAbsVolume);

    return TRUE;
}

/**
 * API_AUDIO_CUSTOMER_SetPCMMixerInputGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetPCMMixerInputGain(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex, MS_U32 gain)
{
    AU_nDBG("[mixerIndex = 0x%x] \n", (unsigned int)mixerIndex);
    AU_nDBG("[gain       = 0x%x] \n", (unsigned int)gain);

    return FALSE;
}

/**
 * API_AUDIO_CUSTOMER_SetFWMixerChannelGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetFWMixerChannelGain(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_U32 gain)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] [gain = %d] \n", (unsigned int)currentConnect, (unsigned int)inputConnect, (unsigned int)gain);

    return AU_CUS_SetFWMixerChannelGain(currentConnect, inputConnect, gain);
}

/**
 * API_AUDIO_CUSTOMER_SetI2SOutGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetI2SOutGain(MS_U32 gain)
{
    AU_nDBG("[gain = %d] \n", (unsigned int)gain);

    return AU_CUS_SetI2SOutGain(gain);
}

/**
 * API_AUDIO_CUSTOMER_SetLineOutGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetLineOutGain(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_U32 gain)
{
    AU_nDBG("[lineIndex = %d] [gain = %d] \n", (unsigned int)lineIndex, (unsigned int)gain);

    return AU_CUS_SetLineOutGain(lineIndex, gain);
}

/**
 * API_AUDIO_CUSTOMER_SetSPDIFOutGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetSPDIFOutGain(MS_U32 gain)
{
    AU_nDBG("[gain = %d] \n", (unsigned int)gain);

    return AU_CUS_SetSPDIFOutGain(gain);
}

/**
 * API_AUDIO_CUSTOMER_SetHDMIOutGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_SetHDMIOutGain(MS_U32 gain)
{
    int vol1, vol2;

    AU_nDBG("[gain = %d] \n", (unsigned int)gain);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Gain = gain;
    gain = gain + pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out;

    vol1 = (1015 - (int)gain)/8;
    vol2 = (1015 - (int)gain) - vol1*8;
    MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_HDMI, vol1, vol2);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetPCMMixerInputMute(API_AUDIO_CUSTOMER_MIXER_INDEX mixerIndex, MS_BOOL bOnOff)
{
    AU_nDBG("[mixerIndex = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)mixerIndex, (unsigned int)bOnOff);

    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_SetFWMixerChannelMute(API_AUDIO_CUSTOMER_FWM_INDEX currentConnect, API_AUDIO_CUSTOMER_FWM_INPUT inputConnect, MS_BOOL bOnOff)
{
    AU_nDBG("[currentConnect = 0x%x] [inputConnect = 0x%x] [bOnOff = 0x%x] \n", (unsigned int)currentConnect, (unsigned int)inputConnect, (unsigned int)bOnOff);

    return AU_CUS_SetFWMixerChannelMute(currentConnect, inputConnect, bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_SetI2SOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    return AU_CUS_SetI2SOutMute(bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_SetLineOutMute(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL bOnOff)
{
    AU_nDBG("[lineIndex = %d] [bOnOff = 0x%x] \n", lineIndex, bOnOff);

    return AU_CUS_SetLineOutMute(lineIndex, bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_SetSPDIFOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    return AU_CUS_SetSPDIFOutMute(bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_SetHDMIOutMute(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = 0x%x] \n", (unsigned int)bOnOff);

    return AU_CUS_SetHDMIOutMute(bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_GetI2SOutMuteStatus(MS_BOOL *pOnOff)
{
    *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute;

    AU_nDBG("[pOnOff = 0x%x] \n", *pOnOff);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_GetLineOutMuteStatus(API_AUDIO_CUSTOMER_LINE_OUT_IDX lineIndex, MS_BOOL *pOnOff)
{
    switch(lineIndex)
    {
        case API_AUDIO_CUSTOMER_LINE_OUT_0:
        {
            *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_1:
        {
            *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_2:
        {
            *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute;
        }
        break;

        case API_AUDIO_CUSTOMER_LINE_OUT_3:
        {
            *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute;
        }
        break;

        default:
            break;
    }

    AU_nDBG("[lineIndex = %d] [bOnOff = 0x%x] \n", lineIndex, *pOnOff);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_GetSPDIFOutMuteStatus(MS_BOOL *pOnOff)
{
    *pOnOff = pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute;

    AU_nDBG("[pOnOff = 0x%x] \n", *pOnOff);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Input(MS_U32 per_50ms, API_AUDIO_CUSTOMER_FWM_INDEX eFWM, API_AUDIO_CUSTOMER_FWM_INPUT eCh)
{
    AU_nDBG("[per_50ms = %d] [eFWM = 0x%x] [eCh = 0x%x] \n", (unsigned int)per_50ms, (unsigned int)eFWM, (unsigned int)eCh);

    return AU_CUS_MuteDuringLimitedTime_Input(per_50ms, eFWM, eCh);
}

MS_BOOL API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Output(MS_U32 per_50ms, API_AUDIO_CUSTOMER_OUTPUT_TYPE ePort)
{
    AU_nDBG("[per_50ms = %d] [ePort = 0x%x] \n", (unsigned int)per_50ms, (unsigned int)ePort);

    return AU_CUS_MuteDuringLimitedTime_Output(per_50ms, ePort);
}

MS_BOOL API_AUDIO_CUSTOMER_SetChannelDelay(API_AUDIO_CUSTOMER_CH_SOUND ch, MS_U32 delay)
{
    AU_nDBG("[delay = 0x%x] \n", (unsigned int)delay);

    switch(ch)
    {
        case API_AUDIO_CUSTOMER_CH5_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH5_Sound_inDelay = delay;
        }
        break;

        case API_AUDIO_CUSTOMER_CH6_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH6_Sound_inDelay = delay;
        }
        break;

        case API_AUDIO_CUSTOMER_CH7_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH7_Sound_inDelay = delay;
        }
        break;

        case API_AUDIO_CUSTOMER_CH8_SOUND:
        {
            pstAudioCustomerShmData->g_audio_customer_CH8_Sound_inDelay = delay;
        }
        break;

        default:
            break;
    }

    return AU_CUS_SetChannelDelay(ch, delay);
}

MS_BOOL API_AUDIO_CUSTOMER_SetAudioDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delay = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay = delay;

    return AU_CUS_SetAudioDelay(delay);
}

MS_BOOL API_AUDIO_CUSTOMER_SetSpdifDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delayTime = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_UpperDelay = delay;

    return AU_CUS_SetSpdifDelay(delay);
}

MS_BOOL API_AUDIO_CUSTOMER_SetHdmiDelay(MS_U32 delay)
{
    AU_nThreadDBG("[delayTime = 0x%x] \n", (unsigned int)delay);

    pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_UpperDelay = delay;

    return AU_CUS_SetHdmiDelay(delay);
}

/* AENC */
MS_BOOL API_AUDIO_CUSTOMER_AENC_Start(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat)
{
    AU_nDBG("[encFormat = 0x%x] \n", (unsigned int)encFormat);

    if(firstGetEncodeTimeFlag == TRUE)
    {
        firstGetEncodeTimeFlag = FALSE;//clear global valiable
    }

    switch(encFormat)
    {
        case API_AUDIO_CUSTOMER_AENC_ENCODE_MP3:
        {
            API_AUDIO_CUSTOMER_MP3_ENC_INPUT mp3EncodeInput = pstAudioCustomerShmData->g_audio_customer_MP3_ENC_Connect;
            AUDIO_CAPTURE_SOURCE_TYPE captureSourceType = E_CAPTURE_MAX_NUM;

            pAU_MP3EncDumpFile = AU_CUS_FileOpen("/tmp/MP3EncDump.mp3", "wb");
            if(pAU_MP3EncDumpFile == FALSE)
            {
                AU_nPRINT("[A] [Error] [%s] [open file for MP3EncDump.mp3 fail] \n", __FUNCTION__);
            }

            memset((void *)(&AENC_INFO), 0x0, sizeof(AENC_INFO));

            AENC_INFO.status  = API_AUDIO_CUSTOMER_AENC_STATUS_PLAY;
            AENC_INFO.codec   = API_AUDIO_CUSTOMER_AENC_ENCODE_MP3;
            AENC_INFO.channel = API_AUDIO_CUSTOMER_AENC_STEREO;
            AENC_INFO.bitrate = API_AUDIO_CUSTOMER_AENC_BIT_128K;

            if(mp3EncodeInput == API_AUDIO_CUSTOMER_MP3_ENC_INPUT_CH5)
            {
                captureSourceType = E_CAPTURE_CH5;
            }
            else if(mp3EncodeInput == API_AUDIO_CUSTOMER_MP3_ENC_INPUT_CH6)
            {
                captureSourceType = E_CAPTURE_CH6;
            }
            else
            {
                AU_nPRINT("[A] [Error] [%s] [wrong mp3 encode input :0x%x] \n", __FUNCTION__, captureSourceType);
            }

            if(AU_CUS_MP3EncodeInit(AU_CUS_MP3EncCallBack, captureSourceType) == TRUE)
            {
                firstGetEncodeTimeFlag = TRUE;
                pstAudioCustomerShmData->g_audio_customer_MP3_ENC_bEnable = TRUE;
            }
            else
            {
                AU_nPRINT("[A] [Error] [%s] [mp3 encode init fail] \n", __FUNCTION__);
                return FALSE;
            }
        }
        break;

        case API_AUDIO_CUSTOMER_AENC_ENCODE_AAC:
        {

        #if (UTPA_SUPPORT_AAC_ENCODE == 1)
            API_AUDIO_CUSTOMER_AAC_ENC_INPUT aacEncodeInput = pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect;
            API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT captureCustomerSourceType = API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT_MAX;
            AUDIO_CAPTURE_SOURCE_TYPE captureDriverSourceType = E_CAPTURE_MAX_NUM;
            MS_S32 retAACEnc = -1;
            tMp4AacEncParams aacEncParams;

            /* create AAC encode related debug files */
            if(pstAudioCustomerShmData->g_audio_customer_AENC_bDumpEncData)
            {
                pAU_AACEncDumpFile = AU_CUS_FileOpen("/tmp/AACEncDump.aac", "wb");
                if(pAU_AACEncDumpFile == FALSE)
                {
                    AU_nPRINT("[A] [Error] [%s] [open file for AACEncDump.aac fail] \n", __FUNCTION__);
                }

                pAU_AACEncPCMCaptureDumpFile = AU_CUS_FileOpen("/tmp/AACEncPCMDump.pcm", "wb");
                if(pAU_AACEncPCMCaptureDumpFile == FALSE)
                {
                    AU_nPRINT("[A] [Error] [%s] [open file for AACEncPCMDump.pcm set fail] \n", __FUNCTION__);
                }
            }

            /* save AAC encode related information in driver side */
            memset((void *)(&AENC_INFO), 0x0, sizeof(AENC_INFO));
            AENC_INFO.status  = API_AUDIO_CUSTOMER_AENC_STATUS_PLAY;
            AENC_INFO.codec   = API_AUDIO_CUSTOMER_AENC_ENCODE_AAC;
            AENC_INFO.channel = API_AUDIO_CUSTOMER_AENC_STEREO;

            /* prepare AAC encode related parameters */
            memset((void *)(&aacEncParams), 0x0, sizeof(aacEncParams));
            aacEncParams.NumberOfChannels = 2;
            aacEncParams.SamplingFrequency = 48000;
            aacEncParams.OutputFormat = FORMAT_ADTS;
            aacEncParams.OutputBitRate = 128000;
            aacEncParams.ChannelMode = JOINT_STEREO;
            aacEncParams.BandWidthSel=  50;

            /* open AAC encode handler */
            retAACEnc = Mpeg4AacEnc_Create(&aacEncodeHandler);
            if (retAACEnc !=  E_EMZ_SUCCESS)
            {
                AU_nPRINT("[A] [Error] [create aacEncodeHandler fail (%d)] \n", (int)retAACEnc);
                return FALSE;
            }

            /* set AAC encode parameters */
            retAACEnc = Mpeg4AacEnc_Reset(aacEncodeHandler, &aacEncParams);
            if (retAACEnc != E_EMZ_SUCCESS)
            {
                AU_nPRINT("[A] [Error] [reset(%d) 0x%x fail] \n", (int)retAACEnc, (unsigned int)aacEncParams.OutputFormat);
                return FALSE;
            }

            /* get PCM capture input */
            if(aacEncodeInput == API_AUDIO_CUSTOMER_AAC_ENC_INPUT_PCM_CAPTURE0)
            {
                captureCustomerSourceType = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect;
                AACEncPCMCaptureDevice = E_DEVICE0;
            }
            else if(aacEncodeInput == API_AUDIO_CUSTOMER_AAC_ENC_INPUT_PCM_CAPTURE1)
            {
                captureCustomerSourceType = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect;
                AACEncPCMCaptureDevice = E_DEVICE1;
            }
            else
            {
                AU_nPRINT("[A] [Error] [%s] [wrong aac encode input :0x%x] \n", __FUNCTION__, captureDriverSourceType);
                captureCustomerSourceType = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect;
                AACEncPCMCaptureDevice = E_DEVICE0;
            }
            captureDriverSourceType = AU_CUS_ConvertCustomerCaptureInputToDriverInput(captureCustomerSourceType);

            /* init and start PCM capture */
            if(AU_CUS_AACEncodeInit(captureDriverSourceType) == TRUE)
            {
                firstGetEncodeTimeFlag = TRUE;
                pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable = TRUE;
            }
            else
            {
                AU_nPRINT("[A] [Error] [%s] [aac encode init fail] \n", __FUNCTION__);
                return FALSE;
            }
        #endif

        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [wrong audio encoding type: 0x%X] \n", __FUNCTION__, encFormat);
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_Stop(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat)
{
    AU_nDBG("[encFormat = 0x%x] \n", (unsigned int)encFormat);

    switch(encFormat)
    {
        case API_AUDIO_CUSTOMER_AENC_ENCODE_MP3:
        {
            pstAudioCustomerShmData->g_audio_customer_MP3_ENC_bEnable = FALSE;

            memset(&AENC_INFO, 0, sizeof(API_AUDIO_CUSTOMER_AENC_INFO));

            AENC_INFO.status  = API_AUDIO_CUSTOMER_AENC_STATUS_STOP;

            MApi_AUDIO_PCMCapture_Stop(E_DEVICE2);

            AU_CUS_FileClose(pAU_MP3EncDumpFile);

            AU_CUS_MemoryFree((void *)pMP3EncBuffer);
        }
        break;

        case API_AUDIO_CUSTOMER_AENC_ENCODE_AAC:
        {

        #if (UTPA_SUPPORT_AAC_ENCODE == 1)
            if(pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable == TRUE)
            {
                #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
                {
                    mutex_lock(&AU_Customer_AACEncode_mutex_lock);
                }
                #else //User Space
                {
                    OS_OBTAIN_MUTEX(AU_Customer_AACEncode_mutex_lock, MSOS_WAIT_FOREVER);
                }
                #endif

                MS_S32 retAACEnc = -1;
                pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable = FALSE;

                memset(&AENC_INFO, 0, sizeof(API_AUDIO_CUSTOMER_AENC_INFO));
                AENC_INFO.status  = API_AUDIO_CUSTOMER_AENC_STATUS_STOP;

                MApi_AUDIO_PCMCapture_Stop(AACEncPCMCaptureDevice);
                if(aacEncodeHandler != NULL)
                {
                    retAACEnc = Mpeg4AacEnc_Delete(aacEncodeHandler);
                    if(retAACEnc < 0)
                    {
                        AU_nPRINT("[A] [Error] [%s] [Abnormal msg(0x%X) when delete AAC encode handler] \n", __FUNCTION__, (int)retAACEnc);
                    }
                }

                if(pAU_AACEncDumpFile != NULL)
                {
                    AU_CUS_FileClose(pAU_AACEncDumpFile);
                    pAU_AACEncDumpFile = NULL;
                }

                if(pAU_AACEncPCMCaptureDumpFile != NULL)
                {
                    AU_CUS_FileClose(pAU_AACEncPCMCaptureDumpFile);
                    pAU_AACEncPCMCaptureDumpFile = NULL;
                }

                if(pAACEncPCMBuffer != NULL)
                {
                    AU_CUS_MemoryFree((void *)pAACEncPCMBuffer);
                    pAACEncPCMBuffer = NULL;
                }

                #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
                {
                    mutex_unlock(&AU_Customer_AACEncode_mutex_lock);
                }
                #else //User Space
                {
                    OS_RELEASE_MUTEX(AU_Customer_AACEncode_mutex_lock);
                }
                #endif
            }
        #endif

        }
        break;

        default:
        {
           AU_nPRINT("[A] [Error] [%s] [wrong audio encoding type: 0x%x] \n", __FUNCTION__, encFormat);
        }
        break;
    }
    return FALSE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_RegisterCallback(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, pfnAudioCustomerAENCDataHandling pfnCallBack)
{
    AU_nDBG("[encFormat = 0x%x] \n", (unsigned int)encFormat);

    switch(encFormat)
    {
        case API_AUDIO_CUSTOMER_AENC_ENCODE_MP3:
        {
            madCallBack.pFunc_AencMP3 = pfnCallBack;
        }
        break;

        case API_AUDIO_CUSTOMER_AENC_ENCODE_AAC:
        {
            madCallBack.pFunc_AencAAC = pfnCallBack;
        }
        break;

        default:
        {
           AU_nPRINT("[A] [Error] [%s] [wrong audio encoding type: 0x%x] \n", __FUNCTION__, encFormat);
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_SetInfo(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, API_AUDIO_CUSTOMER_AENC_INFO info)
{
    AU_nDBG("[encFormat           = 0x%x] \n", (unsigned int)encFormat);
    AU_nDBG("[info.status         = 0x%x] \n", (unsigned int)info.status);
    AU_nDBG("[info.codec          = 0x%x] \n", (unsigned int)info.codec);
    AU_nDBG("[info.errorCount     = 0x%x] \n", (unsigned int)info.errorCount);
    AU_nDBG("[info.inputCount     = 0x%x] \n", (unsigned int)info.inputCount);
    AU_nDBG("[info.underflowCount = 0x%x] \n", (unsigned int)info.underflowCount);
    AU_nDBG("[info.overflowCount  = 0x%x] \n", (unsigned int)info.overflowCount);
    AU_nDBG("[info.channel        = 0x%x] \n", (unsigned int)info.channel);
    AU_nDBG("[info.bitrate        = 0x%x] \n", (unsigned int)info.bitrate);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_GetInfo(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, API_AUDIO_CUSTOMER_AENC_INFO *pInfo)
{
    AU_nDBG("[encFormat             = 0x%x] \n", (unsigned int)encFormat);
    AU_nDBG("[pInfo->status         = 0x%x] \n", (unsigned int)pInfo->status);
    AU_nDBG("[pInfo->codec          = 0x%x] \n", (unsigned int)pInfo->codec);
    AU_nDBG("[pInfo->errorCount     = 0x%x] \n", (unsigned int)pInfo->errorCount);
    AU_nDBG("[pInfo->inputCount     = 0x%x] \n", (unsigned int)pInfo->inputCount);
    AU_nDBG("[pInfo->underflowCount = 0x%x] \n", (unsigned int)pInfo->underflowCount);
    AU_nDBG("[pInfo->overflowCount  = 0x%x] \n", (unsigned int)pInfo->overflowCount);
    AU_nDBG("[pInfo->channel        = 0x%x] \n", (unsigned int)pInfo->channel);
    AU_nDBG("[pInfo->bitrate        = 0x%x] \n", (unsigned int)pInfo->bitrate);

    return TRUE;
}

/**
 * API_AUDIO_CUSTOMER_AENC_SetGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_AENC_SetGain(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U32 gain)
{
    MS_U32 mainVol, fineVol;

    AU_nDBG("[encFormat = 0x%x] \n", (unsigned int)encFormat);
    AU_nDBG("[gain      = %d]   \n", (unsigned int)gain);

    mainVol = (1015 - (int)gain)/8;
    fineVol = (1015 - (int)gain) - mainVol*8;

    pstAudioCustomerShmData->g_audio_customer_AENC_Gain = gain;

    switch(encFormat)
    {
        case API_AUDIO_CUSTOMER_AENC_ENCODE_MP3:
        {
            AU_nPRINT("[A] [Error] [%s] [not support mp3 volume adjust right now: 0x%X] \n", __FUNCTION__, encFormat);
        }
        break;

        case API_AUDIO_CUSTOMER_AENC_ENCODE_AAC:
        {
            API_AUDIO_CUSTOMER_AAC_ENC_INPUT aacEncodeInput = pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect;

            switch(aacEncodeInput)
            {
                case API_AUDIO_CUSTOMER_AAC_ENC_INPUT_PCM_CAPTURE0:
                {
                    MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_PCM_CAPTURE1, (MS_U8)mainVol, (MS_U8)fineVol);
                }
                break;

                case API_AUDIO_CUSTOMER_AAC_ENC_INPUT_PCM_CAPTURE1:
                {
                    MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_PCM_CAPTURE2, (MS_U8)mainVol, (MS_U8)fineVol);
                }
                break;

                default:
                {
                    AU_nPRINT("[A] [Error] [%s] [unsupport aac encode input: %x] \n", __FUNCTION__, aacEncodeInput);
                    return FALSE;
                }
                break;
            }
        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [wrong audio encoding type: 0x%X] \n", __FUNCTION__, encFormat);
        }
        break;
    }
    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_CopyData(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U8 *pDest, MS_U8 *pBufAddr, MS_U32 datasize, MS_U8 *pRStart, MS_U8 *pREnd)
{
    AU_nDBG("[encFormat = 0x%x] [datasize = 0x%x] \n", (unsigned int)encFormat, (unsigned int)datasize);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_AENC_ReleaseData(API_AUDIO_CUSTOMER_AENC_ENCODING_FORMAT encFormat, MS_U8 *pBufAddr, MS_U32 datasize)
{
    AU_nDBG("[encFormat = 0x%x] [datasize = 0x%x] \n", (unsigned int)encFormat, (unsigned int)datasize);

    return TRUE;
}

/* PCM Capture */
MS_BOOL API_AUDIO_CUSTOMER_PCM_StartUpload(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect)
{
    API_AUDIO_CUSTOMER_PCM_CAPTURE_INPUT captureInput;
    AUDIO_DEVICE_TYPE captureDriverDeviceType;
    AUDIO_CAPTURE_SOURCE_TYPE captureDriverSourceType;

    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable)
    {
        pAU_PcmCaptureSourceDumpFile = AU_CUS_FileOpen(AU_PCM_CAPTURE_SOURCE_DUMP_PATH, "wb");
        if(pAU_PcmCaptureSourceDumpFile == FALSE)
        {
            AU_nPRINT("[A] [Error] [%s] [%d] [open dump file is fail !] \n", __FUNCTION__, __LINE__);
        }
    }

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            captureInput = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect;
            captureDriverDeviceType = E_DEVICE0;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            captureInput = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect;
            captureDriverDeviceType = E_DEVICE1;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE2:
        {
            captureInput = pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Connect;
            captureDriverDeviceType = E_DEVICE2;
        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [unsupport pcm capture index: %x] \n", __FUNCTION__, currentConnect);
            return FALSE;
        }
        break;
    }

    captureDriverSourceType = AU_CUS_ConvertCustomerCaptureInputToDriverInput(captureInput);

    if(AU_CUS_PCMCaptureInit(captureDriverDeviceType, captureDriverSourceType) == TRUE)
    {
        if(currentConnect == API_AUDIO_CUSTOMER_PCM_CAPTURE0)
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bEnable = TRUE;
        }
        else if(currentConnect == API_AUDIO_CUSTOMER_PCM_CAPTURE1)
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bEnable = TRUE;

        }
        else if(currentConnect == API_AUDIO_CUSTOMER_PCM_CAPTURE2)
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bEnable = TRUE;
        }
    }
    else
    {
        AU_nPRINT("[A] [Error] [%s] [pcm capture init fail] \n", __FUNCTION__);
        return FALSE;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_StopUpload(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect)
{
    AUDIO_DEVICE_TYPE captureDriverDeviceType;

    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bEnable = FALSE;
            captureDriverDeviceType = E_DEVICE0;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bEnable = FALSE;
            captureDriverDeviceType = E_DEVICE1;
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE2:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bEnable = FALSE;
            captureDriverDeviceType = E_DEVICE2;
        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [unsupport pcm capture index: %x] \n", __FUNCTION__, currentConnect);
            return FALSE;
        }
        break;
    }

    MApi_AUDIO_PCMCapture_Stop(captureDriverDeviceType);

    if(pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Source_Dump_to_file_bEnable)
    {
        AU_CUS_FileClose(pAU_PcmCaptureSourceDumpFile);
    }

    AU_CUS_MemoryFree((void *)pPCMCaptureBuffer);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_RegisterSendPCMCallback(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, pfnAudioCustomerPCMSending pfnCallBack)
{
    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);

    madCallBack.pFunc_PCMCaptureDone = pfnCallBack;

    return TRUE;
}

/**
 * API_AUDIO_CUSTOMER_PCM_SetGain
 * gain Scale     : 0.125dB
 * gain Range     : -114.875dB ~ 12dB
 * ex.  gain 0 = -114.875dB; gain 1015 = 12dB
 */
MS_BOOL API_AUDIO_CUSTOMER_PCM_SetGain(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, MS_U32 gain)
{
    MS_U32 mainVol, fineVol;

    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);
    AU_nDBG("[gain           = %d]   \n", (unsigned int)gain);

    mainVol = (1015 - (int)gain)/8;
    fineVol = (1015 - (int)gain) - mainVol*8;

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Gain = gain;
            MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_PCM_CAPTURE1, (MS_U8)mainVol, (MS_U8)fineVol);
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Gain = gain;
            MApi_AUDIO_SetAbsoluteVolume(AUDIO_T3_PATH_PCM_CAPTURE2, (MS_U8)mainVol, (MS_U8)fineVol);
        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [unsupport pcm capture index: %x] \n", __FUNCTION__, currentConnect);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_SetMute(API_AUDIO_CUSTOMER_PCM_CAPTURE_INDEX currentConnect, MS_BOOL bOnOff)
{
    AU_nDBG("[currentConnect = 0x%x] \n", (unsigned int)currentConnect);
    AU_nDBG("[bOnOff         = 0x%x] \n", (unsigned int)bOnOff);

    switch(currentConnect)
    {
        case API_AUDIO_CUSTOMER_PCM_CAPTURE0:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bMute = bOnOff;
            MApi_AUDIO_SetMute(AUDIO_T3_PATH_PCM_CAPTURE1, pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bMute);
        }
        break;

        case API_AUDIO_CUSTOMER_PCM_CAPTURE1:
        {
            pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bMute = bOnOff;
            MApi_AUDIO_SetMute(AUDIO_T3_PATH_PCM_CAPTURE2, pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bMute);
        }
        break;

        default:
        {
            AU_nPRINT("[A] [Error] [%s] [unsupport pcm capture index: %x] \n", __FUNCTION__, currentConnect);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_PCM_SetRequestSizeInMs(MS_U32 request_ms)
{
    AU_nDBG("[request_ms = %d] \n", (unsigned int)request_ms);

    pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE_Request_data_in_byte = request_ms*48*2*2; /* request_ms in 48KHz, 16bits, stereo PCM */

    return TRUE;
}

/* PCM IO Control */
MS_S32 API_AUDIO_CUSTOMER_PCM_Open(API_AUDIO_CUSTOMER_PCMIO_PARAM *pData)
{
    AUDIO_PCM_INFO_t PcmInfo;
    MS_U32 name_size = 0;
    AU_nDBG("Device Name = %s \n", pData->u8Name);

    if(pData == NULL)
    {
        return -1;
    }

    memset((void *)&PcmInfo, 0x00, sizeof(AUDIO_PCM_INFO_t));
    PcmInfo.u32StructVersion = AUDIO_PCM_INFO_VERSION;
    PcmInfo.u32StructSize = sizeof(PcmInfo);
    name_size = strlen((char*)pData->u8Name);
    if(name_size >= sizeof(PcmInfo.u8Name))
    {
        name_size = sizeof(PcmInfo.u8Name) - 1;
    }
    memset((void*)PcmInfo.u8Name, '\0', sizeof(PcmInfo.u8Name));
    strncpy((char*)PcmInfo.u8Name, (char*)pData->u8Name, name_size);
    PcmInfo.u8MultiChFlag = pData->u8MultiChFlag;
    PcmInfo.u32BufferDuration = pData->u32BufferDuration;
    PcmInfo.u32Channel = pData->u32Channel;
    PcmInfo.u32SampleRate = pData->u32SampleRate;
    PcmInfo.u32BitWidth = pData->u32BitWidth;
    //PcmInfo.u32BigEndian = pData->u32BigEndian; //Wait PcmInfo.u32BigEndian fix in all utopia
    if((strcmp((char *)AUDIO_PCM_CAPTURE1, (char *)pData->u8Name) == 0) ||
       (strcmp((char *)AUDIO_PCM_CAPTURE2, (char *)pData->u8Name) == 0))
    {
        PcmInfo.u8CaptureFlag = TRUE;
    }

    return MApi_AUDIO_PCM_Open((void*)&PcmInfo);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Close(MS_S32 s32DeviceId)
{
    AU_nDBG("[s32DeviceId = 0x%x]\n", (unsigned int)s32DeviceId);

    return MApi_AUDIO_PCM_Close(s32DeviceId);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Start(MS_S32 s32DeviceId)
{
    AU_nDBG("[s32DeviceId = 0x%x]\n", (unsigned int)s32DeviceId);

    return MApi_AUDIO_PCM_Start(s32DeviceId);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Stop(MS_S32 s32DeviceId)
{
    AU_nDBG("[s32DeviceId = 0x%x]\n", (unsigned int)s32DeviceId);

    return MApi_AUDIO_PCM_Stop(s32DeviceId);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Set(MS_S32 s32DeviceId, MS_U32 u32Cmd, const void *pData)
{
    AU_nDBG("[s32DeviceId = 0x%x] [u32Cmd = 0x%x]\n", (unsigned int)s32DeviceId, (unsigned int)u32Cmd);

    return MApi_AUDIO_PCM_Set(s32DeviceId, u32Cmd, pData);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Get(MS_S32 s32DeviceId, MS_U32 u32Cmd, void *pData)
{
    AU_nThreadDBG("[s32DeviceId = 0x%x] [u32Cmd = 0x%x]\n", (unsigned int)s32DeviceId, (unsigned int)u32Cmd);

    return MApi_AUDIO_PCM_Get(s32DeviceId, u32Cmd, pData);
}

MS_U32 API_AUDIO_CUSTOMER_PCM_Read(MS_S32 s32DeviceId, void *pBuf, MS_U32 u32Size)
{
    AU_nDBG("[s32DeviceId = 0x%x] [u32Size = 0x%x]\n", (unsigned int)s32DeviceId, (unsigned int)u32Size);

    return MApi_AUDIO_PCM_Read(s32DeviceId, pBuf, u32Size);
}

MS_U32 API_AUDIO_CUSTOMER_PCM_Write(MS_S32 s32DeviceId, const void *pBuf, MS_U32 u32Size)
{
    AU_nThreadDBG("[s32DeviceId = 0x%x] [u32Size = 0x%x]\n", (unsigned int)s32DeviceId, (unsigned int)u32Size);

    return MApi_AUDIO_PCM_Write(s32DeviceId, pBuf, u32Size);
}

MS_S32 API_AUDIO_CUSTOMER_PCM_Flush(MS_S32 s32DeviceId)
{
    AU_nDBG("[s32DeviceId = 0x%x]\n", (unsigned int)s32DeviceId);

    return MApi_AUDIO_PCM_Flush(s32DeviceId);
}

/* MM New Mode */
MS_PHY  API_AUDIO_CUSTOMER_GetDDRInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_DDRINFO DDRInfo)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    AU_nThreadDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);

    return MApi_AUDIO_GetDDRInfo(DecID, (EN_AUDIO_DDRINFO)DDRInfo);
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_initAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;
    MS_BOOL Ret = FALSE;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_initAesInfo_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    AU_nDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt = 0;

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    Ret   = MApi_AUDIO_MM2_initAesInfo(DecID);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #endif

    return Ret;
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_checkAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_AES_INFO *aes_info)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_checkAesInfo_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    AU_nThreadDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    MApi_AUDIO_MM2_checkAesInfo(DecID, (AES_INFO*)aes_info);

    if(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable)
    {
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_base_addr    = aes_info->aes_base_addr;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_end_addr     = aes_info->aes_end_addr;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_BufSize      = aes_info->aes_BufSize;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_write_addr   = aes_info->aes_write_addr;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_read_addr    = aes_info->aes_read_addr;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_freeSpace    = aes_info->aes_freeSpace;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_level        = aes_info->aes_level;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_ptsCnt       = aes_info->aes_ptsCnt;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_aes_info.aes_lastPTS      = aes_info->aes_lastPTS;
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_inputAesFinished(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)
{
    AUDIO_DEC_ID DecID = AU_DEC_INVALID;
    MS_BOOL ret = FALSE;
    AES_INFO currentAESInfo;
    MS_U32 pEsdump_addr;
    MS_U32 size_tmp;
    MS_U32 SE_base_addr;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_inputAesFinished_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt <= 10)
    {
        AU_nDBG("[cnt:%-7d][adecIndex = 0x%x][es_size = 0x%x][ptsExist = 0x%x][div(pts,90) = %lld] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt, (unsigned int)adecIndex, (unsigned int)es_size, (unsigned int)ptsExist, (unsigned long long)AU_CUS_long_div(pts, 90) );
    }
    else
    {
        AU_nThreadDBG("[cnt:%-7d][adecIndex = 0x%x][es_size = 0x%x][ptsExist = 0x%x][div(pts,90) = %lld] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt, (unsigned int)adecIndex, (unsigned int)es_size, (unsigned int)ptsExist, (unsigned long long)AU_CUS_long_div(pts, 90) );
    }

    DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    ret   = MApi_AUDIO_MM2_inputAesFinished(DecID, es_size, ptsExist, pts);
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_ret = ret;
    pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt ++;

    if(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_bEnable)
    {
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_es_size  = es_size;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_ptsExist = ptsExist;
        pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_Upper_pts      = pts;
    }

    if((ret == TRUE) && (pAU_MMESDumpFile != NULL))
    {
        SE_base_addr = MApi_AUDIO_GetDspMadBaseAddr(1);

        MApi_AUDIO_MM2_checkAesInfo(DecID, &currentAESInfo);

        if(es_size > (currentAESInfo.aes_write_addr - currentAESInfo.aes_base_addr))
        {
            pEsdump_addr = currentAESInfo.aes_write_addr + currentAESInfo.aes_BufSize - es_size;
            size_tmp = es_size - (currentAESInfo.aes_write_addr - currentAESInfo.aes_base_addr);
            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(SE_base_addr + pEsdump_addr), sizeof(char), size_tmp, pAU_MMESDumpFile);
            size_tmp = es_size - size_tmp;
            pEsdump_addr = currentAESInfo.aes_base_addr;
            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(SE_base_addr + pEsdump_addr), sizeof(char), size_tmp, pAU_MMESDumpFile);
        }
        else
        {
            pEsdump_addr = currentAESInfo.aes_write_addr - es_size;
            AU_CUS_FileWrite((void*)MsOS_MPool_PA2KSEG1(SE_base_addr + pEsdump_addr), sizeof(char), es_size, pAU_MMESDumpFile);
        }
    }

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #endif

    return ret;
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_AD_initAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex)
{
    AUDIO_DEC_ID Main_DecID = AU_DEC_INVALID;
    AUDIO_DEC_ID AD_DecID   = AU_DEC_INVALID;
    MS_BOOL      Ret        = FALSE;

    AU_nDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_initAesInfo_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif


    Main_DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AD_DecID   = AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(Main_DecID);
    Ret        = MApi_AUDIO_MM2_initAesInfo(AD_DecID);


    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_initAesInfo_mutex_lock);
    }
    #endif

    return Ret;
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_AD_checkAesInfo(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, API_AUDIO_CUSTOMER_AES_INFO *aes_info)
{
    AUDIO_DEC_ID Main_DecID = AU_DEC_INVALID;
    AUDIO_DEC_ID AD_DecID   = AU_DEC_INVALID;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_checkAesInfo_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    AU_nThreadDBG("[adecIndex = 0x%x]\n", (unsigned int)adecIndex);

    Main_DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AD_DecID   = AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(Main_DecID);

    MApi_AUDIO_MM2_checkAesInfo(AD_DecID, (AES_INFO*)aes_info);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_checkAesInfo_mutex_lock);
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MM2_AD_inputAesFinished(API_AUDIO_CUSTOMER_ADEC_INDEX adecIndex, MS_U32 es_size, MS_BOOL ptsExist, MS_U64 pts)
{
    AUDIO_DEC_ID Main_DecID = AU_DEC_INVALID;
    AUDIO_DEC_ID AD_DecID   = AU_DEC_INVALID;
    MS_BOOL      ret        = FALSE;

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_lock(&AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #else //User Space
    {
        OS_OBTAIN_MUTEX(AU_Customer_MM2_inputAesFinished_mutex_lock, MSOS_WAIT_FOREVER);
    }
    #endif

    if(pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt <= 10)
    {
        AU_nDBG("[cnt:%-7d][adecIndex = 0x%x][es_size = 0x%x][ptsExist = 0x%x][div(pts,90) = %lld] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt, (unsigned int)adecIndex, (unsigned int)es_size, (unsigned int)ptsExist, (unsigned long long)AU_CUS_long_div(pts, 90) );
    }
    else
    {
        AU_nThreadDBG("[cnt:%-7d][adecIndex = 0x%x][es_size = 0x%x][ptsExist = 0x%x][div(pts,90) = %lld] \n", (unsigned int)pstAudioCustomerShmData->g_audio_customer_AU_AV_Sync_Info_inputAesFinished_cnt, (unsigned int)adecIndex, (unsigned int)es_size, (unsigned int)ptsExist, (unsigned long long)AU_CUS_long_div(pts, 90) );
    }

    Main_DecID = AU_CUS_ConvertCustomerAdecIndexToDriverDecID(adecIndex);
    AD_DecID   = AU_CUS_ConvertDriverMainDecIDtoDriverAdDecID(Main_DecID);
    ret        = MApi_AUDIO_MM2_inputAesFinished(AD_DecID, es_size, ptsExist, pts);

    #ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
    {
        mutex_unlock(&AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #else //User Space
    {
        OS_RELEASE_MUTEX(AU_Customer_MM2_inputAesFinished_mutex_lock);
    }
    #endif

    return ret;
}

/* Mstar Sound Effect */
MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_Enable(API_AUDIO_CUSTOMER_MSTAR_SE_TYPE Type, MS_BOOL bOnOff)
{
    Sound_ENABLE_Type seType;

    AU_nDBG("[Type = 0x%x] [bOnOff = 0x%x]\n", (unsigned int)Type, (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable[Type] = bOnOff;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_Enable_UpperSetCnt[Type] += 1;

    seType = AU_CUS_ConvertCustomerMstarSndTypeToDriverMstarSndType(Type);
    return MApi_SND_ProcessEnable(seType, bOnOff);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ(MS_U8 u8band, MS_S8 s8level)
{
    AU_nDBG("[u8band = 0x%x] [s8level = 0x%x]\n", (unsigned int)u8band, (unsigned int)s8level);

    if(u8band < MSTAR_SE_GEQ_MAX_BAND)
    {
        AU_nDBG("\n");

        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ[u8band] = s8level;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_GEQ_UpperSetCnt[u8band]++;

        return MApi_SND_SetParam1(Sound_SET_PARAM_AbsoluteEQ, u8band, (MS_U8)s8level);
    }
    else
    {
        AU_nDBG("\n");

        return FALSE;
    }
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef(API_AUDIO_CUSTOMER_MSTAR_PEQ_COEF *peq_coef)
{
    AUDIO_PEQ_COEF PEQCoef = {0,};

    AU_nDBG("[peq_coef->band   = 0x%x]\n", (unsigned int)peq_coef->band);
    AU_nDBG("[peq_coef->a0     = 0x%x]\n", (unsigned int)peq_coef->a0);
    AU_nDBG("[peq_coef->a1     = 0x%x]\n", (unsigned int)peq_coef->a1);
    AU_nDBG("[peq_coef->a2     = 0x%x]\n", (unsigned int)peq_coef->a2);
    AU_nDBG("[peq_coef->b1     = 0x%x]\n", (unsigned int)peq_coef->b1);
    AU_nDBG("[peq_coef->b2     = 0x%x]\n", (unsigned int)peq_coef->b2);
    AU_nDBG("[peq_coef->enable = 0x%x]\n", (unsigned int)peq_coef->enable);
    AU_nDBG("[peq_coef->scale  = 0x%x]\n", (unsigned int)peq_coef->scale);

    if(peq_coef->band < MSTAR_SE_PEQ_MAX_BAND)
    {
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].band   = peq_coef->band;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].a0     = peq_coef->a0;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].a1     = peq_coef->a1;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].a2     = peq_coef->a2;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].b1     = peq_coef->b1;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].b2     = peq_coef->b2;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].enable = peq_coef->enable;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef[peq_coef->band].scale  = peq_coef->scale;
        pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_PEQCoef_UpperSetCnt[peq_coef->band] +=1 ;
    }
    else
    {
        AU_nDBG("\n");

        return FALSE;
    }

    PEQCoef.band       = peq_coef->band;
    PEQCoef.sfs        = 1;

    if(peq_coef->scale > 1)
    {
        PEQCoef.scale = peq_coef->scale;
    }
    else
    {
        PEQCoef.scale = 1;
    }

    PEQCoef.a0         = peq_coef->a0;
    PEQCoef.a1         = peq_coef->a1;
    PEQCoef.a2         = peq_coef->a2;
    PEQCoef.b1         = peq_coef->b1;
    PEQCoef.b2         = peq_coef->b2;
    PEQCoef.type       = AUDIO_COEF_PEQ;
    PEQCoef.enable     = peq_coef->enable;
    PEQCoef.precision  = AUDIO_DOUBLE_PRECISION;

    MApi_AUDIO_SetPEQCoef(&PEQCoef);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef(API_AUDIO_CUSTOMER_MSTAR_HPF_COEF *hpf_coef)
{
    AUDIO_PEQ_COEF HPFCoef;

    AU_nDBG("[hpf_coef->a0 = 0x%x]\n", (unsigned int)hpf_coef->a0);
    AU_nDBG("[hpf_coef->a1 = 0x%x]\n", (unsigned int)hpf_coef->a1);
    AU_nDBG("[hpf_coef->a2 = 0x%x]\n", (unsigned int)hpf_coef->a2);
    AU_nDBG("[hpf_coef->b1 = 0x%x]\n", (unsigned int)hpf_coef->b1);
    AU_nDBG("[hpf_coef->b2 = 0x%x]\n", (unsigned int)hpf_coef->b2);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a0 = hpf_coef->a0;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a1 = hpf_coef->a1;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.a2 = hpf_coef->a2;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.b1 = hpf_coef->b1;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef.b2 = hpf_coef->b2;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_HPFCoef_UpperSetCnt += 1;

    HPFCoef.a0   = hpf_coef->a0;
    HPFCoef.a1   = hpf_coef->a1;
    HPFCoef.a2   = hpf_coef->a2;
    HPFCoef.b1   = hpf_coef->b1;
    HPFCoef.b2   = hpf_coef->b2;
    HPFCoef.sfs  = 1;
    HPFCoef.type = AUDIO_COEF_HPF;

    MApi_AUDIO_SetPEQCoef(&HPFCoef);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE(API_AUDIO_CUSTOMER_MSTAR_AVC_MODE mode)
{
    AU_nDBG("[mode = 0x%x]\n", (unsigned int)mode);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE = mode;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_MODE_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_Avc_Mode, mode, 0);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL(MS_U16 u16level)
{
    AU_nDBG("[u16level = 0x%x]\n", (unsigned int)u16level);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL = u16level;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_LEVEL_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_Avc_Threshold, u16level, 0);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin(MS_U16 u16Begin)
{
    AU_nDBG("[u16Begin = 0x%x]\n", (unsigned int)u16Begin);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin = u16Begin;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Begin_UpperSetCnt += 1;

    #if(UTPA_SUPPORT_AVC_R_MODE)
    {
        return MApi_SND_SetParam1(Sound_SET_PARAM_Avc_R_Begin, u16Begin, 0);
    }
    #else
    {
        return FALSE;
    }
    #endif
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End(MS_U16 u16End)
{
    AU_nDBG("[u16End = 0x%x]\n", (unsigned int)u16End);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End = u16End;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_End_UpperSetCnt += 1;

    #if(UTPA_SUPPORT_AVC_R_MODE)
    {
        return MApi_SND_SetParam1(Sound_SET_PARAM_Avc_R_End, u16End, 0);
    }
    #else
    {
        return FALSE;
    }
    #endif
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Slope(MS_U16 u16Slope)
{
    AU_nDBG("[u16Slope = 0x%x]\n", (unsigned int)u16Slope);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope = u16Slope;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_R_MODE_Slope_UpperSetCnt += 1;

    #if(UTPA_SUPPORT_AVC_R_MODE)
    {
        if( (u16Slope>=1) && (u16Slope<=3) )
        {
            return MApi_SND_SetParam1(Sound_SET_PARAM_Avc_R_Slope, u16Slope, 0);
        }
        else
        {
            return FALSE;
        }
    }
    #else
    {
        return FALSE;
    }
    #endif
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET(MS_U16 u16offset)
{
    AU_nDBG("[u16offset = 0x%x]\n", (unsigned int)u16offset);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET = u16offset;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_S_MODE_OFFSET_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_AVC_S_Offset, u16offset, 0);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime(MS_U8 AvcAT)
{
    AU_nDBG("[AvcAT = 0x%x]\n", (unsigned int)AvcAT);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime = AvcAT;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_AttackTime_UpperSetCnt += 1;

    MApi_AUDIO_SetAvcAT(AvcAT);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime(MS_U8 AvcRT)
{
    AU_nDBG("[AvcRT = 0x%x]\n", (unsigned int)AvcRT);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime = AvcRT;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_AVC_ReleaseTime_UpperSetCnt += 1;

    MApi_AUDIO_SetAvcRT(AvcRT);

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL(MS_U16 u16level)
{
    AU_nDBG("[u16level = 0x%x]\n", (unsigned int)u16level);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL = u16level;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_DRC_LEVEL_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_Drc_Threshold, u16level, 0);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE(MS_U16 Lbalance, MS_U16 Rbalance)
{
    AU_nDBG("[Lbalance = 0x%x] [Lbalance = 0x%x]\n", (unsigned int)Lbalance, (unsigned int)Rbalance);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_L = Lbalance;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_R = Rbalance;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_BALANCE_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_AbsoluteBalance, Lbalance, Rbalance);
}

MS_BOOL API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold(MS_U16 u16level)
{
    AU_nDBG("[u16level = 0x%x] \n", (unsigned int)u16level);

    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold = u16level;
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_SET_NR_Threshold_UpperSetCnt += 1;

    return MApi_SND_SetParam1(Sound_SET_PARAM_NR_Threshold, u16level, 0);
}

MS_S32 API_AUDIO_CUSTOMER_MSTAR_SE_GET_NR_Status()
{
    pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold = (int)MApi_AUDIO_GetCommAudioInfo(Audio_Comm_infoType_getNR_Status);

    AU_nThreadDBG("[pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold = %d] \n", (int)pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold);

    return pstAudioCustomerShmData->g_audio_customer_MSTAR_SE_GET_NR_Threshold;
}

/* Advanced Sound Effect */
MS_BOOL API_AUDIO_CUSTOMER_DTS_SE_Enable(API_AUDIO_CUSTOMER_DTS_SE_TYPE seType)
{
    ADVSND_TYPE DtsSndType = ADV_NONE;

    AU_nDBG("[seType = 0x%x]\n", (unsigned int)seType);

    pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable[seType] = TRUE;
    pstAudioCustomerShmData->g_audio_customer_DTS_SE_Enable_UpperSetCnt[seType] += 1;

    DtsSndType = AU_CUS_ConvertCustomerDtsSndTypeToDriverDtsSndType(seType);
    MApi_AUDIO_ADVSOUND_ProcessEnable(DtsSndType);
    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable(API_AUDIO_CUSTOMER_DTS_SE_UNIT_TYPE seUnit, MS_BOOL bOnOff)
{
    ADVFUNC DtsSndUnit = SRS_THEATERSOUND_TOTAL;

    AU_nDBG("[seUnit = 0x%x] [bOnOff = 0x%x]\n", (unsigned int)seUnit, (unsigned int)bOnOff);

    pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable[seUnit] = bOnOff;
    pstAudioCustomerShmData->g_audio_customer_DTS_SE_ProcessUnit_Enable_UpperSetCnt[seUnit] += 1;

    DtsSndUnit = AU_CUS_ConvertCustomerDtsSndUnitToDriverDtsSndUnitType(seUnit);
    MApi_AUDIO_ADVSOUND_SubProcessEnable(DtsSndUnit, bOnOff);
    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_DTS_SE_SetParam(API_AUDIO_CUSTOMER_DTS_SE_PARAM_TYPE param, MS_U32 u32value)
{
    ADVSND_PARAM DtsSndParam  = SRS_THEATERSOUND_TOTAL;

    AU_nDBG("[param = 0x%x] [u32value = 0x%x]\n", (unsigned int)param, (unsigned int)u32value);

    DtsSndParam = AU_CUS_ConvertCustomerDtsSndParamToDriverDtsSndParam(param, u32value);
    if(DtsSndParam > 0)
    {
        pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam[param] = u32value;
        pstAudioCustomerShmData->g_audio_customer_DTS_SE_SetParam_UpperSetCnt[param] += 1;

        MApi_AUDIO_ADVSND_SetParam(DtsSndParam, u32value, 1);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

MS_BOOL API_AUDIO_CUSTOMER_Dolby_DAP_Enable(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = %d] \n", (unsigned int)bOnOff);

    #if(UTPA_SUPPORT_DOLBY_DAP)
    {
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable = bOnOff;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_Enable_UpperSetCnt += 1;

        if(bOnOff)
        {
            if(MApi_AUDIO_ADVSOUND_ProcessEnable(DOLBY_DAP) == FALSE)
            {
                AU_nPRINT("MApi_AUDIO_ADVSOUND_ProcessEnable DOLBY_DAP FAIL.\n");
                return FALSE;
            }
        }
        else
        {
            MApi_AUDIO_ADVSOUND_SubProcessEnable(DOLBY_DAP_EN, FALSE);
        }
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable(MS_BOOL bOnOff)
{
    AU_nDBG("[bOnOff = %d] \n", (unsigned int)bOnOff);

    #if(UTPA_SUPPORT_DOLBY_DAP)
    {
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable = bOnOff;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_ProcessUnit_Enable_UpperSetCnt += 1;

        MApi_AUDIO_ADVSOUND_SubProcessEnable(DOLBY_DAP_EN, bOnOff);
    }
    #endif

    return TRUE;
}

MS_BOOL API_AUDIO_CUSTOMER_Dolby_DAP_SetParam(API_AUDIO_CUSTOMER_DOLBY_DAP_PARAM dap_params)
{
    int i = 0, j = 0;

    AU_nDBG("\n");

    AU_UNUSED(i);
    AU_UNUSED(j);

    #if(UTPA_SUPPORT_DOLBY_DAP)
    {
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.pregain                        =  dap_params.pregain;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.postgain                       =  dap_params.postgain;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.systemgain                     =  dap_params.systemgain;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.surround_decoder_enable        =  dap_params.surround_decoder_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtualizer_enable             =  dap_params.virtualizer_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.headphone_reverb               =  dap_params.headphone_reverb;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.speaker_angle                  =  dap_params.speaker_angle;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.speaker_start                  =  dap_params.speaker_start;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.surround_boost                 =  dap_params.surround_boost;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_ieq_enable                  =  dap_params.mi_ieq_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_dv_enable                   =  dap_params.mi_dv_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_de_enable                   =  dap_params.mi_de_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.mi_surround_enable             =  dap_params.mi_surround_enable;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.calibration_boost              =  dap_params.calibration_boost;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_amount                 =  dap_params.leveler_amount;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_input                  =  dap_params.leveler_input;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_output                 =  dap_params.leveler_output;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.leveler_enable                 =  dap_params.leveler_enable;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.modeler_enable                 =  dap_params.modeler_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.modeler_calibration            =  dap_params.modeler_calibration;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_enable                     =  dap_params.ieq_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_amount                     =  dap_params.ieq_amount;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.ieq_nb_bands                   =  dap_params.ieq_nb_bands;

        for(i= 0; i < DOLBY_DAP_IEQ_MAX_BANDS; i++)
        {
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_center[i]       =  dap_params.a_ieq_band_center[i];
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_ieq_band_target[i]       =  dap_params.a_ieq_band_target[i];
        }

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_enable                      =  dap_params.de_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_amount                      =  dap_params.de_amount;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.de_ducking                     =  dap_params.de_ducking;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.volmax_boost                   =  dap_params.volmax_boost;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.geq_enable                     =  dap_params.geq_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.geq_nb_bands                   =  dap_params.geq_nb_bands;
        for(i= 0; i < DOLBY_DAP_GEQ_MAX_BANDS; i++)
        {
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_center[i]       =  dap_params.a_geq_band_center[i];
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_geq_band_target[i]       =  dap_params.a_geq_band_target[i];
        }

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.optimizer_enable               =  dap_params.optimizer_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.optimizer_nb_bands             =  dap_params.optimizer_nb_bands;
        for(i= 0; i < DOLBY_DAP_OPT_MAX_BANDS; i++)
        {
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_center_freq[i]  =  dap_params.a_opt_band_center_freq[i];
        }
        for(i= 0; i < DOLBY_DAP_MAX_CHANNELS; i++)
        {
            for(j= 0; j < DOLBY_DAP_OPT_MAX_BANDS; j++)
            {
                pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_opt_band_gain[i][j]  =  dap_params.a_opt_band_gain[i][j];
            }
        }

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_enable                    =  dap_params.bass_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_boost                     =  dap_params.bass_boost;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_cutoff                    =  dap_params.bass_cutoff;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.bass_width                     =  dap_params.bass_width;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.reg_nb_bands                   =  dap_params.reg_nb_bands;
        for(i= 0; i < DOLBY_DAP_REG_MAX_BANDS; i++)
        {
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_band_center[i]       =  dap_params.a_reg_band_center[i];
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_low_thresholds[i]    =  dap_params.a_reg_low_thresholds[i];
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_high_thresholds[i]   =  dap_params.a_reg_high_thresholds[i];
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.a_reg_isolated_bands[i]    =  dap_params.a_reg_isolated_bands[i];
        }

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_overdrive            =  dap_params.regulator_overdrive;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_timbre               =  dap_params.regulator_timbre;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_distortion           =  dap_params.regulator_distortion;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_mode                 =  dap_params.regulator_mode;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.regulator_enable               =  dap_params.regulator_enable;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mode              =  dap_params.virtual_bass_mode;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_low_src_freq      =  dap_params.virtual_bass_low_src_freq;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_high_src_freq     =  dap_params.virtual_bass_high_src_freq;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_overall_gain      =  dap_params.virtual_bass_overall_gain;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_slope_gain        =  dap_params.virtual_bass_slope_gain;
        for(i= 0; i < 3; i++)
        {
            pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_subgain[i]    =  dap_params.virtual_bass_subgain[i];
        }
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mix_low_freq      =  dap_params.virtual_bass_mix_low_freq;
        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam.virtual_bass_mix_high_freq     =  dap_params.virtual_bass_mix_high_freq;

        pstAudioCustomerShmData->g_audio_customer_Dolby_DAP_SetParam_UpperSetCnt += 1;
        MApi_AUDIO_COPY_Parameter(DOLBY_DAP_SET_PARAMS, (MS_U32 *)(&dap_params), sizeof(API_AUDIO_CUSTOMER_DOLBY_DAP_PARAM));
    }
    #endif

    return TRUE;
}

#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
/* Initialize, STR */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_InitializeModule);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_InitializeModule_IsFinish);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Suspend);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Resume);

/* Connect & Disconnect */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetParserMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ADEC_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ADEC_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ADC_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ADC_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Mixer_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Mixer_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_CH_Sound_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_CH_Sound_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_FW_MIXER_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_FW_MIXER_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SE_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SE_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SNDOUT_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SNDOUT_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_CAPTURE_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_CAPTURE_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MP3_ENC_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MP3_ENC_Disconnect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AAC_ENC_Connect);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AAC_ENC_Disconnect);

/* Start & Stop */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetCodecType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_StartDecoding);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_StopDecoding);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PauseDecoding);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetMainDecoderOutput);

/* SPDIF */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_SetOutputType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_GetOutputType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_SetCopyInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_SetCategoryCode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_SetLightOnOff);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_SetMonitorOnOff);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SPDIF_TX_ChannelStatus_CTRL);

/* HDMI */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_RX_GetAudioMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_RX_GetCopyInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_RX_SetAudioReturnChannel);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_RX_SetMonitorOnOff);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_TX_SetOutputType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_HDMI_TX_SetMonitorOnOff);

/* ATV */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetInputSource);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetHighDevMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetAudioStandard);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetSoundMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_GetSoundMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetMonitorOnOff);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetAutoMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_StartAutoStandardDetection);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetThreshold);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetPALType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SendCmd);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_GetAudioStatus);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_IsPALType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SIF_SetPrescale);

/* Decoder */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetSyncMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetDecodingType);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetDualMonoOutMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetESInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_IsESExist);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetAudioDescription);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetTrickMode);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetBufferStatus);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetAdecPcmPath);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AdecPcmReady);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AdecPcmGet);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AdecRegisterDecodeDoneCallback);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AdecRegisterEndOfStreamCallback);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AdecRegisterUnderrunCallback);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Auto_Recovery_SetMonitorOnOff);

/* Common Decoder */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Open);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Close);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Start);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Stop);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Set);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Get);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Read);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Write);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_COMMON_DECODER_Flush);

/* Common */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetAudioParam);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetAudioInfo);

/* Customized patch */
EXPORT_SYMBOL(API_AUDIO_CUSTOMIZED_PATCH_SetAudioParam);
EXPORT_SYMBOL(API_AUDIO_CUSTOMIZED_PATCH_GetAudioInfo);

/* Clip Play for ES */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PlayClipDecoder);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_StopClipDecoder);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PauseClipDecoder);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ResumeClipDecoder);

/* Clip Play for PCM */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PlayClipMixer);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_StopClipMixer);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PauseClipMixer);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_ResumeClipMixer);

/* Gain, Mute & Delay */
//---Gain---
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetAudioDescriptionGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetPCMMixerInputGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetFWMixerChannelGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetI2SOutGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetLineOutGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetSPDIFOutGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetHDMIOutGain);
//---Mute---
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetPCMMixerInputMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetFWMixerChannelMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetI2SOutMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetLineOutMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetSPDIFOutMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetHDMIOutMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetI2SOutMuteStatus);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetLineOutMuteStatus);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetSPDIFOutMuteStatus);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Input);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MuteDuringLimitedTime_Output);
//---Delay---
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetChannelDelay);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetAudioDelay);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetSpdifDelay);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_SetHdmiDelay);

/* AENC */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_Start);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_Stop);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_RegisterCallback);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_SetInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_GetInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_SetGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_CopyData);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_AENC_ReleaseData);

/* PCM Capture */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_StartUpload);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_StopUpload);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_RegisterSendPCMCallback);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_SetGain);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_SetMute);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_SetRequestSizeInMs);

/* PCM IO Control */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Open);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Close);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Start);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Stop);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Set);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Get);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Read);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Write);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_PCM_Flush);

/* MM New Mode */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_GetDDRInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_initAesInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_checkAesInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_inputAesFinished);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_AD_initAesInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_AD_checkAesInfo);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MM2_AD_inputAesFinished);

/* Mstar Sound Effect */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_Enable);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_GEQ);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_PEQCoef);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_HPFCoef);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_MODE);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_LEVEL);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Begin);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_End);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_R_MODE_Slope);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_S_MODE_OFFSET);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_AttackTime);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_AVC_ReleaseTime);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_DRC_LEVEL);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_BALANCE);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_SET_NR_Threshold);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_MSTAR_SE_GET_NR_Status);

/* Advanced Sound Effect */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_DTS_SE_Enable);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_DTS_SE_ProcessUnit_Enable);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_DTS_SE_SetParam);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Dolby_DAP_Enable);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Dolby_DAP_ProcessUnit_Enable);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_Dolby_DAP_SetParam);

/* Debug */
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_DebugMenu);
EXPORT_SYMBOL(API_AUDIO_CUSTOMER_DebugMenu_Non_Scanf_ParseCommand);
#endif //#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space

//=====================================================================================================================================
//                   DebugMenu Begin (debug menu Always put on the bottom)
//=====================================================================================================================================
/*

===============================================================================
 * * * How to use * * *
===============================================================================

================================
(0100) [Demo] MP3 Encode
================================
d -> 26 -> d99 -> 100
1. Start
2. Stop
3. Exit
dump file in /tmp/MP3EncDump.mp3

cp -f /tmp/MP3EncDump.mp3 /tmp/usb/sda/sda1/
sync

================================
(0101) [Demo] AAC Encode
================================
d -> 26 -> d99 -> 101
1. Start
2. Stop
3. Exit

dump file in /tmp/AACEncDump.aac
             /tmp/AACEncPCMDump.pcm

cp -f /tmp/AACEncDump.aac     /tmp/usb/sda/sda1/
cp -f /tmp/AACEncPCMDump.pcm  /tmp/usb/sda/sda1/
sync


================================
(0102) [Demo] CLIP Decoder play
================================
d -> 26 -> d99 -> 102
1. Start
2. Stop
3. Pause
4. Resume
5. Exit

================================
(0103) [Demo] PCM Capture
================================
d -> 26 -> d99 -> 103
1. Start
2. Stop
3. Exit

dump file in AU_PCM_CAPTURE_SOURCE_DUMP_PATH

cp -f AU_PCM_CAPTURE_SOURCE_DUMP_PATH /tmp/usb/sda/sda1/
sync

================================
Check PC Counter when DSP Dead
================================
For DEC-DSP
Read 1602FE = pc[15:0] , 1602FC= pc[23:16]

For SE-DSP
Read 1602CE = pc[15:0] , 1602CC= pc[23:16]

===============================================================================
 * * * Note * * *
===============================================================================

*/

void AU_CUS_DumpRegInfo(void)
{
    int i = 0, intOffset = 0;
    AU_nPRINT("\n\n\n\n\n");
    AU_nPRINT(" ====[Audio]==== \n");
    AU_nPRINT("--------------------------------------[112A Bank]--------------------------------------------------\n");
    //--------------------------------------------112A_20 ~ 112A_2F--------------------------------------------
    intOffset = (int)0x112a00;
    i = 0x2;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112A_A0 ~ 112A_AF--------------------------------------------
    intOffset = (int)0x112a00;
    i = 0xa;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    AU_nPRINT("--------------------------------------[112C Bank]--------------------------------------------------\n");
    //--------------------------------------------112C_00 ~ 112C_0F--------------------------------------------
    intOffset = (int)0x112c00;
    i = 0;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112C_40 ~ 112C_4F--------------------------------------------
    intOffset = (int)0x112c00;
    i = 4;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112C_60 ~ 112C_6F--------------------------------------------
    intOffset = (int)0x112c00;
    i = 6;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    AU_nPRINT("--------------------------------------[112D Bank]--------------------------------------------------\n");
    //--------------------------------------------112D_00 ~ 112D_0F--------------------------------------------
    intOffset = (int)0x112d00;
    i = 0;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112D_30 ~ 112D_3F--------------------------------------------
    intOffset = (int)0x112d00;
    i = 3;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112D_50 ~ 112D_5F--------------------------------------------
    intOffset = (int)0x112d00;
    i = 5;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    //--------------------------------------------112D_80 ~ 112D_8F--------------------------------------------
    intOffset = (int)0x112d00;
    i = 8;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    AU_nPRINT("--------------------------------------[1603 Bank]--------------------------------------------------\n");
    //--------------------------------------------1603_90 ~ 1603_9F--------------------------------------------
    intOffset = (int)0x160300;
    i = 9;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    AU_nPRINT("--------------------------------------[112E Bank]--------------------------------------------------\n");
    //--------------------------------------------112E_90 ~ 112E_9F--------------------------------------------
    intOffset = (int)0x112E00;
    i = 9;
    #if 0 //because some customer will re-define printf(), it will cause always "\n" in each function call
    for(j = 0; j<= 7; j++)
    {
        unsigned int temp_reg = intOffset + 16*i + 2*j;
        AU_nPRINT("[0x%x]=0x%-4X,", temp_reg, AU_CUS_ReadAbsReg((MS_U32)temp_reg));
    }
    AU_nPRINT(" @@ \n");
    #endif
    AU_nPRINT("[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X,[0x%x]=0x%-4X, @@ \n",
                (intOffset + 16*i + 2*0), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*0)),
                (intOffset + 16*i + 2*1), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*1)),
                (intOffset + 16*i + 2*2), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*2)),
                (intOffset + 16*i + 2*3), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*3)),
                (intOffset + 16*i + 2*4), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*4)),
                (intOffset + 16*i + 2*5), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*5)),
                (intOffset + 16*i + 2*6), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*6)),
                (intOffset + 16*i + 2*7), AU_CUS_ReadAbsReg((MS_U32)(intOffset + 16*i + 2*7)) );

    AU_nPRINT(" ====[Audio]==== \n");
}


void AU_CUS_ShowAudioBlockDiagram(void)
{
int temp = -1;

AU_CUS_DumpRegInfo();
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT(" _________________     _________________     ___________________    ___________________                      \n");
AU_nPRINT("|ADEC0            |   |ADEC1            |   |ADEC_ATV           |  |Sound Effect       |                     \n");
AU_nPRINT("|.................|   |.................|   |...................|  |...................|                     \n");
AU_nPRINT("|Input      (%-4d)|   |Input      (%-4d)|   |Input        (%-4d)|  |Input        (%-4d)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect               , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect              , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect               , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect   );
AU_nPRINT("|.................|   |.................|   |...................|  |...................|                     \n");
AU_nPRINT("|ID         (%-4d)|   |ID         (%-4d)|   |ID           (%-4d)|  |Basic SE:          |                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID                 , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID                , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID                 );
AU_nPRINT("|UpperCodec (%-4d)|   |UpperCodec (%-4d)|   |UpperSifType (%-4d)|  |function01   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperCodec            , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperCodec           , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperSifType          );
AU_nPRINT("|DriverCodec(%-4d)|   |DriverCodec(%-4d)|   |DriverSifType(%-4d)|  |function02   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverCodec           , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverCodec          , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverSifType         );
AU_nPRINT("|UpperPlay  (%-4d)|   |UpperPlay  (%-4d)|   |UpperPlay    (%-4d)|  |function03   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_UpperPlay             , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_UpperPlay            , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_UpperPlay             );
AU_nPRINT("|DriverPlay (%-4d)|   |DriverPlay (%-4d)|   |DriverPlay   (%-4d)|  |function04   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DriverPlay            , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DriverPlay           , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DriverPlay            );
AU_nPRINT("|.................|   |.................|   |...................|  |function05   (xxxx)|                     \n");
AU_nPRINT("|bMM        (%-4d)|   |bMM        (%-4d)|   |PreScale(A2):      |  |function06   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_bMM                   , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_bMM                  );
AU_nPRINT("|.................|   |.................|   |A2_FM        (%-4d)|  |function07   (xxxx)|                     \n"                                                                                                                                                         , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_A2_FM        );
AU_nPRINT("|Sync       (%-4d)|   |Sync       (%-4d)|   |NICAM        (%-4d)|  |function08   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_SyncMode              , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_SyncMode             , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_NICAM        );
AU_nPRINT("|DRC        (%-4d)|   |DRC        (%-4d)|   |AM           (%-4d)|  |function09   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DolbyDRCMode     , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DolbyDRCMode    , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_AM           );
AU_nPRINT("|DMX        (%-4d)|   |DMX        (%-4d)|   |HIDEV        (%-4d)|  |function10   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AC3P_DownmixMode      , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AC3P_DownmixMode     , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_HIDEV        );
AU_nPRINT("|Dual       (%-4d)|   |Dual       (%-4d)|   |FM_M         (%-4d)|  |function11   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DualmonoMode          , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DualmonoMode         , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_FM_M         );
AU_nPRINT("|Trick      (%-4d)|   |Trick      (%-4d)|   |HIDEV_M      (%-4d)|  |function12   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_TrickMode             , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_TrickMode            , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_HIDEV_M      );
AU_nPRINT("|.................|   |.................|   |...................|  |function13   (xxxx)|                     \n");
AU_nPRINT("|AD_bMain   (%-4d)|   |AD_bMain   (%-4d)|   |PreScale(BTSC):    |  |function14   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_bMain              , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_bMain             );
AU_nPRINT("|AD_Gain    (%-4d)|   |AD_Gain    (%-4d)|   |BTSC         (%-4d)|  |function15   (xxxx)|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_AD_Gain               , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_AD_Gain              , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC         );
AU_nPRINT("|.................|   |.................|   |BTSC_MONO    (%-4d)|  |function16   (xxxx)|                     \n"                                                                                                                                                         , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_MONO    );
AU_nPRINT("|Gain       (%-4d)|   |Gain       (%-4d)|   |BTSC_STEREO  (%-4d)|  |...................|                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Gain                  , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Gain                 , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_STEREO  );
AU_nPRINT("|Mute       (%-4d)|   |Mute       (%-4d)|   |BTSC_SAP     (%-4d)|  |ADV SE:            |                     \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_bMute                 , (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_bMute                , (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Prescale_BTSC_SAP     );
AU_nPRINT("|_________________|   |_________________|   |___________________|  |function01   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function02   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function03   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function04   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function05   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function06   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function07   (xxxx)|                     \n");
AU_nPRINT("                                                                   |function08   (xxxx)|                     \n");
AU_nPRINT("                                                                   |___________________|                     \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("         @                                                                                                   \n");
AU_nPRINT("         @@                                                                                                  \n");
AU_nPRINT(" _____   @ @   ___________    _____                                                                          \n");
AU_nPRINT("|AFIFO|  @ @  |PARSER A   |  |     |                                                                         \n");
AU_nPRINT("|  0  |=>@ @=>|-----------|=>|     |                                                                         \n");
AU_nPRINT("|_____|  @ @  |Input(%-4d)|  |     |                                                                         \n", (int)pstAudioCustomerShmData->g_audio_customer_PARSER_A_Connect    );
AU_nPRINT("         @ @  |___________|  |     |                                                                         \n");
AU_nPRINT(" _____   @ @   ___________   |ADEC0|                                                                         \n");
AU_nPRINT("|AFIFO|  @ @  |PARSER B   |  |     |                                                                         \n");
AU_nPRINT("|  1  |=>@ @=>|-----------|=>|     |                                                                         \n");
AU_nPRINT("|_____|  @ @  |Input(%-4d)|  |     |                                                                         \n", (int)pstAudioCustomerShmData->g_audio_customer_PARSER_B_Connect    );
AU_nPRINT("         @ @  |___________|  |_____|                                                                         \n");
AU_nPRINT(" _____   @ @   ___________    _____                                                                          \n");
AU_nPRINT("|AFIFO|  @ @  |PARSER C   |  |     |                                                                         \n");
AU_nPRINT("|  2  |=>@ @=>|-----------|=>|     |                                                                         \n");
AU_nPRINT("|_____|  @ @  |Input(%-4d)|  |     |                                                                         \n", (int)pstAudioCustomerShmData->g_audio_customer_PARSER_C_Connect    );
AU_nPRINT("         @ @  |___________|  |     |                                                                         \n");
AU_nPRINT(" _____   @ @   ___________   |ADEC1|                                                                         \n");
AU_nPRINT("|AFIFO|  @ @  |PARSER D   |  |     |                                                                         \n");
AU_nPRINT("|  3  |=>@ @=>|-----------|=>|     |                                                                         \n");
AU_nPRINT("|_____|  @ @  |Input(%-4d)|  |     |                                                                         \n", (int)pstAudioCustomerShmData->g_audio_customer_PARSER_D_Connect    );
AU_nPRINT("         @ @  |___________|  |_____|                                                                         \n");
AU_nPRINT("         @ @                                                                                                 \n");
AU_nPRINT("         @@                                                                                                  \n");
AU_nPRINT("         @                                                                                                   \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT(" ___________________    @                                                                                    \n");
AU_nPRINT("|   ADEC PCM PATH   |   @@                                                                                   \n");
AU_nPRINT("|  _______________  |   @ @    ___                                                                           \n");
AU_nPRINT("| |     ADEC0     | |   @ @   |   |                                                                          \n");
AU_nPRINT("| |---------------|====>@ @==>|MCU|                                                                          \n");
AU_nPRINT("| |PcmPath  (%-4d)| |   @ @   |___|                                                                          \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_PCM_OutputPath);
AU_nPRINT("| |_______________| |   @ @                                                                                  \n");
AU_nPRINT("|  _______________  |   @ @    ___                                                                           \n");
AU_nPRINT("| |     ADEC1     | |   @ @   |   |                                                                          \n");
AU_nPRINT("| |---------------|====>@ @==>|DSP|                                                                          \n");
AU_nPRINT("| |PcmPath  (%-4d)| |   @ @   |___|                                                                          \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_PCM_OutputPath);
AU_nPRINT("| |_______________| |   @ @                                                                                  \n");
AU_nPRINT("|___________________|   @ @                                                                                  \n");
AU_nPRINT("                        @@                                                                                   \n");
AU_nPRINT("                        @                                                                                    \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT(" _____ ___________ _______________                                                                           \n");
AU_nPRINT("|     | R2 DMA    |  DSP Dec out  |                                                                          \n");
AU_nPRINT("|_____|___________|_______________|                                                                          \n");
AU_nPRINT("|ADEC0| R2_DMA_1  |R2_DEC_ISR1_EN |                                                                          \n");
AU_nPRINT("|     | (0x80)    |    (0x80)     |                                                                          \n");
AU_nPRINT("|_____|___________|_______________|                                                                          \n");
AU_nPRINT("|ADEC1| R2_DMA_2  |R2_DEC_ISR2_EN |                                                                          \n");
AU_nPRINT("|     | (0x82)    |    (0x83)     |                                                                          \n");
AU_nPRINT("|     | 1R1D not  |               |                                                                          \n");
AU_nPRINT("|_____|_Support___|_______________|                                                                          \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                              @                                                                              \n");
AU_nPRINT("                              @@                                                                             \n");
AU_nPRINT("         @                    @ @                                                                            \n");
AU_nPRINT(" _____   @@    ___________    @ @      _____________                             @     ___________________   \n");
AU_nPRINT("| 0   |  @ @  |ADEC0      |   @ @     |CH7 Sound    |                            @@   |  Sound Output     |  \n");
AU_nPRINT("|DTV  |=>@ @=>|-----------|==>@ @====>|(SCART)      |===========================>@ @  |  _______________  |  \n");
AU_nPRINT("|_____|  @ @  |Input(%-4d)|   @ @     |PATH 7       |                            @ @  | |Speaker        | |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Connect   );
AU_nPRINT(" _____   @ @  |ID   (%-4d)|   @ @     |-------------|..                          @ @  | |---------------| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_DecID     );
AU_nPRINT("| 1   |  @ @  |bMM  (%-4d)|   @ @     |Input  (%-4d)| |                          @ @  | |Input    (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_bMM       , (int)pstAudioCustomerShmData->g_audio_customer_CH7_Sound_Connect                                                                                                              , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Connect                              );
AU_nPRINT("|HDMI |=>@ @  |Gain (%-4d)|   @ @     |inDelay(%-4d)| |                          @ @  | |Gain     (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_Gain      , (int)pstAudioCustomerShmData->g_audio_customer_CH7_Sound_inDelay                                                                                                              , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_Gain                                 );
AU_nPRINT("|_____|  @ @  |Mute (%-4d)|   @ @     |_____________| |                          @ @  | |GainComp (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC0_bMute                                                                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_I2S_Out      );
AU_nPRINT(" _____   @ @  |___________|   @ @      _____________  |   ____________________   @ @  | |Mute     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_I2S_bMute                                );
AU_nPRINT("| 2   |  @ @                  @ @     |CH5 Sound    | |=>|     FW Mixer       |  @ @=>| |_______________| |  \n");
AU_nPRINT("|MM   |=>@ @   ___________    @ @====>|(Main)       |    |     ____________   |  @ @  |  _______________  |  \n");
AU_nPRINT("|_____|  @ @  |ADEC1      |   @ @     |-------------|..  |    |FW Mixer0   |  |  @ @  | |Line0          | |  \n");
AU_nPRINT(" _____   @ @=>|-----------|==>@ @     |Input  (%-4d)| |  |    |(FWM0)      |====>@ @  | |---------------| |  \n"                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_CH5_Sound_Connect  );
AU_nPRINT("| 6   |  @ @  |Input(%-4d)|   @ @     |inDelay(%-4d)| |  |    |PATH 4      |  |  @ @  | |Input    (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Connect   , (int)pstAudioCustomerShmData->g_audio_customer_CH5_Sound_inDelay                                                                                                              , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Connect                            );
AU_nPRINT("|MMUNI|=>@ @  |ID   (%-4d)|   @ @     |_____________| |  |    |------------|  |  @ @  | |Gain     (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_DecID                                                                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_Gain                               );
AU_nPRINT("|_____|  @ @  |bMM  (%-4d)|   @ @      _____________  |  |    |CH5         |  |  @ @  | |GainComp (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_bMM                                                                                                                                                                                       , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_0_Out   );
AU_nPRINT(" _____   @ @  |Gain (%-4d)|   @ @     |CH6 Sound    | |=>|    |C[CH5](%-4d)|  |  @ @  | |Mute     (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_Gain                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]        , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line0_bMute                              );
AU_nPRINT("| 3   |  @ @  |Mute (%-4d)|   @ @====>|(Sub)        |    |    |Gain  (%-4d)|  |  @ @  | |_______________| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC1_bMute                                                                         , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]   );
AU_nPRINT("|CLIP |=>@ @  |___________|   @ @     |-------------|===>|    |Mute  (%-4d)|  |  @ @  |  _______________  |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]  );
AU_nPRINT("|_____|  @@                   @ @     |Input  (%-4d)|    |    |------------|  |  @ @  | |Line1          | |  \n"                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_CH6_Sound_Connect  );
AU_nPRINT("         @                    @ @     |inDelay(%-4d)| |=>|    |CH6         |  |  @ @  | |---------------| |  \n"                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_CH6_Sound_inDelay  );
AU_nPRINT("                              @ @     |_____________| |  |    |C[CH6](%-4d)|  |  @ @  | |Input    (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]        , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Connect                            );
AU_nPRINT(" _____         ___________    @ @      _____________  |  |    |Gain  (%-4d)|  |  @ @  | |Gain     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]   , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_Gain                               );
AU_nPRINT("| 4   |       |ADEC_ATV   |   @ @     |CH8 Sound    | |  |    |Mute  (%-4d)|  |  @ @  | |GainComp (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]  , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_1_Out   );
AU_nPRINT("|ATV  |======>|-----------|==>@ @  |=>|(DMA)        | |  |    |------------|  |  @ @  | |Mute     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line1_bMute                              );
AU_nPRINT("|_____|       |Input(%-4d)|   @ @  |  |-------------|..  |    |CH7         |  |  @ @  | |_______________| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_Connect);
AU_nPRINT("              |ID   (%-4d)|   @ @  |  |Input  (%-4d)|    |    |Input(%-4d) |  |  @ @  |  _______________  |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADEC_ATV_DecID  , (int)pstAudioCustomerShmData->g_audio_customer_CH8_Sound_Connect  , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        );
AU_nPRINT("              |___________|   @ @  |  |inDelay(%-4d)|    |    |Gain (%-4d) |  |  @ @  | |Line2          | |  \n"                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_CH8_Sound_inDelay  , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   );
AU_nPRINT(" _____                        @ @  |  |_____________|    |    |Mute (%-4d) |  |  @ @  | |---------------| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  );
AU_nPRINT("| 5   |                       @ @  |                     |    |------------|  |  @ @  | |Input    (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Connect                            );
AU_nPRINT("|HDMI |======================>@ @  |                     |    |CH8         |  |  @ @  | |Gain     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_Gain                               );
AU_nPRINT("|_____|                       @ @  |                     |    |Input(%-4d) |  |  @ @  | |GainComp (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_2_Out   );
AU_nPRINT(" _____   @                    @ @  |                     |    |Gain (%-4d) |  |  @ @  | |Mute     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line2_bMute                              );
AU_nPRINT("|Line |  @@                   @ @  |                     |    |Mute (%-4d) |  |  @ @  | |_______________| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  );
AU_nPRINT("|In-0 |=>@ @                  @ @  |                     |    |____________|  |  @ @  |  _______________  |  \n"                                                                                                                                                                                                                                                 );
AU_nPRINT("|-----|  @ @                  @ @  |                     |           |        |  @ @  | |Line3          | |  \n"                                                                                                                                                                                                                                                 );
AU_nPRINT("|Line |  @ @                  @ @  |                     |     ______|_____   |  @ @  | |---------------| |  \n");
AU_nPRINT("|In-1 |=>@ @   ___________    @ @  |                     |    |Delay0      |  |  @ @  | |Input    (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Connect                            );
AU_nPRINT("|-----|  @ @  |ADC0       |   @ @  |                     |    |(DLY0)      |====>@ @  | |Gain     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_Gain                               );
AU_nPRINT("|Line |  @ @=>|-----------|==>@ @  |                     |    |PATH ?      |  |  @ @  | |GainComp (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_LINE_3_Out   );
AU_nPRINT("|In-2 |=>@ @  |Input(%-4d)|   @ @  |                     |    |------------|  |  @ @  | |Mute     (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADC0_Connect                                                                                                                                                                                    , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_Line3_bMute                              );
AU_nPRINT("|-----|  @ @  |           |   @ @  |                     |    |Delay (%-4d)|  |  @ @  | |_______________| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer0_Channel_Delay                                    );
AU_nPRINT("|Line |  @ @  |___________|   @ @  |                     |    |____________|  |  @ @  |                   |  \n");
AU_nPRINT("|In-3 |=>@ @                  @ @  |                     |           :        |  @ @  |  _______________  |  \n");
AU_nPRINT("|-----|  @ @   ___________    @ @  |                     |           :        |  @ @  | |SPDIF          | |  \n");
AU_nPRINT("|Line |  @ @  |ADC1       |   @ @  |                     | ..........:        |  @ @  | |---------------| |  \n");
AU_nPRINT("|In-4 |=>@ @  |-----------|==>@ @  |                     | :   ____________   |  @ @  | |Input    (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Connect                            );
AU_nPRINT("|-----|  @ @=>|Input(%-4d)|   @ @  |                     | :  |FW Mixer1   |  |  @ @  | |Gain     (%-4d)| |  \n", (int)pstAudioCustomerShmData->g_audio_customer_ADC1_Connect                                                                                                                                                                                    , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_Gain                               );
AU_nPRINT("|Line |  @ @  |           |   @ @  |                     | :  |(FWM1)      |====>@ @  | |GainComp (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_SPDIF_Out    );
AU_nPRINT("|In-5 |=>@ @  |___________|   @ @  |                     | :  |PATH ?      |  |  @ @  | |Mute     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_bMute                              );
AU_nPRINT("|-----|  @ @                  @ @  |                     | :  |------------|  |  @ @  | |UpperDly (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_UpperDelay                         );
AU_nPRINT("|Mic  |  @ @                  @ @  |                     | :  |CH5         |  |  @ @  | |DriverDly(%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_SPDIF_DriverDelay                        );
AU_nPRINT("|In   |=>@ @                  @ @  |                     | :  |C[CH5](%-4d)|  |  @ @  | |Mode     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]        , (int)pstAudioCustomerShmData->g_audio_customer_SPDIF_TX_UpperOutputType                           );
AU_nPRINT("|_____|  @@                   @ @  |                     | :  |Gain  (%-4d)|  |  @ @  | |fg       (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]   , (int)pstAudioCustomerShmData->g_audio_customer_MainDecoderOutput                                  );
AU_nPRINT("         @                    @ @  |                     | :  |Mute  (%-4d)|  |  @ @  | |_______________| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]  );
AU_nPRINT(" _____                        @ @  |                     | :  |------------|  |  @ @  |  _______________  |  \n"                                                                                                                                                                                                                                                 );
AU_nPRINT("|     |                       @ @  |                     | :  |CH6         |  |  @ @  | |ARC            | |  \n"                                                                                                                                                                                                                                                 );
AU_nPRINT("|SCART|======================>@ @  |                     | :  |C[CH6](%-4d)|  |  @ @  | |---------------| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]        );
AU_nPRINT("|_____|                       @ @  |                     | :  |Gain  (%-4d)|  |  @ @  | |Mode     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]   , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_ARC_mode                                 );
AU_nPRINT(" __________                   @ @  |                     | :  |Mute  (%-4d)|  |  @ @  | |_______________| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]  );
AU_nPRINT("|R2DMA_DSP1|                  @ @  |                     | :  |------------|  |  @ @  |  _______________  |  \n");
AU_nPRINT("|----------|=================>@ @  |                     | :  |CH7         |  |  @ @  | |HDMI           | |  \n");
AU_nPRINT("|bEn (%-4d)|                  @ @  |                     | :  |Input(%-4d) |  |  @ @  | |---------------| |  \n", (int)temp                                                                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        );
AU_nPRINT("|__________|                  @ @  |                     | :  |Gain (%-4d) |  |  @ @  | |Input    (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Connect                             );
AU_nPRINT(" __________        @          @ @  |                     | :  |Mute (%-4d) |  |  @ @  | |Gain     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_Gain                                );
AU_nPRINT("|R2DMA_DSP3|       @@         @ @  |                     | :  |------------|  |  @ @  | |GainComp (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_internal_patch_HW_SRC_Gain_Compensate_HDMI_Out     );
AU_nPRINT("|----------|======>@ @        @ @  |                     | :  |CH8         |  |  @ @  | |Mute     (%-4d)| |  \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_bMute                               );
AU_nPRINT("|bEn (%-4d)|       @ @        @ @  |                     | :  |Input(%-4d) |  |  @ @  | |UpperDly (%-4d)| |  \n", (int)temp                                                                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_UpperDelay                          );
AU_nPRINT("|__________|       @ @        @ @  |                     | :  |Gain (%-4d) |  |  @ @  | |DriverDly(%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   , (int)pstAudioCustomerShmData->g_audio_customer_Sound_Out_HDMI_DriverDelay                         );
AU_nPRINT(" __________        @ @=======>@ @  |                     | :  |Mute (%-4d) |  |  @ @  | |Mode     (%-4d)| |  \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  , (int)pstAudioCustomerShmData->g_audio_customer_HDMI_TX_UpperOutputType                            );
AU_nPRINT("|SWDMA_DSP3|       @ @        @ @  |                     | :  |____________|  |  @ @  | |_______________| |  \n");
AU_nPRINT("|----------|======>@ @        @ @  |                     | :         |        |  @ @  |___________________|  \n");
AU_nPRINT("|bEn (%-4d)|       @ @        @ @  |                     | :   ______|_____   |  @ @                         \n", (int)temp                                                      );
AU_nPRINT("|__________|       @@         @ @  |                     | :  |Delay1      |  |  @ @                         \n");
AU_nPRINT("                   @          @ @  |                     | :  |(DLY1)      |====>@ @                         \n");
AU_nPRINT("                              @ @  |                     | :  |PATH ?      |  |  @ @                         \n");
AU_nPRINT("                              @ @  |                     | :  |------------|  |  @ @                         \n");
AU_nPRINT("                              @ @  |                     | :  |Delay (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer1_Channel_Delay                                    );
AU_nPRINT("                              @ @  |                     | :  |____________|  |  @ @                         \n");
AU_nPRINT("                   @          @ @  |                     | :         :        |  @ @                         \n");
AU_nPRINT(" __________        @@         @@   |                     | :         :        |  @ @                         \n");
AU_nPRINT("|HWDMA_Read|       @ @        @    |                     | : ........:        |  @ @                         \n");
AU_nPRINT("|----------|======>@ @             |                     | : : ____________   |  @ @                         \n");
AU_nPRINT("|bEn (%-4d)|       @ @             |                     | : :|FW Mixer2   |  |  @ @                         \n", (int)temp                                                      );
AU_nPRINT("|__________|       @ @..............                     | : :|(FWM2)      |====>@ @                         \n");
AU_nPRINT("                   @ @                                   | : :|PATH ?      |  |  @ @                         \n");
AU_nPRINT("                   @ @                                   | : :|------------|  |  @ @                         \n");
AU_nPRINT("              |===>@ @                                   | : :|CH5         |  |  @ @                         \n");
AU_nPRINT("              |    @@                                    | : :|C[CH5](%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]        );
AU_nPRINT("              |    @                                     | : :|Gain  (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]   );
AU_nPRINT("              |                                          | : :|Mute  (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH5]  );
AU_nPRINT("              |____________                              | : :|------------|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|CH6         |  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|C[CH6](%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]        );
AU_nPRINT("                           |                             | : :|Gain  (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]   );
AU_nPRINT("                           |                             | : :|Mute  (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH6]  );
AU_nPRINT("                           |                             | : :|------------|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|CH7         |  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|Input(%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        );
AU_nPRINT("                           |                             | : :|Gain (%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   );
AU_nPRINT("                           |                             | : :|Mute (%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  );
AU_nPRINT("                           |                             | : :|------------|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|CH8         |  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|Input(%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Connect[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]        );
AU_nPRINT("                           |                             | : :|Gain (%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Gain[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]   );
AU_nPRINT("                           |                             | : :|Mute (%-4d) |  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_bMute[API_AUDIO_CUSTOMER_FWM_INPUT_CH8]  );
AU_nPRINT("                           |                             | : :|____________|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :       |        |  @ @                         \n");
AU_nPRINT("                           |                             | : : ______|_____   |  @ @                         \n");
AU_nPRINT("                           |                             | : :|Delay2      |  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|(DLY0)      |====>@ @                         \n");
AU_nPRINT("                           |                             | : :|PATH ?      |  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|------------|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :|Delay (%-4d)|  |  @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_FW_Mixer2_Channel_Delay                                    );
AU_nPRINT("                           |                             | : :|____________|  |  @ @                         \n");
AU_nPRINT("                           |                             | : :         |      |  @ @                         \n");
AU_nPRINT("                           |                             | : :         |      |  @ @                         \n");
AU_nPRINT("                           |                             | : :         |      |  @ @                         \n");
AU_nPRINT("                           |                             | : :         |      |  @ @                         \n");
AU_nPRINT("                           |                             | : :         |      |  @ @                         \n");
AU_nPRINT("                           |                             | : :.......  |      |  @ @                         \n");
AU_nPRINT("                           |                             | :        |  |      |  @ @                         \n");
AU_nPRINT("                           |                             | :        |  |      |  @ @                         \n");
AU_nPRINT("                           |                             | :......  |  |      |  @ @                         \n");
AU_nPRINT("                           |                             |       |  |  |      |  @ @                         \n");
AU_nPRINT("                           |                             |_______|__|__|______|  @ @                         \n");
AU_nPRINT("                           |                                     |  |  |         @ @                         \n");
AU_nPRINT("                           |                                 @@@@@@@@@@@@@@@     @ @                         \n");
AU_nPRINT("                           |                                  @           @      @ @                         \n");
AU_nPRINT("                           |                                   @@@@@@@@@@@       @ @                         \n");
AU_nPRINT("                           |                                ________|______      @ @                         \n");
AU_nPRINT("                           |                               |Audio          |     @ @                         \n");
AU_nPRINT("                           |                               |Delay          |     @ @                         \n");
AU_nPRINT("                           |                               |PATH 5         |====>@ @                         \n");
AU_nPRINT("                           |                               |---------------|     @ @                         \n");
AU_nPRINT("                           |                               |UpperDly (%-4d)|     @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_SE_UpperDelay                                              );
AU_nPRINT("                           |                               |DriverDly(%-4d)|     @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_SE_DriverDelay                                             );
AU_nPRINT("                           |                               |_______________|     @ @                         \n");
AU_nPRINT("                           |                               |Sound          |     @ @                         \n");
AU_nPRINT("                           |                               |Effect         |     @ @                         \n");
AU_nPRINT("                           |                               |(PreR2)        |====>@ @                         \n");
AU_nPRINT("                           |                               |PATH ?         |     @ @                         \n");
AU_nPRINT("                           |                               |---------------|     @ @                         \n");
AU_nPRINT("                           |                               |Input (%-4d)   |     @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_SE_PreR2_Connect                                           );
AU_nPRINT("                           |                               |_______________|     @ @                         \n");
AU_nPRINT("                           |                               |Sound          |     @ @                         \n");
AU_nPRINT("                           |                               |Effect         |     @ @                         \n");
AU_nPRINT("                           |                               |(DSPSE)        |====>@ @                         \n");
AU_nPRINT("                           |                               |PATH 6         |     @ @                         \n");
AU_nPRINT("                           |                               |---------------|     @ @                         \n");
AU_nPRINT("                           |                               |Input (%-4d)   |     @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_SE_DspSE_Connect                                           );
AU_nPRINT("                           |                               |_______________|     @ @                         \n");
AU_nPRINT("                           |                               |Sound          |     @ @                         \n");
AU_nPRINT("                           |                               |Effect         |     @ @                         \n");
AU_nPRINT("                           |                               |(PostR2)       |====>@ @                         \n");
AU_nPRINT("                           |                               |PATH ?         |     @ @                         \n");
AU_nPRINT("                           |                               |---------------|     @ @                         \n");
AU_nPRINT("                           |                               |Input (%-4d)   |     @ @                         \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_SE_PostR2_Connect                                          );
AU_nPRINT("                           |                               |_______________|     @ @                         \n");
AU_nPRINT("                           |                                                     @ @                         \n");
AU_nPRINT("                           |                                                     @ @                         \n");
AU_nPRINT("                           |                                                     @@                          \n");
AU_nPRINT("                           |                                                     @                           \n");
AU_nPRINT("                           |                                                                                 \n");
AU_nPRINT("                           |                                                                                 \n");
AU_nPRINT(" ____________________      |                                                                                 \n");
AU_nPRINT("|     AMixer         |     |                                                                                 \n");
AU_nPRINT("|  ______________    |     |                                                                                 \n");
AU_nPRINT("| |AMIXER0       |   |     |                                                                                 \n");
AU_nPRINT("| |--------------|==>|     |                                                                                 \n");
AU_nPRINT("| |C[AMIX0](%-4d)|   |     |                                                                                 \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX0] );
AU_nPRINT("| |ID      (%-4d)|   |     |                                                                                 \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX0]      );
AU_nPRINT("| |Gain    (%-4d)|   |     |                                                                                 \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX0]    );
AU_nPRINT("| |Mute    (%-4d)|   |     |                                                                                 \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX0]   );
AU_nPRINT("| |______________|   |     |                                                                                 \n");
AU_nPRINT("|  ______________    |     |                                                                                 \n");
AU_nPRINT("| |AMIXER1       |   |     |                                                                                 \n");
AU_nPRINT("| |--------------|==>|     |                                                                                 \n");
AU_nPRINT("| |C[AMIX1](%-4d)|   |     |                                                     @     __________________    \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX1] );
AU_nPRINT("| |ID      (%-4d)|   |     |                                                     @@   |   PCM Capture    |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX1]      );
AU_nPRINT("| |Gain    (%-4d)|   |     |                           ______________            @ @  |  ______________  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX1]    );
AU_nPRINT("| |Mute    (%-4d)|   |     |                          |CH5           |==========>@ @  | |PCM Capture0  | |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX1]   );
AU_nPRINT("| |______________|   |     |                          |______________|           @ @=>| |--------------| |   \n");
AU_nPRINT("|  ______________    |     |                          |CH6           |==========>@ @  | |Input   (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Connect       );
AU_nPRINT("| |AMIXER2       |   |     |                          |______________|           @ @  | |bEn     (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bEnable       );
AU_nPRINT("| |--------------|==>|     |                          |CH7           |==========>@ @  | |Gain    (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Gain          );
AU_nPRINT("| |C[AMIX2](%-4d)|   |     |                          |______________|           @ @  | |Mute    (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX2]                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_bMute         );
AU_nPRINT("| |ID      (%-4d)|   |     |                          |CH8           |==========>@ @  | |Delay   (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX2]                                                                                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE0_Delay         );
AU_nPRINT("| |Gain    (%-4d)|   |     |                          |______________|           @ @  | |______________| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX2]    );
AU_nPRINT("| |Mute    (%-4d)|   |     |                          |PCM           |==========>@ @  |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX2]   );
AU_nPRINT("| |______________|   |     |                          |______________|           @ @  |  ______________  |   \n");
AU_nPRINT("|  ______________    |     |                          |PCM_Delay     |==========>@ @  | |PCM Capture1  | |   \n");
AU_nPRINT("| |AMIXER3       |   |     |                          |______________|           @ @=>| |--------------| |   \n");
AU_nPRINT("| |--------------|==>|     |                          |PCM_SE        |==========>@ @  | |Input   (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Connect       );
AU_nPRINT("| |C[AMIX3](%-4d)|   |     |                          |______________|           @ @  | |bEn     (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX3]                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bEnable       );
AU_nPRINT("| |ID      (%-4d)|   |     |                          |MIXER         |==========>@ @  | |Gain    (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX3]                                                                                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Gain          );
AU_nPRINT("| |Gain    (%-4d)|   |     |                          |______________|           @ @  | |Mute    (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX3]                                                                                                                                        , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_bMute         );
AU_nPRINT("| |Mute    (%-4d)| __|__   |                          |FWM0          |==========>@ @  | |Delay   (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX3]                                                                                                                                       , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE1_Delay         );
AU_nPRINT("| |______________||PCM  |  |                          |______________|           @ @  | |______________| |   \n");
AU_nPRINT("|  ______________ |Mixer|..|                          |FWM1          |==========>@ @  |                  |   \n");
AU_nPRINT("| |AMIXER4       ||_____|                             |______________|           @ @  |                  |   \n");
AU_nPRINT("| |--------------|   |                                |FWM2          |==========>@ @  |                  |   \n");
AU_nPRINT("| |C[AMIX4](%-4d)|==>|                                |______________|           @ @  |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX4] );
AU_nPRINT("| |ID      (%-4d)|   |                                                           @ @  |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX4]      );
AU_nPRINT("| |Gain    (%-4d)|   |                                                           @ @  |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX4]    );
AU_nPRINT("| |Mute    (%-4d)|   |                                                           @ @  |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX4]   );
AU_nPRINT("| |______________|   |                                                           @ @  |                  |   \n");
AU_nPRINT("|  ______________    |                                                           @ @  |                  |   \n");
AU_nPRINT("| |AMIXER5       |   |                                                           @ @  |                  |   \n");
AU_nPRINT("| |--------------|==>|                                 ___   @                   @ @  |                  |   \n");
AU_nPRINT("| |C[AMIX5](%-4d)|   |                                |   |  @@    ___________   @ @  |  ______________  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX5] );
AU_nPRINT("| |ID      (%-4d)|   |                                |Ch5|=>@ @  |MP3_ENC    |  @ @  | |PCM Capture2  | |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX5]      );
AU_nPRINT("| |Gain    (%-4d)|   |                                |___|  @ @  |-----------|  @ @  | |--------------| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX5]    );
AU_nPRINT("| |Mute    (%-4d)|   |                                 ___   @ @=>|Input(%-4d)|=>@ @=>| |Input   (%-4d)| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX5]                           , (int)pstAudioCustomerShmData->g_audio_customer_MP3_ENC_Connect                                            , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Connect       );
AU_nPRINT("| |______________|   |                                |   |  @ @  |bEn  (%-4d)|  @ @  | |bEn     (%-4d)| |   \n"                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_MP3_ENC_bEnable                                            , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bEnable       );
AU_nPRINT("|  ______________    |                                |Ch6|=>@ @  |___________|  @ @  | |Gain    (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Gain          );
AU_nPRINT("| |AMIXER6       |   |                                |___|  @@                  @@   | |Mute    (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_bMute         );
AU_nPRINT("| |--------------|==>|                                       @                   @    | |Delay   (%-4d)| |   \n"                                                                                                                                                                                                                                                 , (int)pstAudioCustomerShmData->g_audio_customer_PCM_CAPTURE2_Delay         );
AU_nPRINT("| |C[AMIX6](%-4d)|   |                                                                | |______________| |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX6] );
AU_nPRINT("| |ID      (%-4d)|   |                                                                |                  |   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX6]      );
AU_nPRINT("| |Gain    (%-4d)|   |                                                                |__________________|   \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX6]    );
AU_nPRINT("| |Mute    (%-4d)|   |                                                                                       \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX6]   );
AU_nPRINT("| |______________|   |                                          ______________   @                           \n");
AU_nPRINT("|  ______________    |                                         |              |  @@      ______________      \n");
AU_nPRINT("| |AMIXER7       |   |                                         |PCM Capture0  |=>@ @    |AENC_ENC      |     \n");
AU_nPRINT("| |--------------|==>|                                         |______________|  @ @    |--------------|     \n");
AU_nPRINT("| |C[AMIX7](%-4d)|   |                                          ______________   @ @===>|Input   (%-4d)|     \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Connect[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX7]                                                                                                                                     , (int)pstAudioCustomerShmData->g_audio_customer_AAC_ENC_Connect            );
AU_nPRINT("| |ID      (%-4d)|   |                                         |              |  @ @    |bEn     (%-4d)|     \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_ID[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX7]                                                                                                                                          , (int)pstAudioCustomerShmData->g_audio_customer_AAC_ENC_bEnable            );
AU_nPRINT("| |Gain    (%-4d)|   |                                         |PCM Capture 1 |=>@ @    |______________|     \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_Gain[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX7]    );
AU_nPRINT("| |Mute    (%-4d)|   |                                         |______________|  @@                          \n", (int)pstAudioCustomerShmData->g_audio_customer_PCM_Mixer_bMute[API_AUDIO_CUSTOMER_PCM_MIXER_INPUT_AMIX7]   );
AU_nPRINT("| |______________|   |                                                           @                           \n");
AU_nPRINT("|____________________|                                                                                       \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("                                                                                                             \n");
AU_nPRINT("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
AU_nPRINT("\n\n\n\n\n");
}

static EN_COMMNAD_INDEX AU_CUS_Command_Parser(audio_tunnel* pAudio_tunnel)
{
    MS_U32 i = 0;

    for(i = AU_DebugMenu_IDX; i < API_AUDIO_CUSTOMER_MAX_COMMNAD_IDX; i++)
    {
        if(strlen(pAudio_tunnel->name) != strlen(API_AUDIO_CUSTOMER_COMMNAD_INFO[i].cCommmandName))
        {
            continue;
        }

        if(AU_CUS_strcmp(pAudio_tunnel->name, API_AUDIO_CUSTOMER_COMMNAD_INFO[i].cCommmandName, strlen(API_AUDIO_CUSTOMER_COMMNAD_INFO[i].cCommmandName)) == 0)
        {
            return API_AUDIO_CUSTOMER_COMMNAD_INFO[i].u32CommmandIndex;
        }
    }

    AU_nPRINT("[A][%s] [%d] unsupport function\n", __FUNCTION__, __LINE__);
    return API_AUDIO_CUSTOMER_MAX_COMMNAD_IDX;
}

/* Debug */
void API_AUDIO_CUSTOMER_DebugMenu(void * pVoid, MS_BOOL scanf_bSupport)
{
    API_AUDIO_CUSTOMER_DEBUG_PARAM *dbg_param_t;
    audio_tunnel* pAudio_tunnel_set_param;
    pAudio_tunnel_set_param = (audio_tunnel*)pVoid;
    dbg_param_t = (API_AUDIO_CUSTOMER_DEBUG_PARAM*)pAudio_tunnel_set_param->pdata;
    AU_UNUSED(dbg_param_t);

    API_AUDIO_CUSTOMER_DEBUG_INFO *dbg_info_t;
    audio_tunnel* pAudio_tunnel_get_info;
    pAudio_tunnel_get_info = (audio_tunnel*)pVoid;
    dbg_info_t = (API_AUDIO_CUSTOMER_DEBUG_INFO*)pAudio_tunnel_get_info->pdata;
    AU_UNUSED(dbg_info_t);

#if 0
    AU_nPRINT("[AUDIO][%s] [%d] [param = %ld] [param2 = %ld] [param3 = %ld] [param4 = %ld] [param5 = %ld] [param6 = %ld] [param7 = %ld] [param8 = %ld] [param9 = %ld] [param10 = %ld]\n", __FUNCTION__, __LINE__,
            dbg_param_t->Dbg_Param,
            dbg_param_t->Dbg_Param2,
            dbg_param_t->Dbg_Param3,
            dbg_param_t->Dbg_Param4,
            dbg_param_t->Dbg_Param5,
            dbg_param_t->Dbg_Param6,
            dbg_param_t->Dbg_Param7,
            dbg_param_t->Dbg_Param8,
            dbg_param_t->Dbg_Param9,
            dbg_param_t->Dbg_Param10
            );

    AU_nPRINT("[AUDIO][%s] [%d] [Info = %ld] [Info2 = %ld] [Info3 = %ld] [Info4 = %ld] [Info5 = %ld] [Info6 = %ld] [Info7 = %ld] [Info8 = %ld] [Info9 = %ld] [Info10 = %ld]\n", __FUNCTION__, __LINE__,
            dbg_info_t->Dbg_Info,
            dbg_info_t->Dbg_Info2,
            dbg_info_t->Dbg_Info3,
            dbg_info_t->Dbg_Info4,
            dbg_info_t->Dbg_Info5,
            dbg_info_t->Dbg_Info6,
            dbg_info_t->Dbg_Info7,
            dbg_info_t->Dbg_Info8,
            dbg_info_t->Dbg_Info9,
            dbg_info_t->Dbg_Info10
            );
#endif

    EN_COMMNAD_INDEX command_index = API_AUDIO_CUSTOMER_MAX_COMMNAD_IDX;

    command_index = AU_CUS_Command_Parser(pAudio_tunnel_set_param);
    command_index = AU_CUS_Command_Parser(pAudio_tunnel_get_info);

    AU_CUS_ShmInit();
    AU_CUS_Mutex_Init();

    // For applications that don't use scanf, change the behavior so that
    // AU_CUS_DebugMenu() will sleep until new arguments from newly added API
    // API_AUDIO_CUSTOMER_DebugMenu_Non_Scanf_ParseCommand() become available.
    pstAudioCustomerShmData->g_audio_customer_scanf_bSupport = scanf_bSupport;

    switch(command_index)
    {
        case AU_DebugMenu_IDX:
        {
            if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == TRUE)
            {
                AU_CUS_DebugMenu();
            }
            else if(pstAudioCustomerShmData->g_audio_customer_scanf_bSupport == FALSE) //NON_SCANF version: Allow debug menu to work without scanf
            {
                AU_CUS_CreateDebugMenuThread();
            }
        }
        break;

        default:
            break;
    }
    return;
}

void API_AUDIO_CUSTOMER_DebugMenu_Non_Scanf_ParseCommand(char *cmdString)
{

#ifdef MSOS_TYPE_LINUX_KERNEL //Kernel Space
//not support in Kernel Space

#else
    char *cmd;
    int index=0;

    non_scanf_paramIdx = 0;
    non_scanf_paramsCount = 0;
    memset(non_scanf_params,    0, NON_SCANF_DEBUG_CMD_PARAMS_MAX);
    memset(non_scanf_paramsHex, 0, NON_SCANF_DEBUG_CMD_PARAMS_MAX);
    memset(non_scanf_paramsStr, 0, AU_DEBUG_INPUT_STR_LENGTH +1);

    cmd = strtok(cmdString, ";");
    while(cmd != NULL)
    {
        if(cmd[0] < 0x30 || cmd[0] > 0x39) // not integer (0 ~ 9)
        {
            // store the str in global var, only one string is supported in the command so far.
            strcpy(non_scanf_paramsStr, cmd);
            AU_nPRINT("String: \033[0;33m %s \033[0m", non_scanf_paramsStr);
        }
        else
        {
            // parse the str in both decimal and heximal just in case
            non_scanf_params[index] = strtoul(cmd, (char**) NULL, 10);
            non_scanf_paramsHex[index] = strtoul(cmd, (char**) NULL, 16);
        }
        index++;

        cmd = strtok(NULL, ";");
        if(index >= NON_SCANF_DEBUG_CMD_PARAMS_MAX)
        {
            break;
        }
    }
    non_scanf_paramsCount = index;

    AU_nPRINT("\033[0;33m NON_SCANF: Parse debug command:");
    for(index = 0; index < non_scanf_paramsCount; index++)
    {
        AU_nPRINT("%d ", non_scanf_params[index]);
    }
    AU_nPRINT("\033[0m \n");
#endif
}

MS_BOOL API_AUDIO_CUSTOMER_Testing_7202(void * pVoid)
{
    AU_CUS_Where_Am_I();

    //================================================================================================
    //                   AUDIO_BLOCK_DIAGRAM
    //================================================================================================
    audio_tunnel* pAudio_tunnel_audio_block_diagram;
    pAudio_tunnel_audio_block_diagram = (audio_tunnel*)pVoid;
    int global_test = 1;

    if(AU_CUS_strcmp(pAudio_tunnel_audio_block_diagram->name, "AUDIO_BLOCK_DIAGRAM", 19) == 0)
    {
        pAU_nDBG_Log_To_File        = AU_CUS_FileOpen(AU_NDBG_LOG_TO_FILE_PATH, "wb");
        pAU_nDBG_MenuLog_To_File    = AU_CUS_FileOpen(AU_NDBG_MENULOG_TO_FILE_PATH, "wb");

        AU_CUS_ShowAudioBlockDiagram();

        pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = TRUE;
        pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg    = TRUE;

        AU_nDBG("[global_test = 0x%x] \n", global_test);
        AU_nThreadDBG("[global_test = 0x%x] \n", global_test);

        AU_CUS_SHOW_ALL_VERSION();

        pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = FALSE;
        pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg    = FALSE;
        AU_nDBG("[global_test = 0x%x] \n", global_test);
        AU_nThreadDBG("[global_test = 0x%x] \n", global_test);
    }

    //================================================================================================
    //                   SET_PARAM_TEST
    //================================================================================================
    API_AUDIO_CUSTOMER_DEBUG_PARAM *dbg_param_t;

    audio_tunnel* pAudio_tunnel_set_param;
    pAudio_tunnel_set_param = (audio_tunnel*)pVoid;

    if(AU_CUS_strcmp(pAudio_tunnel_set_param->name, "SET_PARAM_TEST", 14) == 0)
    {
        dbg_param_t = (API_AUDIO_CUSTOMER_DEBUG_PARAM*)pAudio_tunnel_set_param->pdata;

        AU_nPRINT("[AUDIO][%s] [%d] [param = %ld] [param2 = %ld] [param3 = %ld] [param4 = %ld] [param5 = %ld] [param6 = %ld] [param7 = %ld] [param8 = %ld] [param9 = %ld] [param10 = %ld]\n", __FUNCTION__, __LINE__,
                (long int)dbg_param_t->Dbg_Param,
                (long int)dbg_param_t->Dbg_Param2,
                (long int)dbg_param_t->Dbg_Param3,
                (long int)dbg_param_t->Dbg_Param4,
                (long int)dbg_param_t->Dbg_Param5,
                (long int)dbg_param_t->Dbg_Param6,
                (long int)dbg_param_t->Dbg_Param7,
                (long int)dbg_param_t->Dbg_Param8,
                (long int)dbg_param_t->Dbg_Param9,
                (long int)dbg_param_t->Dbg_Param10
                );

        return TRUE;
    }

    //================================================================================================
    //                   GET_INFO_TEST
    //================================================================================================
    API_AUDIO_CUSTOMER_DEBUG_INFO *dbg_info_t;

    audio_tunnel* pAudio_tunnel_get_info;
    pAudio_tunnel_get_info = (audio_tunnel*)pVoid;

    if(AU_CUS_strcmp(pAudio_tunnel_get_info->name, "GET_INFO_TEST", 13) == 0)
    {
        dbg_info_t = (API_AUDIO_CUSTOMER_DEBUG_INFO*)pAudio_tunnel_get_info->pdata;

        dbg_info_t->Dbg_Info   = 1;
        dbg_info_t->Dbg_Info2  = 2;
        dbg_info_t->Dbg_Info3  = 3;
        dbg_info_t->Dbg_Info4  = 4;
        dbg_info_t->Dbg_Info5  = 5;
        dbg_info_t->Dbg_Info6  = 6;
        dbg_info_t->Dbg_Info7  = 7;
        dbg_info_t->Dbg_Info8  = 8;
        dbg_info_t->Dbg_Info9  = 9;
        dbg_info_t->Dbg_Info10 = 10;

        return TRUE;
    }

    //================================================================================================
    //                   OPEN_AU_NDBG_LOG
    //================================================================================================
    audio_tunnel* pAudio_tunnel_open_au_ndbg_log;
    pAudio_tunnel_open_au_ndbg_log = (audio_tunnel*)pVoid;

    if(AU_CUS_strcmp(pAudio_tunnel_open_au_ndbg_log->name, "OPEN_AU_NDBG_LOG", 16) == 0)
    {
        pAU_nDBG_Log_To_File        = AU_CUS_FileOpen(AU_NDBG_LOG_TO_FILE_PATH, "wb");
        pAU_nDBG_MenuLog_To_File    = AU_CUS_FileOpen(AU_NDBG_MENULOG_TO_FILE_PATH, "wb");

        pstAudioCustomerShmData->g_audio_customer_bEnableNonThreadPrintMsg = TRUE;
        pstAudioCustomerShmData->g_audio_customer_bEnableThreadPrintMsg    = TRUE;
        AU_nDBG("[global_test = 0x%x] \n", global_test);
        AU_nThreadDBG("[global_test = 0x%x] \n", global_test);
    }


    return TRUE;
}


//=====================================================================================================================================
//                   HAL_AUDIO_DebugMenu End (debug menu Always put on the bottom)
//=====================================================================================================================================

//------------------------------------------------------------------------------------------------
//Bellow must be EMPTY!!!! DO NOT add any code!!!! (For Version Check)
//------------------------------------------------------------------------------------------------

//0x9996
void AU_CUS_SHOW_ALL_VERSION(void)
{
    AU_nPRINT("\n\n\n\n\n\n");
    AU_nPRINT("[---------------------------------------------]\n");
    AU_nPRINT("[AUDIO].....ChipType......||[0x%-4X]        ||]\n", AUDIO_CHIP_TYPE);
    AU_CUS_WriteAbsReg(REG_BANK_ADEC_DSP_DBG, 0x9000);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9000]ADEC-DSP(9000)||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_CUS_WriteAbsReg(REG_BANK_ADEC_DSP_DBG, 0x9100);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9100]ADEC-DSP(9100)||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_CUS_WriteAbsReg(REG_BANK_ADEC_DSP_DBG, 0x9200);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9200]ADEC-DSP(9200)||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ADEC_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_CUS_WriteAbsReg(REG_BANK_ASND_DSP_DBG, 0x9000);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9000]SE-DSP(9000)  ||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_CUS_WriteAbsReg(REG_BANK_ASND_DSP_DBG, 0x9100);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9100]SE-DSP(9100)  ||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_CUS_WriteAbsReg(REG_BANK_ASND_DSP_DBG, 0x9200);                                                                                                          AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO_9200]SE-DSP(9200)  ||[0x%-4X][0x%-4X]||]\n", AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT1), AU_CUS_ReadAbsReg(REG_BANK_ASND_DSP_RESULT2)); AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO].....DEC-R2........||[0x%-4X]        ||]\n", AU_CUS_ReadAbsReg(REG_BANK_DEC_R2_VERSION)                                               );  AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO].....SE-R2.........||[0x%-4X]        ||]\n", AU_CUS_ReadAbsReg(REG_BANK_SND_R2_VERSION)                                               );  AU_CUS_Delay1MS(100); //100ms
    AU_nPRINT("[AUDIO].....VERSION.......||[0x%-4X][0x%-4X]||]\n", __LINE__, AU_VERSION);
    AU_nPRINT("[---------------------------------------------]\n\n\n\n\n\n");
}
//------------------------------------------------------------------------------------------------
//Bellow must be EMPTY!!!! DO NOT add any code!!!! (For Version Check)
//------------------------------------------------------------------------------------------------

#endif // #ifdef ROLLS_ROYCE
